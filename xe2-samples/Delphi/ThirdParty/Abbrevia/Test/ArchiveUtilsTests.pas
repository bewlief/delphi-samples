
//---------------------------------------------------------------------------

// This software is Copyright (c) 2011 Embarcadero Technologies, Inc. 
// You may only use this software if you are an authorized licensee
// of Delphi, C++Builder or RAD Studio (Embarcadero Products).
// This software is considered a Redistributable as defined under
// the software license agreement that comes with the Embarcadero Products
// and is subject to that software license agreement.

//---------------------------------------------------------------------------
unit ArchiveUtilsTests;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, Classes, SysUtils, AbUtils, DB, DBXUtils, ArchiveUtils, SqlExpr;

const
  cnTestFileName = 'DUnitTestFile';

type
  // Test methods for ArchiveUtils unit

  TestArchiveUtils = class(TTestCase)
  private
    procedure DoCreateFromStreamTest(const AFileName: string;
      const AItemCount: Integer); overload;
    procedure DoCreateFromStreamTest(const AStream: TStream;
      const AFileName: string; const AItemCount: Integer); overload;
    procedure DoCreateFromFieldTest(const AField: TField;
      const AFileName: string; const AItemCount: Integer);

    procedure DoCheckArchiveStreamTest(const AFileName: string);
    procedure DoCheckArchiveStringTest(const AFileName: string);
    procedure DoCompressAndEncodeStringTest(AType: TAbArchiveType);
    procedure VerifyCompressedEncodedString(const AString: string;
      const AExpected: string; AType: TAbArchiveType;
      AFileName: string = cnTestFileName);
    procedure DoCompressAndEncodeStreamTest(AType: TAbArchiveType);
    procedure DoCompressTest(AType: TAbArchiveType);
    procedure DoDecodeAndUnCompressStreamTest(AType: TAbArchiveType);
    procedure DoUnCompressStreamTest(AType: TAbArchiveType);
    procedure DoUnCompressBytesTest(AType: TAbArchiveType);
    procedure VerifyCompressedString(AArchive: TArchive; const AExpected: string);
    procedure DoCompressToStreamTest(AType: TAbArchiveType);
  public
    procedure SetUp; override;
    procedure TearDown; override;
    procedure TestArchive(const AArchive: TArchive; const AFileName: string;
      const AItemCount: integer);
  published
    procedure CreateFromStreamTest;
    procedure CompressAndEncodeStringTest;
    procedure CompressAndEncodeStreamTest;
    procedure CompressTest;
    procedure CompressToStreamTest;
    procedure EncodeTest;
    procedure DecodeAndUnCompressStreamTest;
    procedure DecodeTest;
    procedure UnCompressBytesTest;
    procedure UnCompressStreamTest;
    procedure CheckArchiveStreamTest;
    procedure CheckArchiveStringTest;
    procedure OpenArchiveTest;
    procedure FileExtFromArchiveTypeTest;
    procedure BZip2Test;

//    procedure QCAttachmentTest;
//    procedure BlobArchiveTest(AConnection: TSQLConnection; ASql,
//      AFieldName: string; AItemCount: integer);
  end;

const
  cnTestRoot = 'D:\cdn\trunk\cdn\dev\qualitycentral\Delphi\test\';
  cnTestZip = cnTestRoot + 'test.zip';
  cnTestExe = cnTestRoot + 'test.exe';
  cnTestTar = cnTestRoot + 'test.tar';
  cnTestGZip = cnTestRoot + 'test.tar.gz';
  cnTestBZip = cnTestRoot + 'test.tar.bz';
  cnTestCab = cnTestRoot + 'test.cab';

implementation

uses
  AbZipTyp, EncdDecd, Windows, AbCabTyp, AbZipKit, AbBrowse, Math,
  AbArcTyp, AbBzip2Typ;

const
  cnTestString = 'DUnit Compress and encode test';

procedure TestArchiveUtils.DoCheckArchiveStringTest(const AFileName: string);
var
  lString: string;
  lStream: TFileStream;
  lEncoded: TStringStream;
begin
  lStream := TFileStream.Create(AFileName, fmOpenRead);
  try
    lEncoded := TStringStream.Create;
    try
      EncodeStream(lStream, lEncoded);
      lString := lEncoded.DataString;
    finally
      lEncoded.Free;
    end;
  finally
    lStream.Free;
  end;
  CheckArchive(lString);
  CheckArchive(lString, ExtractFileName(AFileName));
end;

procedure TestArchiveUtils.DoCheckArchiveStreamTest(const AFileName: string);
var
  lStream: TFileStream;
begin
  lStream := TFileStream.Create(AFileName, fmOpenRead or fmShareDenyNone);
  try
    CheckArchive(lStream);
    lStream.Position := 0;
    CheckArchive(lStream, ExtractFileName(AFileName));
  finally
    lStream.Free;
  end;
end;

procedure TestArchiveUtils.BZip2Test;
  procedure DoTest(AType: TAbArchiveType);
  var
    lZipKit: TAbZipKit;
    lStream: TStringStream;
    lFileName: string;
    lMS: TMemoryStream;
  begin
    lFileName := 'd:\temp\test';
    if AType = atBzip2 then
      lFileName := lFileName + '.bz2'
    else
      lFileName := lFileName + '.tbz';
    lStream := TStringStream.Create('Test');
    try
      lZipKit := TAbZipKit.Create(nil);
      try
          lZipKit.ArchiveType := AType;
          lZipKit.ForceType := True;
          lZipKit.TarAutoHandle := True;
          lZipKit.FileName := lFileName;
          lZipKit.AddFromStream('Test', lStream);
          lZipKit.Save;
      finally
        lZipKit.Free;
      end;

      lMS := TMemoryStream.Create;
      try
        lMS.LoadFromFile(lFileName);
        lMS.Position := 0;

        lZipKit := TAbZipKit.Create(nil);
        try
          lZipKit.TarAutoHandle := True;
          lZipKit.Stream := lMS;
          lStream.Clear;
          lZipKit.ExtractToStream(lZipKit.Items[0].FileName, lStream);
          CheckEqualsString('Test', lStream.DataString);
        finally
          lZipKit.Free;
        end;
      finally
        lMS.Free;
      end;
     finally
      lStream.Free;
    end;
  end;

begin
  DoTest(atBzippedTar);
  //Stream Read Error on AbDetermineArcType call
  DoTest(atBzip2);
end;

procedure TestArchiveUtils.CheckArchiveStreamTest;
begin
  DoCheckArchiveStreamTest(cnTestZip);
  DoCheckArchiveStreamTest(cnTestExe);
  DoCheckArchiveStreamTest(cnTestTar);
  DoCheckArchiveStreamTest(cnTestGzip);
  DoCheckArchiveStreamTest(cnTestBzip);
  DoCheckArchiveStreamTest(cnTestCab);
end;

procedure TestArchiveUtils.CheckArchiveStringTest;
begin
  DoCheckArchiveStringTest(cnTestZip);
  DoCheckArchiveStringTest(cnTestExe);
  DoCheckArchiveStringTest(cnTestTar);
  DoCheckArchiveStringTest(cnTestGzip);
  DoCheckArchiveStringTest(cnTestBzip);
  DoCheckArchiveStringTest(cnTestCab);
end;

procedure TestArchiveUtils.VerifyCompressedString(AArchive: TArchive;
  const AExpected: string);
var
  lStr: TStringStream;
begin
  lStr := TStringStream.Create;
  try
    AArchive.ExtractToStream(AArchive.Items[0].FileName, lStr);
    CheckEqualsString(AExpected, lStr.DataString);
  finally
    lStr.Free;
  end;
end;

procedure TestArchiveUtils.VerifyCompressedEncodedString(const AString: string;
  const AExpected: string; AType: TAbArchiveType; AFileName: string = cnTestFileName);
var
  lMemStream: TMemoryStream;
  lStringStream: TStringStream;
  lArc: TArchive;
begin
  lStringStream := TStringStream.Create(AString);
  try
    lMemStream := TMemoryStream.Create;
    try
      DecodeStream(lStringStream, lMemStream);
      lMemStream.Position := 0;
      lArc := CreateFromStream(lMemStream, AFileName);
      try
        VerifyCompressedString(lArc, AExpected);
      finally
        lArc.Free;
      end;
    finally
      lMemStream.Free;
    end;
  finally
    lStringStream.Free;
  end;
end;

procedure TestArchiveUtils.DoCompressAndEncodeStringTest(AType: TAbArchiveType);
var
  lCompressed: string;
begin
  lCompressed := CompressAndEncode(cnTestString, cnTestFileName, AType);
  VerifyCompressedEncodedString(lCompressed, cnTestString, AType);
end;

procedure TestArchiveUtils.DoCompressTest(AType: TAbArchiveType);
var
  lArc: TArchive;
  lStream: TStringStream;
begin
  lStream := TStringStream.Create(cnTestString);
  try
    lArc := Compress(lStream, cnTestFileName, AType);
    try
      VerifyCompressedString(lArc, cnTestString);
    finally
      lArc.Free;
    end;
  finally
    lStream.Free;
  end;
end;

procedure TestArchiveUtils.DoCompressToStreamTest(AType: TAbArchiveType);
var
  lArc: TArchive;
  lStringStream: TStringStream;
  lMemStream: TMemoryStream;
begin
  lStringStream := TStringStream.Create(cnTestString);
  try
    lMemStream := TMemoryStream.Create;
    try
      CompressToStream(lStringStream, lMemStream, cnTestFileName, AType);
      lArc := CreateFromStream(lMemStream);
      try
        VerifyCompressedString(lArc, cnTestString);
      finally
        lArc.Free;
      end;
    finally
      lMemStream.Free;
    end;
  finally
    lStringStream.Free;
  end;
end;

procedure TestArchiveUtils.DoCompressAndEncodeStreamTest(AType: TAbArchiveType);
var
  lCompressed: string;
  lStream: TStringStream;
begin
  lStream := TStringStream.Create(cnTestString);
  try
    lCompressed := CompressAndEncode(lStream, cnTestFileName, AType);
  finally
    lStream.Free;
  end;
  VerifyCompressedEncodedString(lCompressed, cnTestString, AType);
end;

procedure TestArchiveUtils.CompressAndEncodeStringTest;
begin
  DoCompressAndEncodeStringTest(atZip);
  DoCompressAndEncodeStringTest(atGzip);
  DoCompressAndEncodeStringTest(atTar);
  DoCompressAndEncodeStringTest(atBzip2);
  DoCompressAndEncodeStringTest(atGzippedTar);
  DoCompressAndEncodeStringTest(atBzippedTar);
  //DoCompressAndEncodeStringTest(atCab);
end;

procedure TestArchiveUtils.CompressTest;
begin
  DoCompressTest(atZip);
  DoCompressTest(atGzip);
  DoCompressTest(atTar);
  DoCompressTest(atBzip2);
  DoCompressTest(atGzippedTar);
  DoCompressTest(atBzippedTar);
end;

procedure TestArchiveUtils.CompressToStreamTest;
begin
  DoCompressToStreamTest(atZip);
  DoCompressToStreamTest(atGzip);
  DoCompressToStreamTest(atTar);
  DoCompressToStreamTest(atBzip2);
  DoCompressToStreamTest(atGzippedTar);
  DoCompressToStreamTest(atBzippedTar);
end;

procedure TestArchiveUtils.CompressAndEncodeStreamTest;
begin
  DoCompressAndEncodeStreamTest(atZip);
  DoCompressAndEncodeStreamTest(atGzip);
  DoCompressAndEncodeStreamTest(atTar);
  DoCompressAndEncodeStreamTest(atGzippedTar);
  DoCompressAndEncodeStreamTest(atBzippedTar);
  DoCompressAndEncodeStreamTest(atBzip2);
  //DoCompressAndEncodeStreamTest(atCab);
end;

procedure TestArchiveUtils.FileExtFromArchiveTypeTest;
const
  cnExpected: array[Low(TAbArchiveType)..High(TAbArchiveType)] of string =
    ('', '.zip', '.zip', '.exe', '.tar', '.gz', '.tgz', '.cab', '.bz2', '.tbz');
var
  i: TAbArchiveType;
begin
  for i := Low(TAbArchiveType) to High(TAbArchiveType) do
    CheckEqualsString(cnExpected[i], FileExtFromArchiveType(i));
end;

procedure TestArchiveUtils.DoCreateFromFieldTest(const AField: TField;
  const AFileName: string; const AItemCount: Integer);
var
  input: TStream;
  buf: TArray<Byte>;
begin
  input := TMemoryStream.Create;
  try
    buf := AField.AsBytes;
    input.Write(buf[0], Length(buf));
    DoCreateFromStreamTest(input, AFileName, AItemCount);
  finally
    input.Free;
  end;
end;

procedure TestArchiveUtils.TestArchive(const AArchive: TArchive;
  const AFileName: string; const AItemCount: integer);
var
  lContents: TStringStream;
  lItem: TAbArchiveItem;
  lSize: int64;
begin
  CheckNotNull(AArchive, Format('%s->NotNull', [AFileName]));
  if (AArchive.ClassType = TEDNCabArchive) then
    CheckEqualsString(AFileName, ExtractFileName(AArchive.ArchiveName), Format('%s->ArchiveName', [AFileName]))
  else
    CheckEqualsString(AFileName, AArchive.ArchiveName, Format('%s->ArchiveName', [AFileName]));

  CheckEquals(AItemCount, AArchive.Count, Format('%s->Count', [AFileName]));
  if AItemCount > 0 then
  begin
    lItem := AArchive.Items[0];
    lContents := TStringStream.Create;
    try
      AArchive.ExtractToStream(lItem.FileName, lContents);
      lSize := Length(lContents.DataString);
      CheckEquals(lSize, lItem.UncompressedSize, Format('%s extracted size %d=%d',
        [lItem.FileName, lSize, lItem.UncompressedSize]));
    finally
      lContents.Free;
    end;
  end;
end;

procedure TestArchiveUtils.UnCompressBytesTest;
begin
  DoUnCompressBytesTest(atZip);
  DoUnCompressBytesTest(atGzip);
  DoUnCompressBytesTest(atTar);
  DoUnCompressBytesTest(atGzippedTar);
  DoUnCompressBytesTest(atBzippedTar);
  DoUnCompressBytesTest(atBzip2);

end;

procedure TestArchiveUtils.UnCompressStreamTest;
begin
  DoUnCompressStreamTest(atZip);
  DoUnCompressStreamTest(atGzip);
  DoUnCompressStreamTest(atTar);
  DoUnCompressStreamTest(atGzippedTar);
  DoUnCompressStreamTest(atBzippedTar);
  DoUnCompressStreamTest(atBzip2);
end;

procedure TestArchiveUtils.DoCreateFromStreamTest(const AStream: TStream;
  const AFileName: string; const AItemCount: Integer);
var
  lArchive: TArchive;
  lArcName: string;

begin
  lArcName := ExtractFileName(AFileName);
  lArchive := CreateFromStream(AStream, lArcName);
  try
    TestArchive(lArchive, lArcName, AItemCount);
  finally
    lArchive.Free;
  end;
end;

procedure TestArchiveUtils.DoCreateFromStreamTest(const AFileName: string;
  const AItemCount: Integer);
var
  lStream: TFileStream;
begin
  lStream := TFileStream.Create(AFileName, fmOpenRead or fmShareDenyNone);
  try
    DoCreateFromStreamTest(lStream, AFileName, AItemCount);
  finally
    lStream.Free;
  end;
end;


procedure TestArchiveUtils.CreateFromStreamTest;
begin
    DoCreateFromStreamTest(cnTestZip, 4);
    DoCreateFromStreamTest(cnTestExe, 4);
    DoCreateFromStreamTest(cnTestTar, 3);
    DoCreateFromStreamTest(cnTestGzip, 3);
    DoCreateFromStreamTest(cnTestBzip, 3);
    DoCreateFromStreamTest(cnTestCab, 3);
end;

procedure TestArchiveUtils.DoDecodeAndUnCompressStreamTest(AType: TAbArchiveType);
var
  lEncoded: string;
  lStream: TStringStream;
  lDecoded: string;
begin
  lEncoded := CompressAndEncode(cnTestString, cnTestFileName, AType);
  VerifyCompressedEncodedString(lEncoded, cnTestString, AType);
  lStream := TStringStream.Create(lEncoded);
  try
    lDecoded := DecodeAndUnCompress(lStream);
    CheckEqualsString(cnTestString, lDecoded);

    lStream.Position := 0;
    lDecoded := DecodeAndUnCompress(lStream);
    CheckEqualsString(cnTestString, lDecoded);
  finally
    lStream.Free;
  end;
end;


procedure TestArchiveUtils.DoUnCompressStreamTest(AType: TAbArchiveType);
var
  lEncoded: string;
  lStream: TBytesStream;
  lDecoded: TBytes;
  lUncompressed: string;
begin
  lEncoded := CompressAndEncode(cnTestString, cnTestFileName, AType);
  lDecoded := DecodeBytes(lEncoded);
  lStream := TBytesStream.Create(lDecoded);
  try
    lStream.Position := 0;
    lUncompressed := UnCompress(lStream);
    CheckEqualsString(cnTestString, lUncompressed);
  finally
    lStream.Free;
  end;
end;

procedure TestArchiveUtils.DoUnCompressBytesTest(AType: TAbArchiveType);
var
  lEncoded: string;
  lDecoded: TBytes;
  lUncompressed: string;
begin
  lEncoded := CompressAndEncode(cnTestString, cnTestFileName, AType);
  lDecoded := DecodeBytes(lEncoded);
  lUncompressed := UnCompress(lDecoded);
  CheckEqualsString(cnTestString, lUncompressed);
end;

procedure TestArchiveUtils.DecodeAndUnCompressStreamTest;
begin
  DoDecodeAndUnCompressStreamTest(atZip);
  DoDecodeAndUnCompressStreamTest(atGzip);
  DoDecodeAndUnCompressStreamTest(atTar);
  DoDecodeAndUnCompressStreamTest(atGzippedTar);
  DoDecodeAndUnCompressStreamTest(atBzippedTar);
  DoDecodeAndUnCompressStreamTest(atBzip2);
  //DoDecodeAndUnCompressStreamTest(atCab);
end;

procedure TestArchiveUtils.DecodeTest;
begin

end;

procedure TestArchiveUtils.EncodeTest;
begin

end;

procedure TestArchiveUtils.OpenArchiveTest;
begin

end;

procedure TestArchiveUtils.SetUp;
begin
  inherited;
end;

procedure TestArchiveUtils.TearDown;
begin
  inherited;
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestArchiveUtils.Suite);

end.

