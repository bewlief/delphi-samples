{*******************************************************}
{                                                       }
{            Delphi Visual Component Library            }
{                                                       }
{ Copyright(c) 1995-2022 Embarcadero Technologies, Inc. }
{              All rights reserved                      }
{                                                       }
{*******************************************************}
unit ExpertsProjectCreators;

interface

uses ToolsApi, ExpertsBaseCreators, ExpertsIntf, SysUtils, ExpertsProject;

type
  TExpertsProjectCreator = class(TCreator, IOTACreator, IOTAProjectCreator, IOTAProjectCreator80, IOTAProjectCreator160, IOTAProjectCreator190)
  private
    FExpertsProject: IExpertsProjectAccessor;
    FPersonality: string;
    property Personality: string read FPersonality;
    function InternalGetPlatforms(const OSFamily: TOSFamilySet): TArray<string>;
    { IOTACreator }
    function GetCreatorType: string;
    { IOTAProjectCreator80 }
    function GetProjectPersonality: string;
    { IOTAProjectCreator }
    function GetFileName: string;
    function GetOptionFileName: string;
    function GetShowSource: Boolean;
    procedure NewDefaultModule;
    function NewOptionSource(const ProjectName: string): IOTAFile;
    procedure NewProjectResource(const Project: IOTAProject);
    function NewProjectSource(const ProjectName: string): IOTAFile;
    { IOTAProjectCreator50 }
    procedure NewDefaultProjectModule(const Project: IOTAProject);
    { IOTACreator }
    function GetUnnamed: Boolean;
    { IOTAProjectCreator160 }
    function GetFrameworkType: string;
    function GetPlatformTypes: TOSFamilySet;
    function GetPlatforms: TArray<string>;
    function GetPreferredPlatform: string;
    procedure SetInitialOptions(const NewProject: IOTAProject);
    { IOTAProjectCreator190 }
    function GetSupportedPlatforms: TArray<string>;
    function GetSupportedPlatformTypes: TOSFamilySet;
  public
    constructor Create(const APersonality: string; const AExpertsProject: IExpertsProjectAccessor);
  end;




implementation

uses PlatformAPI, System.Classes, BCCStrs, ILinkStrs;

{ TProjectCreator }

constructor TExpertsProjectCreator.Create(const APersonality: string; const AExpertsProject: IExpertsProjectAccessor);
begin
  FPersonality := APersonality;
  FExpertsProject := AExpertsProject;
end;

function TExpertsProjectCreator.GetCreatorType: string;
begin
  Result := FExpertsProject.GetCreatorType;
end;

//function DefaultProjectFile(const APersonality: string; const ADirectory: string): string;
//  function ValidProjectName(var AFileName: string): Boolean;
//  var
//    LBaseName: string;
//    I: Integer;
//  begin
//    Result := False;
//    LBaseName := ChangeFileExt(AFileName, '');
//    if (Length(LBaseName) > 0) then
//    begin
//      Result := True;
//      for I := 1 to Length(LBaseName) do
//        if not (CharInSet(LBaseName[I], ['0'..'9','A'..'Z','a'..'z','_'])) then
//          LBaseName[I] := '_';
//      AFileName := ChangeFileExt(LBaseName, ExtractFileExt(AFileName));
//    end;
//  end;
//var
//  LTemplate: string;
//  I: Integer;
//  LExt: string;
//begin
//  if APersonality = sCBuilderPersonality then
//    LExt := '.cpp'
//  else
//    LExt := '.dpr';
//
//  Result := ChangeFileExt(ExtractFileName(ExcludeTrailingPathDelimiter(ADirectory)), LExt);
//  if ValidProjectName(Result) and  not FileExists(IncludeTrailingPathDelimiter(ADirectory) + Result) then
//    Exit;
//  LTemplate := 'Project%d' + LExt;
//  I := 1;
//  repeat
//    Result := Format(LTemplate, [I]);
//  Inc(I);
//  until not FileExists(IncludeTrailingPathDelimiter(ADirectory) + Result);
//end;

//function DefaultProjectDirectory: string;
//var
//  LTemplate: string;
//  I: Integer;
//begin
//  LTemplate := IncludeTrailingPathDelimiter((BorlandIDEServices as IOTAServices).GetStartupDirectory) +
//    sProjectDirTemplate;
//  I := 1;
//  repeat
//    Result := Format(LTemplate, [I]);
//  Inc(I);
//  until not DirectoryExists(Result);
//end;

function TExpertsProjectCreator.GetFileName: string;
var
  LSuffix: string;
  LFileName: string;
  LDirectory: string;
begin
  Result := '';
  LDirectory := FExpertsProject.GetDirectory;
  LFileName := FExpertsProject.GetFileName;
  // For cpppackages always generate a file name.  The default name generated by the IDE has the wrong extension
  if (LDirectory <> '') or (LFileName <> '') or SameText(GetCreatorType, 'cpppackage')  then
  begin
    if LFileName <> '' then
    begin
      if Personality = sCBuilderPersonality then
        LFileName := ChangeFileExt(LFileName, '.cpp')
      else
        LFileName := ChangeFileExt(LFileName, '.dpr');
    end;
    if LDirectory = '' then
    begin
      LDirectory := (BorlandIDEServices as IOTAServices).GetStartupDirectory;
    end;
    Result := GetNewModuleFileName('Project', LDirectory,                            
      LFileName, False, LSuffix, '.bdsproj;.dproj;.dpr;.dpk;.cbproj')
  end;
end;

function TExpertsProjectCreator.GetFrameworkType: string;
begin
  Result := FExpertsProject.GetFrameWorkType;
end;

function TExpertsProjectCreator.GetOptionFileName: string;
begin
  Result := '';
end;

function TExpertsProjectCreator.InternalGetPlatforms(
  const OSFamily: TOSFamilySet): TArray<string>;
begin
  if osfLinux in OSFamily then
    Result := TArray<string>.Create(cWin32Platform, cWin64Platform, cLinux64Platform)
  else
    Result := TArray<string>.Create(cWin32Platform, cWin64Platform);
end;

function TExpertsProjectCreator.GetPlatforms: TArray<string>;
begin
  Result := InternalGetPlatforms(GetPlatformTypes);
end;

function TExpertsProjectCreator.GetSupportedPlatforms: TArray<string>;
begin
  Result := InternalGetPlatforms(GetSupportedPlatformTypes);
end;

function TExpertsProjectCreator.GetPlatformTypes: TOSFamilySet;
begin
  Result := FExpertsProject.GetPlatformTypes;
end;

function TExpertsProjectCreator.GetSupportedPlatformTypes: TOSFamilySet;
var
  LProjectAccessor: IExpertsProjectAccessor190;
begin
  Result := [osfWindows];
  if Supports(FExpertsProject, IExpertsProjectAccessor190, LProjectAccessor) then
    Result := LProjectAccessor.GetProjectPlatformTypes
end;

function TExpertsProjectCreator.GetPreferredPlatform: string;
begin
  Result := GetPlatforms[0];
end;

function TExpertsProjectCreator.GetProjectPersonality: string;
begin
  Result := Personality;
end;

function TExpertsProjectCreator.GetShowSource: Boolean;
begin
  Result := True;
end;

function TExpertsProjectCreator.GetUnnamed: Boolean;
begin
  Result := FExpertsProject.GetUnnamed;
end;

procedure TExpertsProjectCreator.NewDefaultModule;
begin
  FExpertsProject.NewDefaultModule;
end;

procedure TExpertsProjectCreator.NewDefaultProjectModule(const Project: IOTAProject);
begin
  NewDefaultModule;
end;

function TExpertsProjectCreator.NewOptionSource(const ProjectName: string): IOTAFile;
begin
  Result := nil;
end;

procedure TExpertsProjectCreator.NewProjectResource(const Project: IOTAProject);
begin
  { do nothing here }
end;

function TExpertsProjectCreator.NewProjectSource(const ProjectName: string): IOTAFile;
begin
  Result :=  FExpertsProject.NewProjectSource(ProjectName);
end;

procedure TExpertsProjectCreator.SetInitialOptions(
  const NewProject: IOTAProject);
var
  PS: IOTAPlatformServices;
  Configuration: IOTABuildConfiguration;
  POC: IOTAProjectOptionsConfigurations;
  ModuleInfo: IOTAModuleInfo;
  i: integer;
  LibraryPath: string;
  APlatform: string;
begin
  if Personality = sCBuilderPersonality then
  begin
    // Look for default pch file and set initial options
    if Supports(NewProject.ProjectOptions, IOTAProjectOptionsConfigurations, POC) then
    begin
      for i:=0 to NewProject.GetModuleCount -1 do
      begin
        ModuleInfo := NewProject.GetModule(i);
        if ExtractFileExt(ModuleInfo.FileName) = '.h' then
        begin
          POC.BaseConfiguration.PlatformConfiguration[cWin64Platform][BCCStrs.sPCHName_Clang] := ExtractFileName(ModuleInfo.FileName);
          ModuleInfo.BuildAction := sbaPCHCompile;
        end;
      end;

      PS := BorlandIDEServices as IOTAPlatformServices;
      if (PS <> nil) then
      begin
        for APlatform in [cWin32Platform, cWin64Platform] do
          if PS.PlatformExists(APlatform) and PS.PlatformSupports(APlatform, psClangPCHSupport) then
          begin
            if APlatform = cWin32Platform then
            begin
              for i := 0 to POC.ConfigurationCount - 1 do
              begin
                Configuration := POC.Configurations[i];
                if Configuration <> POC.BaseConfiguration then
                begin
                  // Default new WIN32 project to use CLANG
                  Configuration.PlatformConfiguration[APlatform].AsBoolean[BCCStrs.sUseClassicCompiler] := False;
                  // Default new WIN32 projects to enable LSP indexing
                  Configuration.PlatformConfiguration[APlatform].AsBoolean[BCCStrs.sEnableLSPIndexing] := True;

                  // Default new WIN32 project to use $(PLATFORM)$(CC_SUFFIX)
                  LibraryPath := Configuration.PlatformConfiguration[APlatform][ILinkStrs.sLibraryPath];
                  if LibraryPath <> '' then
                  begin
                    LibraryPath := StringReplace(LibraryPath, '$(BDSLIB)\$(PLATFORM)\', '$(BDSLIB)\$(PLATFORM)$(CC_SUFFIX)\', [rfReplaceAll, rfIgnoreCase]);
                    Configuration.PlatformConfiguration[APlatform][ILinkStrs.sLibraryPath] := LibraryPath;
                  end;
                end;
              end;
            end
            else
            begin
              for i := 0 to POC.ConfigurationCount - 1 do
              begin
                Configuration := POC.Configurations[i];
                if Configuration <> POC.BaseConfiguration then
                begin
                  // Default new WIN64 projects to enable LSP indexing
                  Configuration.PlatformConfiguration[APlatform].AsBoolean[BCCStrs.sEnableLSPIndexing] := True;
                end;
              end;
            end;
          end;
      end;
    end;
  end;
end;



end.
