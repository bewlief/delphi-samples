{*******************************************************}
{                                                       }
{           CodeGear Delphi Runtime Library             }
{ Copyright(c) 2014-2022 Embarcadero Technologies, Inc. }
{              All rights reserved                      }
{                                                       }
{*******************************************************}

unit System.Net.HttpClientComponent;

interface

{$SCOPEDENUMS ON}

uses
  System.Sysutils, System.Classes, System.Generics.Collections, System.Types,
  System.Net.URLClient, System.Net.HttpClient, System.Net.Mime;

type
// ------------------------------------------------------------------------------------------------------------------ //
// ------------------------------------------------------------------------------------------------------------------ //

  ///  <summary> Request completion Event signature</summary>
  ///  <param name="Sender"> TNetHTTPClient or TNetHTTPRequest that invoked the Event</param>
  ///  <param name="AResponse">Response generated by the request</param>
  TRequestCompletedEvent = procedure(const Sender: TObject; const AResponse: IHTTPResponse) of object;
  ///  <summary> Request error Event signature</summary>
  ///  <param name="Sender"> TNetHTTPClient or TNetHTTPRequest that invoked the Event</param>
  ///  <param name="AError">Error generated by the request</param>
  TRequestErrorEvent = procedure(const Sender: TObject; const AError: string) of object;
  ///  <summary> Request exception Event signature</summary>
  ///  <param name="Sender"> TNetHTTPClient or TNetHTTPRequest that invoked the Event</param>
  ///  <param name="AError">Exception generated by the request</param>
  TRequestExceptionEvent = procedure(const Sender: TObject; const AError: Exception) of object;

// ------------------------------------------------------------------------------------------------------------------ //
// ------------------------------------------------------------------------------------------------------------------ //

  /// <summary>Component to Manage an HTTPClient</summary>
  TNetHTTPClient = class(TComponent)
  private
    FHttpClient: THTTPClient;
    FOnAuthEvent: TCredentialsStorage.TCredentialAuthevent;
    FOnNeedClientCertificate: TNeedClientCertificateEvent;
    FOnValidateServerCertificate: TValidateCertificateEvent;
    FOnRequestCompleted: TRequestCompletedEvent;
    FOnRequestError: TRequestErrorEvent;
    FOnRequestException: TRequestExceptionEvent;
    FOnSendData: TSendDataEvent;
    FOnReceiveData: TReceiveDataEvent;
    FAsynchronous: Boolean;
    FSynchronizeEvents: Boolean;

    procedure DoOnAuthEvent(const Sender: TObject; AnAuthTarget: TAuthTargetType;
      const ARealm, AURL: string; var AUserName, APassword: string; var AbortAuth: Boolean;
      var Persistence: TAuthPersistenceType);
    procedure DoOnNeedClientCertificate(const Sender: TObject;
      const ARequest: TURLRequest; const ACertificateList: TCertificateList;
      var AnIndex: Integer);
    procedure DoOnValidateServerCertificate(const Sender: TObject;
      const ARequest: TURLRequest; const Certificate: TCertificate;
      var Accepted: Boolean);
    procedure DoOnRequestCompleted(const Sender: TObject; const AResponse: IHTTPResponse);
    procedure DoOnRequestError(const Sender: TObject; const AException: Exception);
    procedure DoOnSendData(const Sender: TObject; AContentLength, AWriteCount: Int64; var AAbort: Boolean);
    procedure DoOnReceiveData(const Sender: TObject; AContentLength, AReadCount: Int64; var AAbort: Boolean);

    procedure DoOnAsyncRequestCompleted(const AAsyncResult: IAsyncResult);

    function GetMaxRedirects: Integer;
    procedure SetMaxRedirects(const Value: Integer);
    procedure SetOnAuthEvent(const Value: TCredentialsStorage.TCredentialAuthevent);
    procedure SetOnNeedClientCertificate(const Value: TNeedClientCertificateEvent);
    procedure SetOnValidateServerCertificate(const Value: TValidateCertificateEvent);
    procedure SetOnSendData(const Value: TSendDataEvent);
    procedure SetOnReceiveData(const Value: TReceiveDataEvent);
    function GetProxySettings: TProxySettings;
    procedure SetProxySettings(const Value: TProxySettings);
    function GetAllowCookies: Boolean;
    procedure SetAllowCookies(const Value: Boolean);
    function GetCookieManager: TCookieManager;
    procedure SetCookieManager(const Value: TCookieManager);
    function GetHandleRedirects: Boolean;
    procedure SetHandleRedirects(const Value: Boolean);
    function GetCustHeaders: TURLHeaders;
    function GetCustomHeaderValue(const AName: string): string;
    procedure SetCustomHeaderValue(const AName, Value: string);
    function GetAccept: string;
    function GetAcceptCharSet: string;
    function GetAcceptEncoding: string;
    function GetAcceptLanguage: string;
    function GetContentType: string;
    procedure SetAccept(const Value: string);
    procedure SetAcceptCharSet(const Value: string);
    procedure SetAcceptEncoding(const Value: string);
    procedure SetAcceptLanguage(const Value: string);
    procedure SetContentType(const Value: string);
    function GetCredentialsStorage: TCredentialsStorage;
    procedure SetCredentialsStorage(const Value: TCredentialsStorage);
    function GetUserAgent: string;
    procedure SetUserAgent(const Value: string);
    function GetConnectionTimeout: Integer;
    function GetResponseTimeout: Integer;
    procedure SetConnectionTimeout(const Value: Integer);
    procedure SetResponseTimeout(const Value: Integer);
    function GetRedirectsWithGET: THTTPRedirectsWithGET;
    function GetSecureProtocols: THTTPSecureProtocols;
    procedure SetRedirectsWithGET(const AValue: THTTPRedirectsWithGET);
    procedure SetSecureProtocols(const AValue: THTTPSecureProtocols);
    function GetSecureFailureReasons: THTTPSecureFailureReasons;
    function GetPreemptiveAuthentication: Boolean;
    procedure SetPreemptiveAuthentication(const AValue: Boolean);
    function GetUseDefaultCredentials: Boolean;
    procedure SetUseDefaultCredentials(const AValue: Boolean);
    function GetAutomaticDecompression: THTTPCompressionMethods;
    procedure SetAutomaticDecompression(const AValue: THTTPCompressionMethods);
    function GetSendTimeout: Integer;
    procedure SetSendTimeout(const AValue: Integer);
    function GetProtocolVersion: THTTPProtocolVersion;
    procedure SetProtocolVersion(const Value: THTTPProtocolVersion);

  protected
    class procedure HandleEvent(ASynchronizedEvents: Boolean; AThreadProc: TThreadProcedure); static;

  public
    /// <summary> Initializes the HTTPComponent </summary>
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    // ------------------------------------------- //
    // Standard HTTP Methods
    // ------------------------------------------- //
    /// <summary>Send 'DELETE' command to url</summary>
    function Delete(const AURL: string; const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'OPTIONS' command to url</summary>
    function Options(const AURL: string; const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'GET' command to url</summary>
    function Get(const AURL: string; const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'TRACE' command to url</summary>
    function Trace(const AURL: string; const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'HEAD' command to url</summary>
    function Head(const AURL: string; const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'GET' command to url adding Range header</summary>
    /// <remarks>It's used for resume downloads</remarks>
    function GetRange(const AURL: string; AStart: Int64; AnEnd: Int64 = -1; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Post a raw file without multipart info</summary>
    function Post(const AURL: string; const ASourceFile: string; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;
    /// <summary>Post TStrings values adding multipart info</summary>
    function Post(const AURL: string; const ASource: TStrings; const AResponseContent: TStream = nil;
      const AEncoding: TEncoding = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;
    /// <summary>Post a stream without multipart info</summary>
    function Post(const AURL: string; const ASource: TStream; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;
    /// <summary>Post a multipart form data object</summary>
    function Post(const AURL: string; const ASource: TMultipartFormData; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;

    /// <summary>Put a raw file without multipart info</summary>
    function Put(const AURL: string; const ASourceFile: string; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;
    /// <summary>Put TStrings values adding multipart info</summary>
    function Put(const AURL: string; const ASource: TStrings; const AResponseContent: TStream = nil;
      const AEncoding: TEncoding = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;
    /// <summary>Send 'PUT' command to url without multipart info</summary>
    function Put(const AURL: string; const ASource: TStream = nil; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;
    /// <summary>Put a multipart form data object</summary>
    function Put(const AURL: string; const ASource: TMultipartFormData; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;

    // Non standard command procedures ...
    /// <summary>Send 'MERGE' command to url</summary>
    function Merge(const AURL: string; const ASource: TStream; const AHeaders: TNetHeaders = nil): IHTTPResponse;
    /// <summary>Send a special 'MERGE' command to url. Command based on a 'PUT' + 'x-method-override' </summary>
    function MergeAlternative(const AURL: string; const ASource: TStream;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;
    /// <summary>Send 'PATCH' command to url</summary>
    function Patch(const AURL: string; const ASource: TStream = nil; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;
    /// <summary>Send a special 'PATCH' command to url. Command based on a 'PUT' + 'x-method-override' </summary>
    function PatchAlternative(const AURL: string; const ASource: TStream = nil; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;

    /// <summary>You have to use this function to Execute a given Request</summary>
    /// <param name="ARequest">The request that is going to be Executed</param>
    /// <param name="AContentStream">The stream to store the response data. If provided the user is responsible
    /// of releasing it. If not provided will be created internally and released when not needed.</param>
    /// <returns>The platform dependant response object associated to the given request. It's an Interfaced object and
    /// It's released automatically.</returns>
    function Execute(const ARequest: IHTTPRequest; const AContentStream: TStream = nil): IHTTPResponse; overload;

    /// <summary>You have to use this function to Execute a Request</summary>
    /// <remarks></remarks>
    /// <param name="ARequestMethod">The request method that is going to be Executed</param>
    /// <param name="AURI">The URI that contains the information for the request that is going to be Executed</param>
    /// <param name="ASourceStream">The stream to provide the request data.</param>
    /// <param name="AContentStream">The stream to store the response data. If provided the user is responsible
    /// of releasing it. If not provided will be created internally and released when not needed.</param>
    /// <param name="AHeaders">Additions headers to be passed to the request that is going to be Executed</param>
    /// <returns>The platform dependant response object associated to the given request. It's an Interface and It's
    /// released automatically.</returns>
    function Execute(const ARequestMethod: string; const AURI: TURI; const ASourceStream: TStream = nil;
      const AContentStream: TStream = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;

    /// <summary>You have to use this function to Execute a given Request</summary>
    /// <remarks></remarks>
    /// <param name="ARequestMethod">The request method that is going to be Executed</param>
    /// <param name="AURIStr">The URI string that contains the information for the request that is going to be Executed</param>
    /// <param name="ASourceStream">The stream to provide the request data.</param>
    /// <param name="AContentStream">The stream to store the response data. If provided the user is responsible
    /// of releasing it. If not provided will be created internally and released when not needed.</param>
    /// <param name="AHeaders">Additions headers to be passed to the request that is going to be Executed</param>
    /// <returns>The platform dependant response object associated to the given request. It's an Interface and It's
    /// released automatically.</returns>
    function Execute(const ARequestMethod: string; const AURIStr: string; const ASourceStream: TStream = nil;
      const AContentStream: TStream = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse; overload; inline;

    /// <summary> Cookie manager object to be used by the client.</summary>
    property CookieManager: TCookieManager read GetCookieManager write SetCookieManager;
    /// <summary> CustomHeaders to be used by the client.</summary>
    property CustomHeaders[const AName: string]: string read GetCustomHeaderValue write SetCustomHeaderValue;
    /// <summary> CustHeaders is TURLHeaders object managing custom headers to be used by the client.</summary>
    property CustHeaders: TURLHeaders read GetCustHeaders;

    /// <summary> Credentials Storage to be used by the client</summary>
    property CredentialsStorage: TCredentialsStorage read GetCredentialsStorage write SetCredentialsStorage;

    /// <summary> Proxy Settings to be used by the client.</summary>
    property ProxySettings: TProxySettings read GetProxySettings write SetProxySettings;

    /// <summary>Property returns a set of reasons, why OnValidateServerCertificate or
    /// ValidateServerCertificateCallback events was called. It is platform dependent and
    /// currently supported on Windows and Linux. </summary>
    property SecureFailureReasons: THTTPSecureFailureReasons read GetSecureFailureReasons;
  published
    /// <summary>Property to indicate if the requests are going to be Synchronous or Asynchronous</summary>
    property Asynchronous: Boolean read FAsynchronous write FAsynchronous default False;
    /// <summary>Specifies if Events should run in the context of the main thread (True) or in the context of an arbitrary thread</summary>
    property SynchronizeEvents: Boolean read FSynchronizeEvents write FSynchronizeEvents default True;

    /// <summary> Property to set the ConnectionTimeout</summary>
    property ConnectionTimeout: Integer read GetConnectionTimeout write SetConnectionTimeout
      default TURLClient.DefaultConnectionTimeout;
    /// <summary> Property to set the SendTimeout</summary>
    property SendTimeout: Integer read GetSendTimeout write SetSendTimeout
      default TURLClient.DefaultSendTimeout;
    /// <summary> Property to set the ResponseTimeout</summary>
    property ResponseTimeout: Integer read GetResponseTimeout write SetResponseTimeout
      default TURLClient.DefaultResponseTimeout;

    /// <summary> Specifies HTTP protocol version to use. Default value is UNKNOWN_HTTP - use default HTTP library protocol. </summary>
    property ProtocolVersion: THTTPProtocolVersion read GetProtocolVersion
      write SetProtocolVersion default THTTPProtocolVersion.UNKNOWN_HTTP;

    /// <summary> Redirection policy to be used by the client.</summary>
    property HandleRedirects: Boolean read GetHandleRedirects write SetHandleRedirects default True;
    /// <summary> Maximum number of redirects</summary>
    property MaxRedirects: Integer read GetMaxRedirects write SetMaxRedirects default 5;
    property RedirectsWithGET: THTTPRedirectsWithGET read GetRedirectsWithGET
      write SetRedirectsWithGET default CHTTPDefRedirectsWithGET;

    /// <summary> Cookies policy to be used by the client.</summary>
    /// <remarks>If false the cookies from server will not be accepted,
    /// but the cookies in the cookie manager will be sent.</remarks>
    property AllowCookies: Boolean read GetAllowCookies write SetAllowCookies default True;

    /// <summary>Property to manage the 'Accept' header</summary>
    property Accept: string read GetAccept write SetAccept;
    /// <summary>Property to manage the 'Accept-CharSet' header</summary>
    property AcceptCharSet: string read GetAcceptCharSet write SetAcceptCharSet;
    /// <summary>Property to manage the 'Accept-Encoding' header</summary>
    property AcceptEncoding: string read GetAcceptEncoding write SetAcceptEncoding;
    /// <summary>Property to manage the 'Accept-Language' header</summary>
    property AcceptLanguage: string read GetAcceptLanguage write SetAcceptLanguage;
    /// <summary>Property to manage the 'Content-Type' header</summary>
    property ContentType: string read GetContentType write SetContentType;
    /// <summary> Property to set the UserAgent sent with the request </summary>
    property UserAgent: string read GetUserAgent write SetUserAgent;

    property SecureProtocols: THTTPSecureProtocols read GetSecureProtocols
      write SetSecureProtocols default CHTTPDefSecureProtocols;

    /// <summary>Property controls preemptive authentication. When set to True, then
    /// basic authentication will be provided before the server gives an unauthorized response. </summary>
    property PreemptiveAuthentication: Boolean read GetPreemptiveAuthentication
      write SetPreemptiveAuthentication default False;
    /// <summary>Property controls automatic usage of logged user credentials
    /// for NTLM and Negotiate authentication schemas. It is platform dependent and
    /// currently supported on Windows and Linux. </summary>
    property UseDefaultCredentials: Boolean read GetUseDefaultCredentials
      write SetUseDefaultCredentials default True;

    /// <summary>Property controls automatic decompression of response body.
    /// It is platform dependent and currently supported on Windows and Linux.
    /// When set, then corresponding "Accept-Encoding" header will be included
    /// into request, and response body will be automatically decoded. On iOS,
    /// macOS and Android platforms decoding is performed automatically. </summary>
    property AutomaticDecompression: THTTPCompressionMethods
      read GetAutomaticDecompression write SetAutomaticDecompression
      default [];

    /// <summary> Event fired when a ClientCertificate is needed</summary>
    property OnNeedClientCertificate: TNeedClientCertificateEvent read FOnNeedClientCertificate write SetOnNeedClientCertificate;
    /// <summary> Event fired when checking the validity of a Server Certificate</summary>
    property OnValidateServerCertificate: TValidateCertificateEvent read FOnValidateServerCertificate write SetOnValidateServerCertificate;

    /// <summary> UserName needed to be authenticated to the proxy</summary>
    property OnAuthEvent: TCredentialsStorage.TCredentialAuthevent read FOnAuthEvent write SetOnAuthEvent;

    /// <summary> Event fired when a request finishes</summary>
    property OnRequestCompleted: TRequestCompletedEvent read FOnRequestCompleted write FOnRequestCompleted;
    /// <summary> Event fired when a request has an error</summary>
    property OnRequestError: TRequestErrorEvent read FOnRequestError write FOnRequestError;
    /// <summary> Event fired when a request has an exception</summary>
    property OnRequestException: TRequestExceptionEvent read FOnRequestException write FOnRequestException;

    /// <summary>Property to manage the SendData Event</summary>
    property OnSendData: TSendDataEvent read FOnSendData write SetOnSendData;
    /// <summary>Property to manage the ReceiveData Event</summary>
    property OnReceiveData: TReceiveDataEvent read FOnReceiveData write SetOnReceiveData;
  end;

// ------------------------------------------------------------------------------------------------------------------ //
// ------------------------------------------------------------------------------------------------------------------ //

  /// <summary>Component to handle HTTP Requests</summary>
  TNetHTTPRequest = class(TComponent)
  private
    FClient: TNetHTTPClient;

    FContentStream: TStream;
    FSourceStream: TStream;

    FURL: string;
    FMethodString: string;

    FHttpRequest: IHTTPRequest;
    FHttpResponse: IHTTPResponse;

    FOnRequestCompleted: TRequestCompletedEvent;
    FOnRequestError: TRequestErrorEvent;
    FOnRequestException: TRequestExceptionEvent;
    FOnSendData: TSendDataEvent;
    FOnReceiveData: TReceiveDataEvent;
    FCustomHeaders: TURLHeaders;
    FAsynchronous: Boolean;
    FConnectionTimeout: Integer;
    FSendTimeout: Integer;
    FResponseTimeout: Integer;
    FSynchronizeEvents: Boolean;

    FClientCertificatePassword: string;
    FClientCertificatePath: string;
    FClientCertificateStream: TStream;

    procedure DoOnRequestCompleted(const Sender: TObject; const AResponse: IHTTPResponse);
    procedure DoOnRequestError(const Sender: TObject; const AException: Exception);
    procedure DoOnSendData(const Sender: TObject; AContentLength, AWriteCount: Int64; var AAbort: Boolean);
    procedure DoOnReceiveData(const Sender: TObject; AContentLength, AReadCount: Int64; var AAbort: Boolean);

    procedure DoOnAsyncRequestCompleted(const AAsyncResult: IAsyncResult);

    procedure SetClient(const Value: TNetHTTPClient);
    procedure SetOnSendData(const Value: TSendDataEvent);
    procedure SetOnReceiveData(const Value: TReceiveDataEvent);

    procedure CheckClient;
    function GetRequest(const AMethod: string; const AURL: string; const ASourceStream: TStream;
      AOwnsSourceStream: Boolean = False): IHTTPRequest;
    function GetAccept: string;
    function GetAcceptCharSet: string;
    function GetAcceptEncoding: string;
    function GetAcceptLanguage: string;
    procedure SetAccept(const Value: string);
    procedure SetAcceptCharSet(const Value: string);
    procedure SetAcceptEncoding(const Value: string);
    procedure SetAcceptLanguage(const Value: string);
    function GetCustomHeaderValue(const AName: string): string;
    procedure SetCustomHeaderValue(const AName, Value: string);
    function GetIsCancelled: Boolean;

    procedure SetClientCertificatePath(const Value: string);
    procedure SetClientCertificateStream(const Value: TStream);

  protected
    /// <summary> Notification method to process component adding or removal from a form/datamodule</summary>
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;

    /// <summary>You have to use this function to Execute the internal Request</summary>
    function DoExecute(const ARequest: IHTTPRequest; const AResponseContent: TStream; const AHeaders: TNetHeaders;
      AOwnsSourceStream: Boolean = False): IHTTPResponse;

  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    // ------------------------------------------- //
    // Standard HTTP Methods
    // ------------------------------------------- //
    /// <summary>Send 'DELETE' command to url</summary>
    function Delete(const AURL: string; const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'OPTIONS' command to url</summary>
    function Options(const AURL: string; const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'GET' command to url</summary>
    function Get(const AURL: string; const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'TRACE' command to url</summary>
    function Trace(const AURL: string; const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'HEAD' command to url</summary>
    function Head(const AURL: string; const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'GET' command to url adding Range header</summary>
    /// <remarks>It's used for resume downloads</remarks>
    function GetRange(const AURL: string; AStart: Int64; AnEnd: Int64 = -1; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Post a raw file without multipart info</summary>
    function Post(const AURL: string; const ASourceFile: string; AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;
    /// <summary>Post TStrings values adding multipart info</summary>
    function Post(const AURL: string; const ASource: TStrings; const AResponseContent: TStream = nil;
      const AEncoding: TEncoding = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;
    /// <summary>Post a stream without multipart info</summary>
    function Post(const AURL: string; const ASource: TStream; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;
    /// <summary>Post a multipart form data object</summary>
    function Post(const AURL: string; const ASource: TMultipartFormData; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;

    /// <summary>Put a raw file without multipart info</summary>
    function Put(const AURL: string; const ASourceFile: string; AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;
    /// <summary>Put TStrings values adding multipart info</summary>
    function Put(const AURL: string; const ASource: TStrings; const AResponseContent: TStream = nil;
      const AEncoding: TEncoding = nil; const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;
    /// <summary>Send 'PUT' command to url</summary>
    function Put(const AURL: string; const ASource: TStream = nil; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;
    /// <summary>Put a multipart form data object</summary>
    function Put(const AURL: string; const ASource: TMultipartFormData; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;

    // Non standard command procedures ...
    /// <summary>Send 'MERGE' command to url</summary>
    function Merge(const AURL: string; const ASource: TStream; const AHeaders: TNetHeaders = nil): IHTTPResponse;
    /// <summary>Send 'MERGE' command to url</summary>
    function MergeAlternative(const AURL: string; const ASource: TStream; const AHeaders: TNetHeaders = nil): IHTTPResponse;
    /// <summary>Send 'PATCH' command to url</summary>
    function Patch(const AURL: string; const ASource: TStream = nil; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;
    /// <summary>Send 'PATCH' command to url</summary>
    function PatchAlternative(const AURL: string; const ASource: TStream = nil; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>You have to use this function to Execute the internal Request</summary>
    function Execute(const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Cancels request</summary>
    procedure Cancel;
    /// <summary>Property indicating when the request was canceled</summary>
    property IsCancelled: Boolean read GetIsCancelled;

    /// <summary> CustomHeaders to be used by the client.</summary>
    property CustomHeaders[const AName: string]: string read GetCustomHeaderValue write SetCustomHeaderValue;
    /// <summary> CustHeaders is TURLHeaders object managing custom headers to be used by the client.</summary>
    property CustHeaders: TURLHeaders read FCustomHeaders;
    /// <summary> Content stream associated with the request component</summary>
    property ContentStream: TStream read FContentStream write FContentStream;
    /// <summary> Source stream associated with the request component</summary>
    property SourceStream: TStream read FSourceStream write FSourceStream;

    /// <summary> Client certificate stream for the request (iOS, Linux, Windows)</summary>
    property ClientCertificateStream: TStream read FClientCertificateStream write SetClientCertificateStream;

  published
    /// <summary>Property to indicate if the requests are going to be Synchronous or Asynchronous</summary>
    property Asynchronous: Boolean read FAsynchronous write FAsynchronous default False;
    /// <summary>Specifies if Events should run in the context of the main thread (True) or in the context of an arbitrary thread</summary>
    property SynchronizeEvents: Boolean read FSynchronizeEvents write FSynchronizeEvents default True;

    /// <summary> Property to set/get the ConnectionTimeout. Value is in milliseconds</summary>
    property ConnectionTimeout: Integer read FConnectionTimeout write FConnectionTimeout
      default TURLClient.DefaultConnectionTimeout;
    /// <summary> Property to set/get the SendTimeout. Value is in milliseconds</summary>
    property SendTimeout: Integer read FSendTimeout write FSendTimeout
      default TURLClient.DefaultSendTimeout;
    /// <summary> Property to set/get the ResponseTimeout. Value is in milliseconds</summary>
    property ResponseTimeout: Integer read FResponseTimeout write FResponseTimeout
      default TURLClient.DefaultResponseTimeout;

    /// <summary>Property to manage the 'Accept' header</summary>
    property Accept: string read GetAccept write SetAccept;
    /// <summary>Property to manage the 'Accept-CharSet' header</summary>
    property AcceptCharSet: string read GetAcceptCharSet write SetAcceptCharSet;
    /// <summary>Property to manage the 'Accept-Encoding' header</summary>
    property AcceptEncoding: string read GetAcceptEncoding write SetAcceptEncoding;
    /// <summary>Property to manage the 'Accept-Language' header</summary>
    property AcceptLanguage: string read GetAcceptLanguage write SetAcceptLanguage;

    /// <summary> Property to access the MethodString from the request</summary>
    property MethodString: string read FMethodString write FMethodString;
    /// <summary> URL to be accessed</summary>
    property URL: string read FURL write FURL;
    /// <summary> Client component associated with the request component</summary>
    property Client: TNetHTTPClient read FClient write SetClient;

    /// <summary> Client certificate path for the request (iOS, Linux, Windows, Android)
    ///  Note, on Android this is certificate fingerprint or imported name, not a file path. Password is not used. </summary>
    property ClientCertificatePath: string read FClientCertificatePath write SetClientCertificatePath;
    /// <summary> Client certificate password for the request </summary>
    property ClientCertificatePassword: string read FClientCertificatePassword write FClientCertificatePassword;

    /// <summary> Event fired when a request finishes</summary>
    property OnRequestCompleted: TRequestCompletedEvent read FOnRequestCompleted write FOnRequestCompleted;
    /// <summary> Event fired when a request has an error</summary>
    property OnRequestError: TRequestErrorEvent read FOnRequestError write FOnRequestError;
    /// <summary> Event fired when a request has an exception</summary>
    property OnRequestException: TRequestExceptionEvent read FOnRequestException write FOnRequestException;

    /// <summary>Property to manage the SendData Event</summary>
    property OnSendData: TSendDataEvent read FOnSendData write SetOnSendData;
    /// <summary>Property to manage the ReceiveData Event</summary>
    property OnReceiveData: TReceiveDataEvent read FOnReceiveData write SetOnReceiveData;
  end;
// ------------------------------------------------------------------------------------------------------------------ //
// ------------------------------------------------------------------------------------------------------------------ //

implementation

uses
  System.NetEncoding,
  System.NetConsts;

{ TNetHTTPClient }

constructor TNetHTTPClient.Create(AOwner: TComponent);
begin
  inherited;
  FHttpClient := THTTPClient.Create;
  FSynchronizeEvents := True;
end;

destructor TNetHTTPClient.Destroy;
begin
  FHttpClient.Free;
  inherited;
end;

function TNetHTTPClient.Delete(const AURL: string; const AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginDelete(DoOnAsyncRequestCompleted, AURL, AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Delete(AURL, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E);
  end;
end;

procedure TNetHTTPClient.DoOnAsyncRequestCompleted(const AAsyncResult: IAsyncResult);
begin
  try
    DoOnRequestCompleted(Self, THTTPClient.EndAsyncHTTP(AAsyncResult));
  except
    on E: Exception do
      DoOnRequestError(Self, E);
  end;
end;

class procedure TNetHTTPClient.HandleEvent(ASynchronizedEvents: Boolean; AThreadProc: TThreadProcedure);
begin
  if ASynchronizedEvents and Assigned(WakeMainThread) and
     (System.MainThreadID <> TThread.CurrentThread.ThreadID) then
    TThread.Synchronize(TThread.CurrentThread, AThreadProc)
  else
    AThreadProc;
end;

procedure TNetHTTPClient.DoOnAuthEvent(const Sender: TObject;
  AnAuthTarget: TAuthTargetType; const ARealm, AURL: string; var AUserName,
  APassword: string; var AbortAuth: Boolean;
  var Persistence: TAuthPersistenceType);
var
  LUserName, LPassword: string;
  LAbortAuth: Boolean;
  LPersistence: TAuthPersistenceType;
begin
  if Assigned(FOnAuthEvent) then
  begin
    LUserName := AUserName;
    LPassword := APassword;
    LAbortAuth := AbortAuth;
    LPersistence := Persistence;
    HandleEvent(SynchronizeEvents,
      procedure
      begin
        FOnAuthEvent(Self, AnAuthTarget, ARealm, AURL, LUserName, LPassword, LAbortAuth, LPersistence);
      end);
    AUserName := LUserName;
    APassword := LPassword;
    AbortAuth := LAbortAuth;
    Persistence := LPersistence;
  end;
end;

procedure TNetHTTPClient.DoOnNeedClientCertificate(const Sender: TObject;
  const ARequest: TURLRequest; const ACertificateList: TCertificateList;
  var AnIndex: Integer);
var
  LAnIndex: Integer;
begin
  if Assigned(FOnNeedClientCertificate) then
  begin
    LAnIndex := AnIndex;
    HandleEvent(SynchronizeEvents,
      procedure
      begin
        FOnNeedClientCertificate(Self, ARequest, ACertificateList, LAnIndex);
      end);
    AnIndex := LAnIndex;
  end;
end;

procedure TNetHTTPClient.DoOnValidateServerCertificate(const Sender: TObject;
  const ARequest: TURLRequest; const Certificate: TCertificate; var Accepted: Boolean);
var
  LAccepted: Boolean;
begin
  if Assigned(FOnValidateServerCertificate) then
  begin
    LAccepted := Accepted;
    HandleEvent(SynchronizeEvents,
      procedure
      begin
        FOnValidateServerCertificate(Self, ARequest, Certificate, LAccepted);
      end);
    Accepted := LAccepted;
  end;
end;

procedure TNetHTTPClient.DoOnSendData(const Sender: TObject; AContentLength,
  AWriteCount: Int64; var AAbort: Boolean);
var
  LAbort: Boolean;
begin
  if Assigned(FOnSendData) then
  begin
    LAbort := AAbort;
    HandleEvent(SynchronizeEvents,
      procedure
      begin
        FOnSendData(Self, AContentLength, AWriteCount, LAbort);
      end);
    AAbort := LAbort;
  end;
end;

procedure TNetHTTPClient.DoOnReceiveData(const Sender: TObject; AContentLength,
  AReadCount: Int64; var AAbort: Boolean);
var
  LAbort: Boolean;
begin
  if Assigned(FOnReceiveData) then
  begin
    LAbort := AAbort;
    HandleEvent(SynchronizeEvents,
      procedure
      begin
        FOnReceiveData(Self, AContentLength, AReadCount, LAbort);
      end);
    AAbort := LAbort;
  end;
end;

procedure TNetHTTPClient.DoOnRequestCompleted(const Sender: TObject; const AResponse: IHTTPResponse);
begin
  if Assigned(FOnRequestCompleted) then
    HandleEvent(SynchronizeEvents,
      procedure
      begin
        FOnRequestCompleted(Sender, AResponse);
      end);
end;

procedure TNetHTTPClient.DoOnRequestError(const Sender: TObject; const AException: Exception);
begin
  if Assigned(FOnRequestError) or Assigned(FOnRequestException) then
    HandleEvent(SynchronizeEvents,
      procedure
      begin
        if Assigned(FOnRequestError) then
          FOnRequestError(Sender, AException.Message);
        if Assigned(FOnRequestException) then
          FOnRequestException(Sender, AException);
      end)
  else
    raise AcquireExceptionObject;
end;

function TNetHTTPClient.Execute(const ARequestMethod: string; const AURI: TURI; const ASourceStream,
  AContentStream: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := IHTTPResponse(FHttpClient.BeginExecute(DoOnAsyncRequestCompleted, ARequestMethod, AURI, ASourceStream,
        AContentStream, AHeaders))
    else
    begin
      Result := IHTTPResponse(FHttpClient.Execute(ARequestMethod, AURI, ASourceStream, AContentStream, AHeaders));
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E);
  end;
end;

function TNetHTTPClient.Execute(const ARequestMethod, AURIStr: string; const ASourceStream, AContentStream: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  Result := Execute(ARequestMethod, TURI.Create(AURIStr), ASourceStream, AContentStream, AHeaders);
end;

function TNetHTTPClient.Execute(const ARequest: IHTTPRequest; const AContentStream: TStream): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginExecute(DoOnAsyncRequestCompleted, ARequest, AContentStream) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Execute(ARequest, AContentStream);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E);
  end;
end;

function TNetHTTPClient.Get(const AURL: string; const AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginGet(DoOnAsyncRequestCompleted, AURL, AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Get(AURL, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E);
  end;
end;

function TNetHTTPClient.GetAccept: string;
begin
  Result := FHttpClient.Accept;
end;

function TNetHTTPClient.GetAcceptCharSet: string;
begin
  Result := FHttpClient.AcceptCharSet;
end;

function TNetHTTPClient.GetAcceptEncoding: string;
begin
  Result := FHttpClient.AcceptEncoding;
end;

function TNetHTTPClient.GetAcceptLanguage: string;
begin
  Result := FHttpClient.AcceptLanguage;
end;

function TNetHTTPClient.GetAllowCookies: Boolean;
begin
  Result := FHttpClient.AllowCookies;
end;

function TNetHTTPClient.GetConnectionTimeout: Integer;
begin
  Result := FHttpClient.ConnectionTimeout;
end;

function TNetHTTPClient.GetContentType: string;
begin
  Result := FHttpClient.ContentType;
end;

function TNetHTTPClient.GetCookieManager: TCookieManager;
begin
  Result := FHttpClient.CookieManager;
end;

function TNetHTTPClient.GetCustHeaders: TURLHeaders;
begin
  Result := FHttpClient.CustHeaders;
end;

function TNetHTTPClient.GetCustomHeaderValue(const AName: string): string;
begin
  Result := FHttpClient.CustomHeaders[AName];
end;

function TNetHTTPClient.GetHandleRedirects: Boolean;
begin
  Result := FHttpClient.HandleRedirects;
end;

function TNetHTTPClient.GetCredentialsStorage: TCredentialsStorage;
begin
  Result := FHttpClient.CredentialsStorage;
end;

function TNetHTTPClient.GetMaxRedirects: Integer;
begin
  Result := FHttpClient.MaxRedirects;
end;

function TNetHTTPClient.GetProxySettings: TProxySettings;
begin
  Result := FHttpClient.ProxySettings;
end;

function TNetHTTPClient.GetProtocolVersion: THTTPProtocolVersion;
begin
  Result := FHttpClient.ProtocolVersion;
end;

function TNetHTTPClient.GetRange(const AURL: string; AStart, AnEnd: Int64;
  const AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginGetRange(DoOnAsyncRequestCompleted, AURL, AStart,
        AnEnd, AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.GetRange(AURL, AStart, AnEnd, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E);
  end;
end;

function TNetHTTPClient.GetResponseTimeout: Integer;
begin
  Result := FHttpClient.ResponseTimeout;
end;

function TNetHTTPClient.GetUserAgent: string;
begin
  Result := FHttpClient.UserAgent;
end;

function TNetHTTPClient.Head(const AURL: string; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginHead(DoOnAsyncRequestCompleted, AURL, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Head(AURL, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E);
  end;
end;

function TNetHTTPClient.Merge(const AURL: string; const ASource: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginMerge(DoOnAsyncRequestCompleted, AURL,
        ASource, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Merge(AURL, ASource, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E);
  end;
end;

function TNetHTTPClient.MergeAlternative(const AURL: string; const ASource: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginMergeAlternative(DoOnAsyncRequestCompleted, AURL,
        ASource, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.MergeAlternative(AURL, ASource, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E);
  end;
end;

function TNetHTTPClient.Options(const AURL: string; const AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginOptions(DoOnAsyncRequestCompleted, AURL,
        AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Options(AURL, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E);
  end;
end;

function TNetHTTPClient.Patch(const AURL: string; const ASource, AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginPatch(DoOnAsyncRequestCompleted, AURL, ASource,
        AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Patch(AURL, ASource, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E);
  end;
end;

function TNetHTTPClient.PatchAlternative(const AURL: string; const ASource,
  AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginPatchAlternative(DoOnAsyncRequestCompleted, AURL,
        ASource, AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.PatchAlternative(AURL, ASource, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E);
  end;
end;

function TNetHTTPClient.Post(const AURL: string; const ASource: TStrings;
  const AResponseContent: TStream; const AEncoding: TEncoding; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginPost(DoOnAsyncRequestCompleted, AURL, ASource,
        AResponseContent, AEncoding, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Post(AURL, ASource, AResponseContent, AEncoding, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E);
  end;
end;

function TNetHTTPClient.Post(const AURL: string; const ASource, AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginPost(DoOnAsyncRequestCompleted, AURL,
        ASource, AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Post(AURL, ASource, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E);
  end;
end;

function TNetHTTPClient.Post(const AURL: string; const ASource: TMultipartFormData;
  const AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginPost(DoOnAsyncRequestCompleted, AURL, ASource,
        AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Post(AURL, ASource, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E);
  end;
end;

function TNetHTTPClient.Post(const AURL, ASourceFile: string; const AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginPost(DoOnAsyncRequestCompleted, AURL,
        ASourceFile, AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Post(AURL, ASourceFile, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E);
  end;
end;

function TNetHTTPClient.Put(const AURL: string; const ASource: TStrings;
  const AResponseContent: TStream; const AEncoding: TEncoding; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginPut(DoOnAsyncRequestCompleted, AURL, ASource,
        AResponseContent, AEncoding, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Put(AURL, ASource, AResponseContent, AEncoding, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E);
  end;
end;

function TNetHTTPClient.Put(const AURL: string; const ASource, AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginPut(DoOnAsyncRequestCompleted, AURL, ASource,
        AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Put(AURL, ASource, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E);
  end;
end;

function TNetHTTPClient.Put(const AURL: string; const ASource: TMultipartFormData;
  const AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginPut(DoOnAsyncRequestCompleted, AURL, ASource,
        AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Put(AURL, ASource, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E);
  end;
end;

function TNetHTTPClient.Put(const AURL, ASourceFile: string; const AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginPut(DoOnAsyncRequestCompleted, AURL,
        ASourceFile, AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Put(AURL, ASourceFile, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E);
  end;
end;

procedure TNetHTTPClient.SetAccept(const Value: string);
begin
  FHttpClient.Accept := Value;
end;

procedure TNetHTTPClient.SetAcceptCharSet(const Value: string);
begin
  FHttpClient.AcceptCharSet := Value;
end;

procedure TNetHTTPClient.SetAcceptEncoding(const Value: string);
begin
  FHttpClient.AcceptEncoding := Value;
end;

procedure TNetHTTPClient.SetAcceptLanguage(const Value: string);
begin
  FHttpClient.AcceptLanguage := Value;
end;

procedure TNetHTTPClient.SetAllowCookies(const Value: Boolean);
begin
  FHttpClient.AllowCookies := Value;
end;

procedure TNetHTTPClient.SetOnAuthEvent(const Value: TCredentialsStorage.TCredentialAuthevent);
begin
  FOnAuthEvent := Value;
  if Assigned(FOnAuthEvent) then
    FHttpClient.AuthEvent := DoOnAuthEvent
  else
    FHttpClient.AuthEvent := nil;
end;

procedure TNetHTTPClient.SetConnectionTimeout(const Value: Integer);
begin
  FHttpClient.ConnectionTimeout := Value;
end;

procedure TNetHTTPClient.SetContentType(const Value: string);
begin
  FHttpClient.ContentType := Value;
end;

procedure TNetHTTPClient.SetCookieManager(const Value: TCookieManager);
begin
  FHttpClient.CookieManager := Value;
end;

procedure TNetHTTPClient.SetCredentialsStorage(const Value: TCredentialsStorage);
begin
  FHttpClient.CredentialsStorage := Value;
end;

procedure TNetHTTPClient.SetCustomHeaderValue(const AName, Value: string);
begin
  FHttpClient.CustomHeaders[AName] := Value;
end;

procedure TNetHTTPClient.SetHandleRedirects(const Value: Boolean);
begin
  FHttpClient.HandleRedirects := Value;
end;

procedure TNetHTTPClient.SetMaxRedirects(const Value: Integer);
begin
  FHttpClient.MaxRedirects := Value;
end;

procedure TNetHTTPClient.SetOnNeedClientCertificate(const Value: TNeedClientCertificateEvent);
begin
  FOnNeedClientCertificate := Value;
  if Assigned(FOnNeedClientCertificate) then
    FHttpClient.OnNeedClientCertificate := DoOnNeedClientCertificate
  else
    FHttpClient.OnNeedClientCertificate := nil;
end;

procedure TNetHTTPClient.SetOnValidateServerCertificate(const Value: TValidateCertificateEvent);
begin
  FOnValidateServerCertificate := Value;
  if Assigned(FOnValidateServerCertificate) then
    FHttpClient.OnValidateServerCertificate := DoOnValidateServerCertificate
  else
    FHttpClient.OnValidateServerCertificate := nil;
end;

procedure TNetHTTPClient.SetOnSendData(const Value: TSendDataEvent);
begin
  FOnSendData := Value;
  if Assigned(FOnSendData) then
    FHttpClient.OnSendData := DoOnSendData
  else
    FHttpClient.OnSendData := nil;
end;

procedure TNetHTTPClient.SetOnReceiveData(const Value: TReceiveDataEvent);
begin
  FOnReceiveData := Value;
  if Assigned(FOnReceiveData) then
    FHttpClient.OnReceiveData := DoOnReceiveData
  else
    FHttpClient.OnReceiveData := nil;
end;

procedure TNetHTTPClient.SetProxySettings(const Value: TProxySettings);
begin
  FHttpClient.ProxySettings := Value;
end;

procedure TNetHTTPClient.SetResponseTimeout(const Value: Integer);
begin
  FHttpClient.ResponseTimeout := Value;
end;

procedure TNetHTTPClient.SetUserAgent(const Value: string);
begin
  FHttpClient.UserAgent := Value;
end;

procedure TNetHTTPClient.SetProtocolVersion(const Value: THTTPProtocolVersion);
begin
  FHttpClient.ProtocolVersion := Value;
end;

function TNetHTTPClient.Trace(const AURL: string; const AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    if FAsynchronous then
      Result := FHttpClient.BeginTrace(DoOnAsyncRequestCompleted, AURL,
        AResponseContent, AHeaders) as IHTTPResponse
    else
    begin
      Result := FHttpClient.Trace(AURL, AResponseContent, AHeaders);
      DoOnRequestCompleted(Self, Result);
    end;
  except
    on E: Exception do
      DoOnRequestError(Self, E);
  end;
end;

function TNetHTTPClient.GetRedirectsWithGET: THTTPRedirectsWithGET;
begin
  Result := FHttpClient.RedirectsWithGET;
end;

function TNetHTTPClient.GetSecureProtocols: THTTPSecureProtocols;
begin
  Result := FHttpClient.SecureProtocols;
end;

function TNetHTTPClient.GetSendTimeout: Integer;
begin
  Result := FHttpClient.SendTimeout;
end;

procedure TNetHTTPClient.SetRedirectsWithGET(const AValue: THTTPRedirectsWithGET);
begin
  FHttpClient.RedirectsWithGET := AValue;
end;

procedure TNetHTTPClient.SetSecureProtocols(const AValue: THTTPSecureProtocols);
begin
  FHttpClient.SecureProtocols := AValue;
end;

procedure TNetHTTPClient.SetSendTimeout(const AValue: Integer);
begin
  FHttpClient.SendTimeout := AValue;
end;

function TNetHTTPClient.GetPreemptiveAuthentication: Boolean;
begin
  Result := FHttpClient.PreemptiveAuthentication;
end;

procedure TNetHTTPClient.SetPreemptiveAuthentication(const AValue: Boolean);
begin
  FHttpClient.PreemptiveAuthentication := AValue;
end;

function TNetHTTPClient.GetSecureFailureReasons: THTTPSecureFailureReasons;
begin
  Result := FHttpClient.SecureFailureReasons;
end;

function TNetHTTPClient.GetAutomaticDecompression: THTTPCompressionMethods;
begin
  Result := FHttpClient.AutomaticDecompression;
end;

procedure TNetHTTPClient.SetAutomaticDecompression(const AValue: THTTPCompressionMethods);
begin
  FHttpClient.AutomaticDecompression := AValue;
end;

function TNetHTTPClient.GetUseDefaultCredentials: Boolean;
begin
  Result := FHttpClient.UseDefaultCredentials;
end;

procedure TNetHTTPClient.SetUseDefaultCredentials(const AValue: Boolean);
begin
  FHttpClient.UseDefaultCredentials := AValue;
end;

// ------------------------------------------------------------------------------------------------------------------ //
// ------------------------------------------------------------------------------------------------------------------ //

{ TNetHTTPRequest }

constructor TNetHTTPRequest.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FCustomHeaders := TURLHeaders.Create;
  FSynchronizeEvents := True;
end;

destructor TNetHTTPRequest.Destroy;
begin
  Client := nil;
  FCustomHeaders.Free;
  inherited Destroy;
end;

procedure TNetHTTPRequest.CheckClient;
begin
  if FClient = nil then
    raise ENetHTTPRequestException.CreateRes(@SNetHttpComponentRequestClient);
end;

procedure TNetHTTPRequest.DoOnAsyncRequestCompleted(const AAsyncResult: IAsyncResult);
begin
  try
    FHttpResponse := THTTPClient.EndAsyncHTTP(AAsyncResult);
    DoOnRequestCompleted(Self, FHttpResponse);
  except
    on E: Exception do
      DoOnRequestError(Self, E);
  end;
end;

procedure TNetHTTPRequest.DoOnSendData(const Sender: TObject; AContentLength,
  AWriteCount: Int64; var AAbort: Boolean);
var
  LAbort: Boolean;
begin
  if Assigned(FOnSendData) then
  begin
    LAbort := AAbort;
    TNetHTTPClient.HandleEvent(SynchronizeEvents,
      procedure
      begin
        FOnSendData(Self, AContentLength, AWriteCount, LAbort);
      end);
    AAbort := LAbort;
  end;
end;

procedure TNetHTTPRequest.DoOnReceiveData(const Sender: TObject; AContentLength,
  AReadCount: Int64; var AAbort: Boolean);
var
  LAbort: Boolean;
begin
  if Assigned(FOnReceiveData) then
  begin
    LAbort := AAbort;
    TNetHTTPClient.HandleEvent(SynchronizeEvents,
      procedure
      begin
        FOnReceiveData(Self, AContentLength, AReadCount, LAbort);
      end);
    AAbort := LAbort;
  end;
end;

procedure TNetHTTPRequest.DoOnRequestCompleted(const Sender: TObject; const AResponse: IHTTPResponse);
begin
  if Assigned(FOnRequestCompleted) then
    TNetHTTPClient.HandleEvent(SynchronizeEvents,
      procedure
      begin
        FOnRequestCompleted(Sender, AResponse);
      end)
  else if FClient <> nil then
    FClient.DoOnRequestCompleted(Self, AResponse);
end;

procedure TNetHTTPRequest.DoOnRequestError(const Sender: TObject; const AException: Exception);
begin
  if Assigned(FOnRequestError) or Assigned(FOnRequestException) then
    TNetHTTPClient.HandleEvent(SynchronizeEvents,
      procedure
      begin
        if Assigned(FOnRequestError) then
          FOnRequestError(Sender, AException.Message);
        if Assigned(FOnRequestException) then
          FOnRequestException(Sender, AException);
      end)
  else if FClient <> nil then
    FClient.DoOnRequestError(Self, AException)
  else
    raise AcquireExceptionObject;
end;

function TNetHTTPRequest.Delete(const AURL: string; const AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodDelete, AURL, nil);
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

function TNetHTTPRequest.Execute(const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(FMethodString, FURL, nil);
  Result := DoExecute(FHttpRequest, FContentStream, AHeaders);
end;

type
  TDummyHTTPClient = class(THTTPClient);

function TNetHTTPRequest.DoExecute(const ARequest: IHTTPRequest; const AResponseContent: TStream;
  const AHeaders: TNetHeaders; AOwnsSourceStream: Boolean): IHTTPResponse;
var
  LHeaders: TNetHeaders;
begin
  CheckClient;
  Result := nil;
  FHttpResponse := nil;
  if ARequest <> nil then
    try
      LHeaders := FCustomHeaders.Headers + AHeaders;
      if FAsynchronous then
        Result := TDummyHTTPClient(FClient.FHttpClient).InternalExecuteAsync(nil,
          DoOnAsyncRequestCompleted, ARequest, AResponseContent, LHeaders, AOwnsSourceStream) as IHTTPResponse
      else
      begin
        Result := FClient.FHttpClient.Execute(ARequest, AResponseContent, LHeaders);
        DoOnRequestCompleted(Self, Result);
      end;
      FHttpResponse := Result;
    except
      on E: Exception do
        DoOnRequestError(Self, E);
    end;
end;

function TNetHTTPRequest.Get(const AURL: string; const AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodGet, AURL, nil);
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

function TNetHTTPRequest.GetAccept: string;
begin
  Result := CustomHeaders[sAccept];
end;

function TNetHTTPRequest.GetAcceptCharSet: string;
begin
  Result := CustomHeaders[sAcceptCharSet];
end;

function TNetHTTPRequest.GetAcceptEncoding: string;
begin
  Result := CustomHeaders[sAcceptEncoding];
end;

function TNetHTTPRequest.GetAcceptLanguage: string;
begin
  Result := CustomHeaders[sAcceptLanguage];
end;

function TNetHTTPRequest.GetCustomHeaderValue(const AName: string): string;
begin
  Result := FCustomHeaders.Value[AName];
end;

function TNetHTTPRequest.GetRange(const AURL: string; AStart, AnEnd: Int64;
  const AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
var
  LHeaders: TNetHeaders;
  LRange: string;
begin
  LRange := 'bytes=';
  if AStart > -1 then
    LRange := LRange + AStart.ToString;
  LRange := LRange + '-';
  if AnEnd > -1 then
    LRange := LRange + AnEnd.ToString;
  LHeaders := AHeaders + [TNetHeader.Create('Range', LRange)]; // do not translate
  Result := Get(AURL, AResponseContent, LHeaders);
end;

function TNetHTTPRequest.GetRequest(const AMethod, AURL: string; const ASourceStream: TStream;
  AOwnsSourceStream: Boolean): IHTTPRequest;
var
  LRequest: THTTPRequest;
begin
  CheckClient;
  try
    Result := nil;
    Result := FClient.FHttpClient.GetRequest(AMethod, AURL);
    LRequest := Result as THTTPRequest;
    LRequest.ConnectionTimeout := FConnectionTimeout;
    LRequest.SendTimeout := FSendTimeout;
    LRequest.ResponseTimeout := FResponseTimeout;
    if ClientCertificatePath <> '' then
      Result.SetClientCertificate(ClientCertificatePath, ClientCertificatePassword)
    else if ClientCertificateStream <> nil then
      Result.SetClientCertificate(ClientCertificateStream, ClientCertificatePassword);
    if Assigned(FOnSendData) then
      Result.OnSendData := DoOnSendData;
    if Assigned(FOnReceiveData) then
      Result.OnReceiveData := DoOnReceiveData;
    if ASourceStream = nil then
      Result.SourceStream := FSourceStream
    else
      Result.SourceStream := ASourceStream;
  except
    on E: Exception do
    begin
	  {$IFNDEF AUTOREFCOUNT}
      if AOwnsSourceStream then
        ASourceStream.Free;
	  {$ENDIF AUTOREFCOUNT}
      DoOnRequestError(Self, E);
    end;
  end;
end;

function TNetHTTPRequest.Head(const AURL: string; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodHead, AURL, nil);
  Result := DoExecute(FHttpRequest, nil, AHeaders);
end;

function TNetHTTPRequest.Merge(const AURL: string; const ASource: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodMerge, AURL, ASource);
  Result := DoExecute(FHttpRequest, nil, AHeaders);
end;

function TNetHTTPRequest.MergeAlternative(const AURL: string; const ASource: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
var
  LHeaders: TNetHeaders;
begin
  FHttpRequest := GetRequest(sHTTPMethodPut, AURL, ASource);
  LHeaders := [TNetHeader.Create(sXMethodOverride, sHTTPMethodPatch),
               TNetHeader.Create('PATCHTYPE', sHTTPMethodMerge)] + AHeaders; // Do not translate
  Result := DoExecute(FHttpRequest, nil, LHeaders);
end;

procedure TNetHTTPRequest.Notification(AComponent: TComponent; Operation: TOperation);
begin
  inherited Notification(AComponent, Operation);
  if (AComponent = Client) and (Operation = opRemove) then
    Client := nil;
end;

function TNetHTTPRequest.Options(const AURL: string; const AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodOptions, AURL, nil);
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

function TNetHTTPRequest.Patch(const AURL: string; const ASource,
  AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodPatch, AURL, ASource);
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

function TNetHTTPRequest.PatchAlternative(const AURL: string; const ASource,
  AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
var
  LHeaders: TNetHeaders;
begin
  FHttpRequest := GetRequest(sHTTPMethodPut, AURL, ASource);
  LHeaders := [TNetHeader.Create(sXMethodOverride, sHTTPMethodPatch)] + AHeaders;
  Result := DoExecute(FHttpRequest, AResponseContent, LHeaders);
end;

function TNetHTTPRequest.Post(const AURL: string; const ASource: TStrings;
  const AResponseContent: TStream; const AEncoding: TEncoding; const AHeaders: TNetHeaders): IHTTPResponse;
var
  LSourceStream: TStream;
  LSourceHeaders: TNetHeaders;
begin
  CheckClient;
  FClient.FHttpClient.CreateFormFromStrings(ASource, AEncoding, AHeaders,
    LSourceStream, LSourceHeaders);
  try
    FHttpRequest := GetRequest(sHTTPMethodPost, AURL, LSourceStream, FAsynchronous);
    Result := DoExecute(FHttpRequest, AResponseContent, LSourceHeaders, FAsynchronous);
  finally
    if not FAsynchronous then
      LSourceStream.Free;
  end;
end;

function TNetHTTPRequest.Post(const AURL: string; const ASource, AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodPost, AURL, ASource);
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

function TNetHTTPRequest.Post(const AURL: string; const ASource: TMultipartFormData;
  const AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodPost, AURL, ASource.Stream);
  if FHttpRequest <> nil then
  begin
    FHttpRequest.SourceStream.Position := 0;
    FHttpRequest.AddHeader(sContentType, ASource.MimeTypeHeader);
  end;
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

function TNetHTTPRequest.Post(const AURL, ASourceFile: string; AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
var
  LSourceStream: TStream;
begin
  LSourceStream := TFileStream.Create(ASourceFile, fmOpenRead or fmShareDenyWrite);
  try
    FHttpRequest := GetRequest(sHTTPMethodPost, AURL, LSourceStream, FAsynchronous);
    Result := DoExecute(FHttpRequest, AResponseContent, AHeaders, FAsynchronous);
  finally
    if not FAsynchronous then
      LSourceStream.Free;
  end;
end;

function TNetHTTPRequest.Put(const AURL: string; const ASource: TStrings;
  const AResponseContent: TStream; const AEncoding: TEncoding;
  const AHeaders: TNetHeaders): IHTTPResponse;
var
  LSourceStream: TStream;
  LSourceHeaders: TNetHeaders;
begin
  CheckClient;
  FClient.FHttpClient.CreateFormFromStrings(ASource, AEncoding, AHeaders,
    LSourceStream, LSourceHeaders);
  try
    FHttpRequest := GetRequest(sHTTPMethodPut, AURL, LSourceStream, FAsynchronous);
    Result := DoExecute(FHttpRequest, AResponseContent, LSourceHeaders, FAsynchronous);
  finally
    if not FAsynchronous then
      LSourceStream.Free;
  end;
end;

function TNetHTTPRequest.Put(const AURL: string; const ASource, AResponseContent: TStream;
  const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodPut, AURL, ASource);
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

function TNetHTTPRequest.Put(const AURL: string; const ASource: TMultipartFormData;
  const AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodPut, AURL, ASource.Stream);
  if FHttpRequest <> nil then
  begin
    FHttpRequest.SourceStream.Position := 0;
    FHttpRequest.AddHeader(sContentType, ASource.MimeTypeHeader);
  end;
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

function TNetHTTPRequest.Put(const AURL, ASourceFile: string;
  AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
var
  LSourceStream: TStream;
begin
  LSourceStream := TFileStream.Create(ASourceFile, fmOpenRead or fmShareDenyWrite);
  try
    FHttpRequest := GetRequest(sHTTPMethodPut, AURL, LSourceStream, FAsynchronous);
    Result := DoExecute(FHttpRequest, AResponseContent, AHeaders, FAsynchronous);
  finally
    if not FAsynchronous then
      LSourceStream.Free;
  end;
end;

function TNetHTTPRequest.Trace(const AURL: string; const AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodTrace, AURL, nil);
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

procedure TNetHTTPRequest.SetAccept(const Value: string);
begin
  CustomHeaders[sAccept] := Value;
end;

procedure TNetHTTPRequest.SetAcceptCharSet(const Value: string);
begin
  CustomHeaders[sAcceptCharSet] := Value;
end;

procedure TNetHTTPRequest.SetAcceptEncoding(const Value: string);
begin
  CustomHeaders[sAcceptEncoding] := Value;
end;

procedure TNetHTTPRequest.SetAcceptLanguage(const Value: string);
begin
  CustomHeaders[sAcceptLanguage] := Value;
end;

procedure TNetHTTPRequest.SetClient(const Value: TNetHTTPClient);
begin
  if FClient <> Value then
  begin
    if FClient <> nil then
      FClient.RemoveFreeNotification(Self);
    FClient := Value;
    if FClient <> nil then
    begin
      FClient.FreeNotification(Self);
      FConnectionTimeout := FClient.ConnectionTimeout;
      FSendTimeout := FClient.SendTimeout;
      FResponseTimeout := FClient.ResponseTimeout;
    end;
  end;
end;

procedure TNetHTTPRequest.SetClientCertificatePath(const Value: string);
begin
  FClientCertificatePath := Value;
  FClientCertificateStream := nil;
end;

procedure TNetHTTPRequest.SetClientCertificateStream(const Value: TStream);
begin
  FClientCertificatePath := '';
  FClientCertificateStream := Value;
end;

procedure TNetHTTPRequest.SetCustomHeaderValue(const AName, Value: string);
begin
  FCustomHeaders.Value[AName] := Value;
end;

procedure TNetHTTPRequest.SetOnSendData(const Value: TSendDataEvent);
begin
  FOnSendData := Value;
  if FHttpRequest <> nil then
    if Assigned(OnSendData) then
      FHttpRequest.OnSendData := DoOnSendData
    else
      FHttpRequest.OnSendData := nil;
end;

procedure TNetHTTPRequest.SetOnReceiveData(const Value: TReceiveDataEvent);
begin
  FOnReceiveData := Value;
  if FHttpRequest <> nil then
    if Assigned(FOnReceiveData) then
      FHttpRequest.OnReceiveData := DoOnReceiveData
    else
      FHttpRequest.OnReceiveData := nil;
end;

function TNetHTTPRequest.GetIsCancelled: Boolean;
var
  LRequest: IHTTPRequest;
begin
  LRequest := FHttpRequest;
  Result := (LRequest <> nil) and LRequest.IsCancelled;
end;

procedure TNetHTTPRequest.Cancel;
var
  LRequest: IHTTPRequest;
begin
  LRequest := FHttpRequest;
  if LRequest <> nil then
    LRequest.Cancel;
end;

end.
