{*******************************************************}
{                                                       }
{           CodeGear Delphi Runtime Library             }
{                                                       }
{ Copyright(c) 1995-2022 Embarcadero Technologies, Inc. }
{              All rights reserved                      }
{                                                       }
{*******************************************************}

unit System.JSON;

/// <summary>
/// System.JSON implements a TJson class that offers several convenience methods:
/// - converting Objects to Json and vice versa
/// - formating Json  </summary>

interface

{$SCOPEDENUMS ON}

uses
  System.SysUtils, System.Rtti, System.TypInfo, System.Generics.Collections;

type
  TJSONByteReader = class;
  TJSONValue = class;
  TJSONObject = class;

  /// <summary> Base class for all JSON exception</summary>
  EJSONException = class(Exception);

  /// <summary> JSON exception generated by JSON path parser code</summary>
  EJSONPathException = class(EJSONException);

  /// <summary> JSON exception generated by JSON parser code</summary>
  EJSONParseException = class(EJSONException)
  private
    FPath: string;
    FOffset: Integer;
    FLine, FPosition: Integer;
    constructor Create(AOffset: Integer; ABr: TJSONByteReader; AValue: TJSONValue;
      AIdent: PResStringRec; const AArgs: array of const); overload;
    constructor Create(AOffset: Integer; ABr: TJSONByteReader; AValue: TJSONValue); overload;
  public
    property Path: string read FPath;
    property Offset: Integer read FOffset;
    property Line: Integer read FLine;
    property Position: Integer read FPosition;
  end;

  /// <summary> Parses a JSON path with names and indexes.</summary>
  /// <remarks>
  ///  The syntax to write paths is similar to XPath but in a Json way.
  ///  The following XPath expression:
  ///    /entities/urls[0]/indices[1]
  ///  would look like
  ///    entities.urls[0].indices[1]   (dot notation)
  ///  or
  ///    entities["urls"][0]["indices"][1]   (bracket notation)
  ///
  ///  The dot (.) token is used to access the object elements:
  ///    ex: object.key
  ///
  ///  The bracket ([]) token is used to access array or object elements:
  ///    In array: cities[0]
  ///    In object: city["name"] or city['name']
  ///    In object: ["city"]["name"] or ['city']['name']
  ///
  ///  The quote (" or ') is used to introduce a literal when the element is being written in bracket notation:
  ///    ex:["first"]["second"] or ['first']['second']
  ///
  ///  To escape the quote in a literal use backslash (\): \"
  ///    ex: ["quotes(\").should.be.escaped"] or ['quotes(\').should.be.escaped']
  ///
  ///  Note: The backslash will only escape quotes within a literal. Bracket notation can be useful when
  ///  names can not be written in dot notation, like the objects keys with dot characters:
  ///    ex: object["key.with.dots"] or object['key.with.dots']
  ///
  /// </remarks>
  TJSONPathParser = record
  public type
    TToken = (Undefined, Name, ArrayIndex, Eof, Error);
  private
    FPathPtr: PChar;
    FPtr: PChar;
    FEndPtr: PChar;
    FTokenArrayIndex: Integer;
    FTokenName: string;
    FToken: TToken;
    function GetIsEof: Boolean; inline;
    procedure RaiseError(AMsg: PResStringRec);
    procedure RaiseErrorFmt(AMsg: PResStringRec; const AParams: array of const);
    procedure ParseName;
    procedure ParseQuotedName(AQuote: Char);
    procedure ParseArrayIndex;
    procedure ParseIndexer;
    function EnsureLength(ALength: Integer): Boolean; inline;
    procedure FrontTrim(var APtr: PChar); inline;
    procedure BackTrim(var APtr: PChar); inline;
  public
    constructor Create(const APath: string); overload;
    constructor Create(const APathPtr: PChar; ALen: Integer); overload;
    function NextToken: TToken;
    property IsEof: Boolean read GetIsEof;
    property Token: TToken read FToken;
    property TokenName: string read FTokenName;
    property TokenArrayIndex: Integer read FTokenArrayIndex;
  end;

  /// <summary> JSON top level class. All specific classes are descendant of it.</summary>
  /// <remarks> All specific classes are descendant of it. More on JSON can be found on www.json.org </remarks>
  TJSONAncestor = class abstract
  public type
    /// <summary> JSON Output Option </summary>
    TJSONOutputOption = (EncodeBelow32, EncodeAbove127);
    /// <summary>
    ///   JSON Output Options
    ///     EncodeBelow32 - characters with code less than 32 will be encoded using \uXXXX
    ///     EncodeAbove127 - characters with code greater than 127 will be encoded using \uXXXX
    /// </summary>
    TJSONOutputOptions = set of TJSONOutputOption;

  private
    /// <summary> True if the instance is own by the container</summary>
    FOwned: Boolean;
  protected
    /// <summary> Returns true if the instance represent JSON null value </summary>
    /// <returns>true if the instance represents JSON null value</returns>
    function IsNull: Boolean; virtual;

    /// <summary> Method used by parser to re-constitute the JSON object structure </summary>
    /// <param name="descendent">descendant to be added</param>
    procedure AddDescendant(const Descendent: TJSONAncestor); virtual;

    procedure Format(Builder: TStringBuilder; const ParentIdent, Ident: string); overload; virtual;
  public
    /// <summary> Default constructor, sets owned flag to true </summary>
    constructor Create; overload; virtual;

    /// <summary> Where appropriate, returns the instance representation as String </summary>
    /// <returns>string representation, can be null</returns>
    function Value: string; virtual;

    /// <summary> Returns estimated byte size of current JSON object. The actual size is smaller</summary>
    /// <remarks> The actual size is smaller</remarks>
    /// <returns>integer - the byte size</returns>
    function EstimatedByteSize: Integer; virtual; abstract;

    /// <summary> Serializes the JSON object content into bytes. Returns the actual used size.
    /// It assumes the byte container has sufficient capacity to store it. </summary>
    /// <remarks> Returns the actual used size. It assumes the byte container has sufficient capacity to store it.
    /// It is recommended that the container capacity is given by estimatedByteSize </remarks>
    /// <param name="data">- byte container</param>
    /// <param name="offset">- offset from which the object is serialized</param>
    /// <returns>integer - the actual size used</returns>
    function ToBytes(const Data: TArray<Byte>; Offset: Integer): Integer; virtual; abstract;
    procedure ToChars(Builder: TStringBuilder; Options: TJSONOutputOptions); overload; virtual; abstract;

    function ToJSON(Options: TJSONOutputOptions): string; overload;
    function ToJSON: string; overload; inline;
    function ToString: string; override;
    function Format(Indentation: Integer = 4): string; overload;

    /// <summary> Perform deep clone on current value</summary>
    /// <returns>an exact copy of current instance</returns>
    function Clone: TJSONAncestor; virtual; abstract;

    /// <summary> Returns true if the instance represent JSON null value </summary>
    /// <returns>true if the instance represents JSON null value</returns>
    property Null: Boolean read IsNull;
    property Owned: Boolean read FOwned write FOwned;
  end;

  /// <summary> Generalizes byte consumption of JSON parser. It accommodates UTF8, default it</summary>
  /// <remarks> It accommodates UTF8, default it assumes the content is generated by JSON toBytes method. </remarks>
  TJSONByteReader = class
  private
    FData: PByte;
    FDataStart: PByte;
    FDataEnd: PByte;
    FIsUTF8: Boolean;

    FUtf8data: TArray<Byte>;
    FUtf8offset: Integer;
    FUtf8length: Integer;

    FStringCache: TDictionary<Cardinal, String>;
    FCharData: TArray<Char>;
    FCharPos: Integer;
    FCharLen: Integer;
    FCache: Boolean;

    FLevel: Integer;

    procedure Init(const Data: PByte; const Offset, Range: Integer);
    function GetOffset: Integer; inline;

    /// <summary> Consumes byte-order mark if any is present in the byte data </summary>
    procedure ConsumeBOM;
    procedure MoveOffset; inline;
    procedure ProcessMBCS;

    procedure EnterLevel; inline;
    procedure ExitLevel; inline;

  public
    constructor Create(const Data: PByte; const Offset: Integer; const Range: Integer); overload;
    constructor Create(const Data: PByte; const Offset: Integer; const Range: Integer; const IsUTF8: Boolean); overload;
    destructor Destroy; override;

    function ConsumeByte: Byte;
    function PeekRawByte: Byte; inline;
    function PeekByte: Byte;
    procedure SkipByte; inline;
    procedure SkipWhitespaces;
    function IsEof: Boolean; inline;
    function HasMore(const Size: Integer): Boolean;

    procedure AddChar(Ch: Char);
    procedure ResetString; inline;
    procedure FlushString(var ADest: string; ACache: Boolean);

    procedure OffsetToPos(AOffset: Integer; var ALine, APos: Integer);

    property Offset: Integer read GetOffset;
  end;

  /// <summary> Groups string, number, object, array, true, false, null </summary>
  TJSONValue = class abstract(TJSONAncestor)
  public type
    /// <summary> JSON Parser Option </summary>
    TJSONParseOption = (IsUTF8, UseBool, RaiseExc);
    /// <summary>
    ///   JSON Parser Options
    ///     IsUTF8 - data should be treated as UTF8
    ///     UseBool - Parser should create a TJSONBool object for each instance of "true" or "false" seen in the JSON data
    /// </summary>
    TJSONParseOptions = set of TJSONParseOption;

  private
    function GetValueP(const APath: string): TJSONValue;
    function GetValueA(const AIndex: Integer): TJSONValue; virtual;

    class function MakeParseOptions(IsUTF8, UseBool, RaiseExc: Boolean): TJSONValue.TJSONParseOptions; inline;

    /// <summary> Consumes a JSON object </summary>
    /// <param name="Br"> raw byte data</param>
    /// <param name="Parent"> parent JSON entity</param>
    /// <param name="UseBool"> create a TJSONBool for "true" or "false" seen
    /// in the JSON data</param>
    /// <returns>next offset</returns>
    class function ParseObject(const Br: TJSONByteReader; const Parent: TJSONAncestor; UseBool: Boolean): Integer; static;

    /// <summary> Consumes JSON pair string:value </summary>
    /// <param name="Br">raw byte data</param>
    /// <param name="Parent">parent JSON entity</param>
    /// <param name="UseBool"> create a TJSONBool for "true" or "false" seen
    /// in the JSON data</param>
    /// <returns>next offset</returns>
    class function ParsePair(const Br: TJSONByteReader; const Parent: TJSONObject; UseBool: Boolean): Integer; static;

    /// <summary> Consumes JSON array [...] </summary>
    /// <param name="Br"> raw byte data</param>
    /// <param name="Parent"> parent JSON entity</param>
    /// <param name="UseBool"> create a TJSONBool for "true" or "false" seen
    /// in the JSON data</param>
    /// <returns>next offset</returns>
    class function ParseArray(const Br: TJSONByteReader; const Parent: TJSONAncestor; UseBool: Boolean): Integer; static;

    /// <summary> Consumes JSON values: string, number, object, array, true, false, null </summary>
    /// <param name="Br">raw byte data</param>
    /// <param name="Parent">parent JSON entity</param>
    /// <param name="UseBool"> create a TJSONBool for "true" or "false" seen
    /// in the JSON data</param>
    /// <returns>next offset</returns>
    class function ParseValue(const Br: TJSONByteReader; const Parent: TJSONAncestor; UseBool: Boolean): Integer; static;

    /// <summary> Consumes numbers: int | int frac | int exp | int frac exp </summary>
    /// <param name="Br">raw byte data</param>
    /// <param name="Parent">parent JSON entity</param>
    /// <returns>next offset</returns>
    class function ParseNumber(const Br: TJSONByteReader; const Parent: TJSONAncestor): Integer; static;

    /// <summary> Consumes a JSON string "..." </summary>
    /// <param name="Br">raw byte data</param>
    /// <param name="Parent">parent JSON entity</param>
    /// <returns>next offset</returns>
    class function ParseString(const Br: TJSONByteReader; const Parent: TJSONAncestor): Integer; static;

  protected
    function AsTValue(ATypeInfo: PTypeInfo; var AValue: TValue): Boolean; virtual;
  public
    class function ParseJSONValue(const Data: PByte; const Offset: Integer; const ALength: Integer; Options: TJSONParseOptions): TJSONValue; overload; static;

    /// <summary> Parses a byte array and returns the JSON value from it. </summary>
    /// <remarks> Assumes buffer has only JSON pertinent data. </remarks>
    /// <param name="Data">- byte array, not null</param>
    /// <param name="Offset">- offset from which the parsing starts</param>
    /// <param name="IsUTF8">- true if the Data should be treated as UTF-8. Optional, defaults to true</param>
    /// <returns>JSONValue or nil if the parse fails</returns>
    class function ParseJSONValue(const Data: TArray<Byte>; const Offset: Integer; IsUTF8: Boolean = True): TJSONValue; overload; inline; static;

    /// <summary> Parses a byte array and returns the JSON value from it. </summary>
    /// <remarks> Assumes buffer has only JSON pertinent data. </remarks>
    /// <param name="Data">- byte array, not null</param>
    /// <param name="Offset">- offset from which the parsing starts</param>
    /// <param name="Options">- See TJSONParseOptions for correct values</param>
    /// <returns>JSONValue or nil if the parse fails and RaiseExc option is not specified</returns>
    class function ParseJSONValue(const Data: TArray<Byte>; const Offset: Integer; Options: TJSONParseOptions): TJSONValue; overload; inline; static;

    /// <summary> Parses a byte array and returns the JSON value from it. </summary>
    /// <param name="Data">- byte array, not null</param>
    /// <param name="Offset">- offset from which the parsing starts</param>
    /// <param name="ALength">- buffer capacity</param>
    /// <param name="IsUTF8">- true if the Data should be treated as UTF-8. Optional, defaults to true</param>
    /// <returns>JSONValue or nil if the parse fails</returns>
    class function ParseJSONValue(const Data: TArray<Byte>; const Offset: Integer; const ALength: Integer; IsUTF8: Boolean = True): TJSONValue; overload; inline; static;

    /// <summary> Parses a byte array and returns the JSON value from it. </summary>
    /// <param name="Data">- byte array, not null</param>
    /// <param name="Offset">- offset from which the parsing starts</param>
    /// <param name="ALength">- buffer capacity</param>
    /// <param name="Options">- See TJSONParseOptions for correct values</param>
    /// <returns>JSONValue or nil if the parse fails and RaiseExc option is not specified</returns>
    class function ParseJSONValue(const Data: TArray<Byte>; const Offset: Integer; const ALength: Integer; Options: TJSONParseOptions): TJSONValue; overload; inline; static;

    /// <summary> Parses a string and returns the JSON value from it. </summary>
    /// <param name="Data">- String to parse</param>
    /// <param name="UseBool">- Create a TJSONBool for "true" or "false" seen in the JSON data</param>
    /// <param name="RaiseExc">- true if exception must be raised on invalid JSON. Optional, defaults to false</param>
    /// <returns>JSONValue or nil if the parse fails and RaiseExc is False</returns>
    class function ParseJSONValue(const Data: string; UseBool: Boolean = False; RaiseExc: Boolean = False): TJSONValue; overload; static;
{$IFNDEF NEXTGEN}
    class function ParseJSONValue(const Data: UTF8String; UseBool: Boolean = False; RaiseExc: Boolean = False): TJSONValue; overload; static;
{$ENDIF !NEXTGEN}

    class function ParseJSONFragment(const Data: PByte; var Offset: Integer; const ALength: Integer; Options: TJSONParseOptions): TJSONValue; overload; static;
    class function ParseJSONFragment(const Data: TArray<Byte>; var Offset: Integer; Options: TJSONParseOptions): TJSONValue; overload; static;
    class function ParseJSONFragment(const Data: string; var Offset: Integer; Options: TJSONParseOptions): TJSONValue; overload; static;

    /// <summary>Finds a JSON value and returns reference to it. </summary>
    /// <remarks> Returns nil when a JSON value could not be found. </remarks>
    function FindValue(const APath: string): TJSONValue;

    /// <summary>Converts a JSON value to a specified type. </summary>
    /// <remarks> Returns False when the JSON value could not be converted. </remarks>
    function TryGetValue<T>(out AValue: T): Boolean; overload;

    /// <summary>Finds a JSON value and converts to a specified type. </summary>
    /// <remarks> Returns False when a JSON value could not be found or could not be converted. </remarks>
    function TryGetValue<T>(const APath: string; out AValue: T): Boolean; overload;

    /// <summary>Finds a JSON value and converts to a specified type. </summary>
    /// <remarks> Raises an exception when a JSON value could not be found or the JSON value could not be converted. </remarks>
    function GetValue<T>(const APath: string = ''): T; overload;

    /// <summary>Finds a JSON value if possible.  If found, the JSON value is converted to a specified type.
    /// If not found or if the JSON value is null, then returns a default value. </summary>
    /// <remarks>Raises an exception when a JSON value is found but can't be converted. </remarks>
    function GetValue<T>(const APath: string; ADefaultValue: T): T; overload;

    /// <summary>Converts a JSON value to a specified type. </summary>
    /// <remarks>Raises an exception when a JSON value can't be converted. </remarks>
    function AsType<T>: T; overload;

    /// <summary>Finds a JSON value and returns reference to it. </summary>
    /// <remarks> Raises an exception when a JSON value could not be found. </remarks>
    property P[const APath: string]: TJSONValue read GetValueP;{ default;}
    property A[const AIndex: Integer]: TJSONValue read GetValueA;

    { Deprecated functions }
{$IFNDEF NEXTGEN}
    class function ParseJSONValueUTF8(const Data: TArray<Byte>; const Offset: Integer;
                                      const ACount: Integer): TJSONValue; overload; static; deprecated 'Use ParseJSONValue';
    class function ParseJSONValueUTF8(const Data: TArray<Byte>;
                                      const Offset: Integer): TJSONValue; overload; static; deprecated 'Use ParseJSONValue';
{$ENDIF !NEXTGEN}
  end;

  TJSONString = class(TJSONValue)
  protected
    FValue: string;
    FIsNull: Boolean;

    /// <summary> see com.borland.dbx.transport.JSONAncestor#isNull() </summary>
    function IsNull: Boolean; override;

    function AsTValue(ATypeInfo: PTypeInfo; var AValue: TValue): Boolean; override;

  public
    /// <summary> Constructor for null string. No further changes are supported. </summary>
    /// <remarks> No further changes are supported. </remarks>
    constructor Create; overload; override;

    /// <summary> Constructor for a given string </summary>
    /// <param name="value">String initial value, cannot be null</param>
    constructor Create(const Value: string); overload;

    /// <summary> Adds a character to current content </summary>
    /// <param name="ch">char to be appended</param>
    procedure AddChar(const Ch: Char);

    function Equals(const Value: string): Boolean; reintroduce; inline;

    /// <summary> see com.borland.dbx.transport.JSONAncestor#estimatedByteSize() </summary>
    function EstimatedByteSize: Integer; override;

    /// <summary> see com.borland.dbx.transport.JSONAncestor#toBytes(byte[], int) </summary>
    function ToBytes(const Data: TArray<Byte>; Offset: Integer): Integer; override;
    /// <summary> Returns the quoted string content. </summary>
    procedure ToChars(Builder: TStringBuilder; Options: TJSONAncestor.TJSONOutputOptions); override;

    /// <summary> Returns the string content </summary>
    function Value: string; override;
    function Clone: TJSONAncestor; override;
  end;

  TJSONNumber = class sealed(TJSONString)
  protected
    /// <summary> Returns the double representation of the number </summary>
    /// <returns>double</returns>
    function GetAsDouble: Double;

    /// <summary> Returns the integer part of the number </summary>
    /// <returns>int</returns>
    function GetAsInt: Integer;

    /// <summary> Returns the int64 part of the number </summary>
    /// <returns>int64</returns>
    function GetAsInt64: Int64;

  public
    /// <summary> Constructor with numerical argument represented as string </summary>
    /// <param name="value">- string equivalent of a number</param>
    constructor Create(const Value: string); overload;

    /// <summary> Constructor for a double number </summary>
    /// <param name="value">double to be represented as JSONNumber</param>
    constructor Create(const Value: Double); overload;

    /// <summary> Constructor for integer </summary>
    /// <param name="value">integer to be represented as JSONNumber</param>
    constructor Create(const Value: Integer); overload;

    /// <summary> Constructor for integer </summary>
    /// <param name="value">integer to be represented as JSONNumber</param>
    constructor Create(const Value: Int64); overload;

    /// <seealso cref="TJSONString.estimatedByteSize()"/>
    function EstimatedByteSize: Integer; override;

    /// <summary> see com.borland.dbx.transport.JSONString#toBytes(byte[], int) </summary>
    function ToBytes(const Data: TArray<Byte>; Offset: Integer): Integer; override;
    /// <summary> Returns the non-localized string representation </summary>
    procedure ToChars(Builder: TStringBuilder; Options: TJSONAncestor.TJSONOutputOptions); override;

    function Clone: TJSONAncestor; override;

    /// <summary> Returns the double representation of the number </summary>
    /// <returns>double</returns>
    property AsDouble: Double read GetAsDouble;

    /// <summary> Returns the integer part of the number </summary>
    /// <returns>int</returns>
    property AsInt: Integer read GetAsInt;

    /// <summary> Returns the number as an int64 </summary>
    /// <returns>int64</returns>
    property AsInt64: Int64 read GetAsInt64;
  end;

  /// <summary> Implements JSON string : value </summary>
  TJSONPair = class sealed(TJSONAncestor)
  private
    FJsonString: TJSONString;
    FJsonValue: TJSONValue;
  protected
    /// <summary> see com.borland.dbx.transport.JSONAncestor#addDescendent(com.borland.dbx.transport.JSONAncestor) </summary>
    procedure AddDescendant(const Descendant: TJSONAncestor); override;

    /// <summary> Sets the pair's string value </summary>
    /// <param name="descendant">string object cannot be null</param>
    procedure SetJsonString(const Descendant: TJSONString);

    /// <summary> Sets the pair's value member </summary>
    /// <param name="val">string object cannot be null</param>
    procedure SetJsonValue(const Val: TJSONValue);

    function HasName(const Name: string): Boolean; inline;
  public
    /// <summary> Utility constructor providing pair members </summary>
    /// <param name="str">- JSONString member, not null</param>
    /// <param name="value">- JSONValue member, never null</param>
    constructor Create(const Str: TJSONString; const Value: TJSONValue); overload;

    /// <summary> Convenience constructor. Parameters will be converted into JSON equivalents</summary>
    /// <remarks> Parameters will be converted into JSON equivalents </remarks>
    /// <param name="str">- string member</param>
    /// <param name="value">- JSON value</param>
    constructor Create(const Str: string; const Value: TJSONValue); overload;

    /// <summary> Convenience constructor. Parameters are converted into JSON strings pair </summary>
    /// <remarks> Parameters are converted into JSON strings pair </remarks>
    /// <param name="str">- string member</param>
    /// <param name="value">- converted into a JSON string value</param>
    constructor Create(const Str: string; const Value: string); overload;

    /// <summary> Convenience constructor. Parameters are converted into JSON strings pair </summary>
    /// <remarks> Parameters are converted into JSON strings pair </remarks>
    /// <param name="str">- string member</param>
    /// <param name="value">- converted into a JSON numeric value</param>
    constructor Create(const Str: string; const Value: Int64); overload;

    /// <summary> Convenience constructor. Parameters are converted into JSON strings pair </summary>
    /// <remarks> Parameters are converted into JSON strings pair </remarks>
    /// <param name="str">- string member</param>
    /// <param name="value">- converted into a JSON numeric value</param>
    constructor Create(const Str: string; const Value: Integer); overload;

    /// <summary> Convenience constructor. Parameters are converted into JSON strings pair </summary>
    /// <remarks> Parameters are converted into JSON strings pair </remarks>
    /// <param name="str">- string member</param>
    /// <param name="value">- converted into a JSON numeric value</param>
    constructor Create(const Str: string; const Value: Double); overload;

    /// <summary> Convenience constructor. Parameters are converted into JSON strings pair </summary>
    /// <remarks> Parameters are converted into JSON strings pair </remarks>
    /// <param name="str">- string member</param>
    /// <param name="value">- converted into a JSON boolean value</param>
    constructor Create(const Str: string; const Value: Boolean); overload;

    /// <summary> Utility constructor creating empty pair. </summary>
    constructor Create; overload; override;

    /// <summary> Frees string and value</summary>
    destructor Destroy; override;

    /// <summary> see com.borland.dbx.transport.JSONAncestor#estimatedByteSize() </summary>
    function EstimatedByteSize: Integer; override;

    /// <summary> see com.borland.dbx.transport.JSONAncestor#toBytes(byte[], int) </summary>
    function ToBytes(const Data: TArray<Byte>; Offset: Integer): Integer; override;
    procedure ToChars(Builder: TStringBuilder; Options: TJSONAncestor.TJSONOutputOptions); override;
    function Clone: TJSONAncestor; override;

    /// <summary> Returns the pair's string. </summary>
    /// <returns>JSONString - pair's string</returns>
    property JsonString: TJSONString read FJsonString write SetJsonString;

    /// <summary> Returns the pair value. </summary>
    /// <returns>JSONAncestor - pair's value</returns>
    property JsonValue: TJSONValue read FJsonValue write SetJsonValue;
  end;

  /// <summary> JSON object represents {} or { members } </summary>
  TJSONObject = class sealed(TJSONValue)
  public type
    /// <summary> Enumerator for JSON pairs </summary>
    TEnumerator = class
    private
      FIndex: Integer;
      FObject: TJSONObject;
    public
      constructor Create(const AObject: TJSONObject);
      function GetCurrent: TJSONPair; inline;
      function MoveNext: Boolean; inline;
      property Current: TJSONPair read GetCurrent;
    end;

  private
    FMembers: TList<TJSONPair>;

    function Parse(const Br: TJSONByteReader; UseBool: Boolean): Integer; overload;

  protected
    /// <summary> Adds a new member </summary>
    /// <param name="Descendant">- JSON pair</param>
    procedure AddDescendant(const Descendant: TJSONAncestor); override;

    /// <summary> Returns the number of members in its content. May be zero </summary>
    /// <remarks> May be zero </remarks>
    /// <returns>number of members in its content</returns>
    function GetCount: Integer; inline;

    /// <summary> Returns the i-th pair</summary>
    /// <param name="Index">- pair index</param>
    /// <returns>the i-th pair</returns>
    function GetPair(const Index: Integer): TJSONPair; inline;

    /// <summary> Returns a JSON pair based on the pair string part.
    ///  The search is case sensitive and it returns the fist pair with string part matching the argument </summary>
    /// <param name="pairName">- string: the  pair string part</param>
    /// <returns>- JSONPair : first pair encountered, null otherwise</returns>
    function GetPairByName(const PairName: string): TJSONPair;

    procedure Format(Builder: TStringBuilder; const ParentIdent, Ident: string); overload; override;
  public
    /// <summary> Default constructor, initializes the members container </summary>
    constructor Create; overload; override;

    /// <summary> Convenience constructor - builds an object around a given pair </summary>
    /// <param name="Pair">first pair in the object definition, must not be null</param>
    constructor Create(const Pair: TJSONPair); overload;

    /// <summary> Returns an enumerator for pairs </summary>
    /// <remarks> Allows JSONPairs to be accessed using a for-in loop. </remarks>
    /// <returns>The enumerator</returns>
    function GetEnumerator: TEnumerator; inline;

    /// <summary> Returns a JSON pair value based on the pair string part. The search is case sensitive and it returns
    /// the fist pair with string part matching the argument </summary>
    /// <param name="Name">- string: the  pair string part</param>
    /// <returns>- JSONValue : value of the first pair encountered, null otherwise</returns>
    function GetValue(const Name: string): TJSONValue; overload;

    /// <summary> Releases the stored members </summary>
    destructor Destroy; override;

    /// <summary> Adds a new pair </summary>
    /// <param name="Pair">- a new pair, cannot be null</param>
    function AddPair(const Pair: TJSONPair): TJSONObject; overload;

    /// <summary> Convenience method for adding a pair (name, value). </summary>
    /// <param name="Str">- pair name</param>
    /// <param name="Val">- pair value</param>
    function AddPair(const Str: TJSONString; const Val: TJSONValue): TJSONObject; overload;

    /// <summary> Convenience method for adding a pair to current object. </summary>
    /// <param name="Str">- string: pair name</param>
    /// <param name="Val">- JSONValue: pair value</param>
    function AddPair(const Str: string; const Val: TJSONValue): TJSONObject; overload;

    /// <summary> Convenience method for adding a pair to current object. </summary>
    /// <param name="Str">- string: pair name</param>
    /// <param name="Val">- string: pair value</param>
    function AddPair(const Str: string; const Val: string): TJSONObject; overload;

    /// <summary> Convenience method for adding a pair to current object. </summary>
    /// <param name="Str">- string: pair name</param>
    /// <param name="Val">- Int64: pair value</param>
    function AddPair(const Str: string; const Val: Int64): TJSONObject; overload;

    /// <summary> Convenience method for adding a pair to current object. </summary>
    /// <param name="Str">- string: pair name</param>
    /// <param name="Val">- Integer: pair value</param>
    function AddPair(const Str: string; const Val: Integer): TJSONObject; overload;

    /// <summary> Convenience method for adding a pair to current object. </summary>
    /// <param name="Str">- string: pair name</param>
    /// <param name="Val">- Double: pair value</param>
    function AddPair(const Str: string; const Val: Double): TJSONObject; overload;

    /// <summary> Convenience method for adding a pair to current object. </summary>
    /// <param name="Str">- string: pair name</param>
    /// <param name="Val">- Boolean: pair value</param>
    // Workaround for RSP-35502
    [HPPGEN('TJSONObject* __fastcall AddPair(const System::UnicodeString Str, const bool Val);'    + #13#10 +
            'TJSONObject* __fastcall AddPair(const System::UnicodeString Str, const char* Val) {'  + #13#10 +
            '  return AddPair(Str, System::String(Val));'                                          + #13#10 +
            '}')]
    function AddPair(const Str: string; const Val: Boolean): TJSONObject; overload;

    function RemovePair(const PairName: string): TJSONPair;

    /// <summary> Returns the number of bytes needed to serialize this object </summary>
    function EstimatedByteSize: Integer; override;

    /// <summary> see JSONAncestor#toBytes(byte[], int) </summary>
    function ToBytes(const Data: TArray<Byte>; Offset: Integer): Integer; override;
    procedure ToChars(Builder: TStringBuilder; Options: TJSONAncestor.TJSONOutputOptions); override;

    function Clone: TJSONAncestor; override;

    /// <summary> Consumes a JSON object byte representation. </summary>
    /// <remarks> It is recommended to use static function parseJSONValue, unless you are familiar
    ///  with parsing technology. It assumes the buffer has only JSON bytes. </remarks>
    /// <param name="Data">byte[] with JSON stream</param>
    /// <param name="Pos">position within the byte array to start from, negative number if
    ///    parser fails. If negative, the absolute value is the offset where the failure happens. </param>
    /// <param name="UseBool"> create a TJSONBool for "true" or "false" seen
    /// in the JSON data</param>
    /// <returns>negative number on parse error, byte buffer length on success.</returns>
    function Parse(const Data: TArray<Byte>; const Pos: Integer; UseBool: Boolean = False): Integer; overload;

    /// <summary> Consumes a JSON object byte representation. </summary>
    /// <remarks> It is recommended to use static function parseJSONValue, unless you are familiar
    ///  with parsing technology. </remarks>
    /// <param name="Data">byte[] with JSON stream</param>
    /// <param name="Pos">position within the byte array to start from</param>
    /// <param name="Count">number of bytes</param>
    /// <param name="UseBool"> create a TJSONBool for "true" or "false" seen
    /// in the JSON data</param>
    /// <returns>negative number on parse error</returns>
    function Parse(const Data: TArray<Byte>; const Pos: Integer; const Count: Integer; UseBool: Boolean = False): Integer; overload;
    procedure SetPairs(const AList: TList<TJSONPair>);
    property Count: Integer read GetCount;
    property Pairs[const Index: Integer]: TJSONPair read GetPair;
    property Values[const Name: string]: TJSONValue read GetValue;

    { Deprecated functions }
    function Size: Integer; inline; deprecated 'Use Count Property';
    function Get(const Index: Integer): TJSONPair; overload; inline; deprecated 'Use Pairs property';
    function Get(const Name: string): TJSONPair; overload; inline; // deprecated
  end;

  TJSONPairEnumerator = class(TJSONObject.TEnumerator)
  end deprecated 'Use TJSONObject.TEnumerator';

  /// <summary> Implements JSON null value </summary>
  TJSONNull = class sealed(TJSONValue)
  strict protected const
    NULLString: string = 'null';
  protected
    function AsTValue(ATypeInfo: PTypeInfo; var AValue: TValue): Boolean; override;

    /// <summary> see com.borland.dbx.transport.JSONAncestor#isNull() </summary>
    function IsNull: Boolean; override;

  public
    /// <summary> see com.borland.dbx.transport.JSONAncestor#estimatedByteSize() </summary>
    function EstimatedByteSize: Integer; override;

    /// <summary> see com.borland.dbx.transport.JSONAncestor#toBytes(byte[], int) </summary>
    function ToBytes(const Data: TArray<Byte>; Offset: Integer): Integer; override;
    procedure ToChars(Builder: TStringBuilder; Options: TJSONAncestor.TJSONOutputOptions); override;
    function Value: string; override;
    function Clone: TJSONAncestor; override;
  end;

  /// <summary> Implements JSON Boolean type from which TJSONTrue and TJSONFalse derive </summary>
  TJSONBool = class(TJSONValue)
  private
    FValue: Boolean;
  strict protected const
    FalseString: string = 'false';
    TrueString: string = 'true';
    FalseBytes: array[0..4] of Byte = (Ord('f'), Ord('a'), Ord('l'), Ord('s'), Ord('e'));
    TrueBytes: array[0..3] of Byte = (Ord('t'), Ord('r'), Ord('u'), Ord('e'));
  protected
    function AsTValue(ATypeInfo: PTypeInfo; var AValue: TValue): Boolean; override;
  public
    constructor Create(AValue: Boolean); overload;
    /// <summary> see com.borland.dbx.transport.JSONAncestor#estimatedByteSize() </summary>
    function EstimatedByteSize: Integer; override;
    /// <summary> see com.borland.dbx.transport.JSONAncestor#toBytes(byte[], int) </summary>
    function ToBytes(const Data: TArray<Byte>; Offset: Integer): Integer; override;
    procedure ToChars(Builder: TStringBuilder; Options: TJSONAncestor.TJSONOutputOptions); override;
    function Value: string; override;
    function Clone: TJSONAncestor; override;
    property AsBoolean: Boolean read FValue;
  end;

  /// <summary> Implements JSON true value </summary>
  TJSONTrue = class sealed(TJSONBool)
  public
    constructor Create; override;
    function Clone: TJSONAncestor; override;
  end;

  /// <summary> Implements JSON false value </summary>
  TJSONFalse = class sealed(TJSONBool)
  public
    constructor Create; override;
    function Clone: TJSONAncestor; override;
  end;

  /// <summary> Implements JSON array [] | [ elements ] </summary>
  TJSONArray = class sealed(TJSONValue)
  public type
    /// <summary> Support enumeration of values in a JSONArray. </summary>
    TEnumerator = class
    private
      FIndex: Integer;
      FArray: TJSONArray;
    public
      constructor Create(const AArray: TJSONArray);
      function GetCurrent: TJSONValue; inline;
      function MoveNext: Boolean; inline;
      property Current: TJSONValue read GetCurrent;
    end;

  private
    FElements: TList<TJSONValue>;
    function GetValueA(const Index: Integer): TJSONValue; override;

  protected
    function AsTValue(ATypeInfo: PTypeInfo; var AValue: TValue): Boolean; override;

    /// <summary> see com.borland.dbx.transport.JSONAncestor#addDescendent(com.borland.dbx.transport.JSONAncestor) </summary>
    procedure AddDescendant(const Descendant: TJSONAncestor); override;

    /// <summary> Removes the first element from the element list. </summary>
    /// <remarks> No checks are made, it is the caller responsibility to check if there is at least one element. </remarks>
    /// <returns>JSONValue</returns>
    function Pop: TJSONValue; inline;

    /// <summary> Returns the array component, null if index is out of range </summary>
    /// <param name="Index">- element index</param>
    /// <returns>JSONValue element, null if index is out of range</returns>
    function GetValue(const Index: Integer): TJSONValue; overload; inline;
    /// <summary> Returns the array size </summary>
    /// <returns>int - array size</returns>
    function GetCount: Integer; inline;

    procedure Format(Builder: TStringBuilder; const ParentIdent, Ident: string); overload; override;
  public
    /// <summary> Default constructor, initializes the container </summary>
    constructor Create; overload; override;

    /// <summary> Convenience constructor, wraps an array around a JSON value </summary>
    /// <param name="FirstElem">JSON value</param>
    constructor Create(const FirstElem: TJSONValue); overload;

    /// <summary> Convenience constructor, wraps an array around a JSON value </summary>
    /// <param name="FirstElem">JSON value</param>
    /// <param name="SecondElem">JSON value</param>
    constructor Create(const FirstElem: TJSONValue; const SecondElem: TJSONValue); overload;

    constructor Create(const FirstElem: string; const SecondElem: string); overload;
    /// <summary> frees the container elements </summary>
    destructor Destroy; override;

    /// <summary> Returns the array size </summary>
    /// <returns>int - array size</returns>
    property Count: Integer read GetCount;

    /// <summary> Returns the array element. Raises EArgumentOutOfRangeException exception if index is out of range </summary>
    /// <param name="Index">- element index</param>
    /// <returns>JSONValue element</returns>
    property Items[const Index: Integer]: TJSONValue read GetValue; default;

    /// <summary>Removes the pair at the given index, returning the removed pair (or nil)</summary>
    function Remove(Index: Integer): TJSONValue;

    /// <summary> Adds a non-null value to the current element list </summary>
    /// <param name="Element">string object cannot be null</param>
    procedure AddElement(const Element: TJSONValue); inline;
    function Add(const Element: string): TJSONArray; overload;
    function Add(const Element: Integer): TJSONArray; overload;
    function Add(const Element: Double): TJSONArray; overload;
    function Add(const Element: Boolean): TJSONArray; overload;
    function Add(const Element: TJSONObject): TJSONArray; overload;
    function Add(const Element: TJSONArray): TJSONArray; overload;

    /// <summary> see com.borland.dbx.transport.JSONAncestor#estimatedByteSize() </summary>
    function EstimatedByteSize: Integer; override;

    procedure SetElements(const AList: TList<TJSONValue>);

    // / <seealso cref="TJSONAncestor.ToBytes(TArray<Byte>,Integer)"/>
    function ToBytes(const Data: TArray<Byte>; Offset: Integer): Integer; override;
    procedure ToChars(Builder: TStringBuilder; Options: TJSONAncestor.TJSONOutputOptions); override;
    function Clone: TJSONAncestor; override;
    function GetEnumerator: TEnumerator; inline;

	  { Deprecated functions }
    function Size: Integer; inline; deprecated 'Use Count Property';
    function Get(const Index: Integer): TJSONValue; inline; deprecated 'Use Items property';
  end;

  function GetJSONFormat: TFormatSettings;
  function FloatToJson(const Value: Double): string;
  function JsonToFloat(const DotValue: string): Double;
  function TryJsonToFloat(const DotValue: string; var Value: Double): Boolean;
  function HexToDecimal(const AHex: Byte): Byte; inline;
  function DecimalToHex(const ADecimal: Byte): Byte; inline;

const
  MaximumNestingLevel: Integer = 512;
  DecimalToHexMap: string = '0123456789ABCDEF';
  HexToDecimalMap: array[Byte] of Byte = (
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, {00-0F}
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, {10 0F}
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, {20-2F}
     0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  0,  0,  0,  0,  0,  0, {30-3F}
     0, 10, 11, 12, 13, 14, 15,  0,  0,  0,  0,  0,  0,  0,  0,  0, {40-4F}
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, {50-5F}
     0, 10, 11, 12, 13, 14, 15,  0,  0,  0,  0,  0,  0,  0,  0,  0, {60-6F}
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, {70-7F}
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, {80-8F}
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, {90-9F}
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, {A0-AF}
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, {B0-BF}
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, {C0-CF}
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, {D0-DF}
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, {E0-EF}
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0); {F0-FF}

implementation

uses
  System.Classes, System.DateUtils, System.SysConst, System.JSONConsts;

var
  JSONFormatSettings: TFormatSettings;

function GetJSONFormat: TFormatSettings;
begin
  Result := JSONFormatSettings;
end;

function IncrAfter(var Arg: Integer): Integer; inline;
begin
  Result := Arg;
  Inc(Arg);
end;

function DecrAfter(var Arg: Integer): Integer; inline;
begin
  Result := Arg;
  Dec(Arg);
end;

function FloatToJson(const Value: Double): string;
begin
  Result := FloatToStr(Value, JSONFormatSettings);
end;

function JsonToFloat(const DotValue: string): Double;
begin
  Result := StrToFloat(DotValue, JSONFormatSettings);
end;

function TryJsonToFloat(const DotValue: string; var Value: Double): Boolean;
begin
  Result := TryStrToFloat(DotValue, Value, JSONFormatSettings);
end;

  {$R-}
function StrToTValue(const AStr: string; const ATypeInfo: PTypeInfo; var AValue: TValue): Boolean;

  function CheckRange(const AMin, AMax: Int64; const AValue: Int64; const AStr: string): Int64;
  begin
    Result := AValue;
    if (AValue < AMin) or (AValue > AMax) then
      raise EConvertError.CreateResFmt(@SInvalidInteger, [AStr]);
  end;

  function IsBoolean: Boolean;
  var
    LTypeName: string;
  begin
    LTypeName := ATypeInfo.NameFld.ToString;
    Result := SameText(LTypeName, 'boolean') or SameText(LTypeName, 'bool');
  end;

var
  LPtr: Pointer;
  LValI32: Int32;
  LValI64: Int64;
  LValBool: Boolean;
  LValSngl: Single;
  LValDbl: Double;
  LValExt: Extended;
  LValComp: Comp;
  LValCurr: Currency;
  LValChr: Char;
  LCode: Integer;
begin
  Result := True;
  LPtr := nil;
  case ATypeInfo.Kind of
    tkInteger:
      begin
        case GetTypeData(ATypeInfo)^.OrdType of
          otSByte: LValI32 := CheckRange(Low(Int8), High(Int8), StrToInt(AStr), AStr);
          otSWord: LValI32 := CheckRange(Low(Int16), High(Int16), StrToInt(AStr), AStr);
          otSLong: LValI32 := StrToInt(AStr);
          otUByte: LValI32 := CheckRange(Low(UInt8), High(UInt8), StrToInt(AStr), AStr);
          otUWord: LValI32 := CheckRange(Low(UInt16), High(UInt16), StrToInt(AStr), AStr);
          otULong: LValI32 := CheckRange(Low(UInt32), High(UInt32), StrToInt64(AStr), AStr);
        end;
        LPtr := @LValI32;
      end;
    tkInt64:
      begin
        if ATypeInfo^.TypeData^.MinInt64Value > ATypeInfo^.TypeData^.MaxInt64Value then
          LValI64 := StrToUInt64(AStr)
        else
          LValI64 := StrToInt64(AStr);
        LPtr := @LValI64;
      end;
    tkEnumeration:
      if IsBoolean() then
      begin
        LValBool := StrToBool(AStr);
        LPtr := @LValBool;
      end
      else
      begin
        LValI32 := GetEnumValue(ATypeInfo, AStr);
        Result := LValI32 >= 0;
        if not Result then
        begin
          Val(AStr, LValI32, LCode);
          Result := LCode = 0;
        end;
        if Result then
          LPtr := @LValI32;
      end;
    tkFloat:
      case GetTypeData(ATypeInfo)^.FloatType of
        ftSingle:
          begin
            LValSngl := StrToFloat(AStr, JSONFormatSettings);
            LPtr := @LValSngl;
          end;
        ftDouble:
          begin
            if ATypeInfo = System.TypeInfo(TDate) then
              LValDbl := ISO8601ToDate(AStr)
            else if ATypeInfo = System.TypeInfo(TTime) then
              LValDbl := ISO8601ToDate(AStr)
            else if ATypeInfo = System.TypeInfo(TDateTime) then
              LValDbl := ISO8601ToDate(AStr)
            else
              LValDbl := StrToFloat(AStr, JSONFormatSettings);
            LPtr := @LValDbl;
          end;
        ftExtended:
          begin
            LValExt := StrToFloat(AStr, JSONFormatSettings);
            LPtr := @LValExt;
          end;
        ftComp:
          begin
            LValComp := StrToFloat(AStr, JSONFormatSettings);
            LPtr := @LValComp;
          end;
        ftCurr:
          begin
            LValCurr := StrToCurr(AStr, JSONFormatSettings);
            LPtr := @LValCurr;
          end;
      end;
{$IFNDEF NEXTGEN}
    tkChar,
{$ENDIF !NEXTGEN}
    tkWChar:
      if AStr.Length = 1 then
      begin
        LValChr := AStr[Low(string)];
        LPtr := @LValChr;
      end
      else
        Result := False;
    tkUString:
      LPtr := @AStr;
    tkString, tkLString, tkWString:
      TValue.Make(@AStr, TypeInfo(string), AValue);
    else
      Result := False;
  end;
  if Result and (LPtr <> nil) then
    TValue.Make(LPtr, ATypeInfo, AValue);
end;
  {$R+}

function HexToDecimal(const AHex: Byte): Byte;
begin
  Result := HexToDecimalMap[AHex];
end;

function DecimalToHex(const ADecimal: Byte): Byte;
begin
  Result := Byte(DecimalToHexMap.Chars[ADecimal]);
end;

{ EJSONParseException }

constructor EJSONParseException.Create(AOffset: Integer; ABr: TJSONByteReader;
  AValue: TJSONValue; AIdent: PResStringRec; const AArgs: array of const);
var
  LPair: TJSONPair;
begin
  FPath := '';
  while AValue <> nil do
    if (AValue.ClassType = TJSONArray) and (TJSONArray(AValue).Count > 0) then
    begin
      FPath := FPath + '[' + IntToStr(TJSONArray(AValue).Count - 1) + ']';
      AValue := TJSONArray(AValue).Items[TJSONArray(AValue).Count - 1];
    end
    else if (AValue.ClassType = TJSONObject) and (TJSONObject(AValue).Count > 0) then
    begin
      LPair := TJSONObject(AValue).Pairs[TJSONObject(AValue).Count - 1];
      if FPath <> '' then
        FPath := FPath + '.';
      if LPair.JsonString = nil then
        FPath := FPath + '<null>'
      else
        FPath := FPath + LPair.JsonString.Value;
      AValue := LPair.JsonValue;
    end
    else
      AValue := nil;

  if AOffset < 0 then
    FOffset := - AOffset
  else
    FOffset := AOffset;
  ABr.OffsetToPos(FOffset, FLine, FPosition);

  Create(Format(LoadResString(AIdent), AArgs) +
    Format(SJSONLocation, [FPath, FLine, FPosition, FOffset]));
end;

constructor EJSONParseException.Create(AOffset: Integer; ABr: TJSONByteReader;
  AValue: TJSONValue);
begin
  Create(AOffset, ABr, AValue, @SJSONSyntaxError, []);
end;

{ TJSONPathParser }

constructor TJSONPathParser.Create(const APathPtr: PChar; ALen: Integer);
begin
  FPathPtr := APathPtr;
  FPtr := FPathPtr;
  FEndPtr := FPathPtr + ALen;
end;

constructor TJSONPathParser.Create(const APath: string);
begin
  FPathPtr := PChar(APath);
  FPtr := FPathPtr;
  FEndPtr := FPathPtr + Length(APath);
end;

function TJSONPathParser.EnsureLength(ALength: Integer): Boolean;
begin
  Result := (FPtr + ALength) < FEndPtr;
end;

function TJSONPathParser.GetIsEof: Boolean;
begin
  Result := FPtr >= FEndPtr;
end;

procedure TJSONPathParser.FrontTrim(var APtr: PChar);
begin
  while (APtr < FEndPtr) and (APtr^ <= ' ') do
    Inc(APtr);
end;

procedure TJSONPathParser.BackTrim(var APtr: PChar);
begin
  while (APtr > FPtr) and (APtr^ <= ' ') do
    Dec(APtr);
end;

function TJSONPathParser.NextToken: TToken;
var
  IsFirstToken: Boolean;
begin
  IsFirstToken := FPtr = FPathPtr;
  FrontTrim(FPtr);
  if IsEof then
    FToken := TToken.Eof
  else
  begin
    case FPtr^ of
      '.':
        // Root element cannot start with a dot
        if IsFirstToken then
          RaiseError(@SJSONPathUnexpectedRootChar)
        else
          ParseName;
      '[':
        ParseIndexer;
      else
        // In dot notation all names are prefixed by '.', except the root element
        if IsFirstToken then
          ParseName
        else
          RaiseErrorFmt(@SJSONPathUnexpectedIndexedChar, [FPtr^]);
    end;
    Inc(FPtr);
  end;
  Result := FToken;
end;

procedure TJSONPathParser.ParseArrayIndex;
var
  LPtr, LPtr2: PChar;
  E: Integer;
begin
  LPtr := StrScan(FPtr, ']');
  if LPtr = nil then
    RaiseError(@SJSONPathEndedOpenBracket);

  LPtr2 := LPtr - 1;
  BackTrim(LPtr2);

  SetString(FTokenName, FPtr, LPtr2 - FPtr + 1);
  FPtr := LPtr - 1;
  Val(FTokenName, FTokenArrayIndex, E);
  if E = 0 then
    FToken := TToken.ArrayIndex
  else
    RaiseErrorFmt(@SJSONPathInvalidArrayIndex, [FTokenName]);
end;

procedure TJSONPathParser.ParseQuotedName(AQuote: Char);
var
  LString: string;
begin
  LString := '';
  Inc(FPtr);
  while not IsEof do
  begin
    if (FPtr^ = '\') and EnsureLength(1) and ((FPtr + 1)^ = AQuote) then // \"
    begin
      Inc(FPtr);
      LString := LString + AQuote;
    end
    else if FPtr^ = AQuote then
    begin
      FToken := TToken.Name;
      FTokenName := LString;
      Exit;
    end
    else
      LString := LString + FPtr^;
    Inc(FPtr);
  end;
  RaiseError(@SJSONPathEndedOpenString);
end;

procedure TJSONPathParser.RaiseError(AMsg: PResStringRec);
begin
  RaiseErrorFmt(AMsg, []);
end;

procedure TJSONPathParser.RaiseErrorFmt(AMsg: PResStringRec; const AParams: array of const);
begin
  FToken := TToken.Error;
  raise EJSONPathException.CreateResFmt(AMsg, AParams);
end;

procedure TJSONPathParser.ParseIndexer;
begin
  Inc(FPtr); // [
  FrontTrim(FPtr);
  if IsEof then
    RaiseError(@SJSONPathEndedOpenBracket);
  case FPtr^ of
    '"',
    '''':
      ParseQuotedName(FPtr^);
  else
    ParseArrayIndex;
  end;
  Inc(FPtr);
  FrontTrim(FPtr);
  if FPtr^ <> ']' then
    RaiseErrorFmt(@SJSONPathUnexpectedIndexedChar, [FPtr^]);
end;

procedure TJSONPathParser.ParseName;
var
  LPtr, LPtr2: PChar;
begin
  if FPtr^ = '.' then
  begin
    Inc(FPtr);
    if IsEof then
    begin
      FToken := TToken.Error;
      Exit;
    end;
  end;

  FrontTrim(FPtr);

  LPtr := FPtr;
  while (LPtr < FEndPtr) and not (Ord(LPtr^) in [Ord('.'), Ord('[')]) do
    Inc(LPtr);

  LPtr2 := LPtr - 1;
  BackTrim(LPtr2);

  SetString(FTokenName, FPtr, LPtr2 - FPtr + 1);
  FPtr := LPtr - 1;
  if FTokenName = '' then
    RaiseError(@SJSONPathDotsEmptyName)
  else
    FToken := TToken.Name;
end;

{ TJSONAncestor }

constructor TJSONAncestor.Create;
begin
  inherited Create;
  FOwned := True;
end;

function TJSONAncestor.IsNull: Boolean;
begin
  Result := False;
end;

function TJSONAncestor.Value: string;
begin
  Result := '';
end;

procedure TJSONAncestor.AddDescendant(const Descendent: TJSONAncestor);
begin
  raise EJSONException.CreateResFmt(@SCannotAddJSONValue,
    [Descendent.ClassName, ClassName]);
end;

function TJSONAncestor.ToJSON(Options: TJSONOutputOptions): string;
var
  Buf: TStringBuilder;
begin
  Buf := TStringBuilder.Create(256);
  try
    ToChars(Buf, Options);
    Result := Buf.ToString(True);
  finally
    Buf.Free;
  end;
end;

function TJSONAncestor.ToJSON: string;
begin
  Result := ToJSON([TJSONOutputOption.EncodeBelow32, TJSONOutputOption.EncodeAbove127]);
end;

function TJSONAncestor.ToString: string;
var
  Buf: TStringBuilder;
begin
  Buf := TStringBuilder.Create(256);
  try
    ToChars(Buf, []);
    Result := Buf.ToString(True);
  finally
    Buf.Free;
  end;
end;

function TJSONAncestor.Format(Indentation: Integer): string;
var
  Buf: TStringBuilder;
begin
  Buf := TStringBuilder.Create(256);
  try
    Format(Buf, '', StringOfChar(' ', Indentation));
    Result := Buf.ToString(True);
  finally
    Buf.Free;
  end;
end;

procedure TJSONAncestor.Format(Builder: TStringBuilder; const ParentIdent, Ident: string);
begin
  ToChars(Builder, []);
end;

{ TJSONByteReader }

procedure TJSONByteReader.Init(const Data: PByte; const Offset: Integer; const Range: Integer);
const
  CInitialLen = $10;
begin
  if (Data = nil) or (Offset < 0) or (Offset >= Range) then
  begin
    // next IsEof call will return True
    FDataStart := Pointer(1);
    FData := Pointer(1);
    FDataEnd := nil;
  end
  else
  begin
    FDataStart := Data;
    FData := Data + Offset;
    FDataEnd := Data + Range - 1;
  end;

  FStringCache := TDictionary<Cardinal, String>.Create();
  SetLength(FCharData, CInitialLen);
  FCharLen := CInitialLen;
  FCharPos := 0;
  FCache := (Range - Offset) > 1000000;
end;

constructor TJSONByteReader.Create(const Data: PByte; const Offset: Integer; const Range: Integer);
begin
  inherited Create;
  Init(Data, Offset, Range);
  ConsumeBOM;
end;

constructor TJSONByteReader.Create(const Data: PByte; const Offset: Integer; const Range: Integer; const IsUTF8: Boolean);
begin
  inherited Create;
  Init(Data, Offset, Range);
  FIsUTF8 := IsUTF8;
  if IsUTF8 then
    ConsumeBOM;
end;

destructor TJSONByteReader.Destroy;
begin
  FStringCache.Free;
  inherited Destroy;
end;

function TJSONByteReader.GetOffset: Integer;
begin
  Result := FData - FDataStart;
end;

procedure TJSONByteReader.ConsumeBOM;
begin
  if FData + 2 <= FDataEnd then
  begin
    if (FData^ = Byte(239)) and ((FData + 1)^ = Byte(187)) and ((FData + 2)^ = Byte(191)) then
    begin
      FIsUTF8 := True;
      Inc(FData, 3);
    end;
  end;
end;

procedure TJSONByteReader.MoveOffset;
begin
  if FUtf8offset < FUtf8length then
    Inc(FUtf8offset)
  else
    Inc(FData);
end;

function TJSONByteReader.ConsumeByte: Byte;
begin
  Result := PeekByte;
  MoveOffset;
end;

procedure TJSONByteReader.SkipByte;
begin
  MoveOffset;
end;

procedure TJSONByteReader.ProcessMBCS;
var
  Bmp: Int64;
  W1: Integer;
  W2: Integer;
begin
  FUtf8offset := 0;
  if (FData^ and Byte(224)) = Byte(192) then
  begin
    if FData + 1 > FDataEnd then
      raise EJSONParseException.Create(Offset, Self, nil, @SUTF8Start, []);
    if ((FData + 1)^ and Byte(192)) <> Byte(128) then
      raise EJSONParseException.Create(Offset + 1, Self, nil, @SUTF8UnexpectedByte, [2]);
    SetLength(FUtf8data, 6);
    FUtf8length := 6;
    FUtf8data[0] := Ord('\');
    FUtf8data[1] := Ord('u');
    FUtf8data[2] := DecimalToHex(0);
    FUtf8data[3] := DecimalToHex((FData^ and Byte(28)) shr 2);
    FUtf8data[4] := DecimalToHex((Byte(FData^ and Byte(3)) shl 2) or Byte(Byte((FData + 1)^ and Byte(48)) shr 4));
    FUtf8data[5] := DecimalToHex((FData + 1)^ and Byte(15));
    Inc(FData, 2);
  end
  else if (FData^ and Byte(240)) = Byte(224) then
  begin
    if FData + 2 > FDataEnd then
      raise EJSONParseException.Create(Offset, Self, nil, @SUTF8Start, []);
    if ((FData + 1)^ and Byte(192)) <> Byte(128) then
      raise EJSONParseException.Create(Offset + 1, Self, nil, @SUTF8UnexpectedByte, [3]);
    if ((FData + 2)^ and Byte(192)) <> Byte(128) then
      raise EJSONParseException.Create(Offset + 2, Self, nil, @SUTF8UnexpectedByte, [3]);
    SetLength(FUtf8data,6);
    FUtf8length := 6;
    FUtf8data[0] := Ord('\');
    FUtf8data[1] := Ord('u');
    FUtf8data[2] := DecimalToHex(FData^ and Byte(15));
    FUtf8data[3] := DecimalToHex((Byte((FData + 1)^ and Byte(60))) shr 2);
    FUtf8data[4] := DecimalToHex((Byte((FData + 1)^ and Byte(3)) shl 2) or Byte(Byte((FData + 2)^ and Byte(48)) shr 4));
    FUtf8data[5] := DecimalToHex((FData + 2)^ and Byte(15));
    Inc(FData, 3);
  end
  else if (FData^ and Byte(248)) = Byte(240) then
  begin
    if FData + 3 > FDataEnd then
      raise EJSONParseException.Create(Offset, Self, nil, @SUTF8Start, []);
    if ((FData + 1)^ and Byte(192)) <> Byte(128) then
      raise EJSONParseException.Create(Offset + 1, Self, nil, @SUTF8UnexpectedByte, [4]);
    if ((FData + 2)^ and Byte(192)) <> Byte(128) then
      raise EJSONParseException.Create(Offset + 2, Self, nil, @SUTF8UnexpectedByte, [4]);
    if ((FData + 3)^ and Byte(192)) <> Byte(128) then
      raise EJSONParseException.Create(Offset + 3, Self, nil, @SUTF8UnexpectedByte, [4]);
    Bmp := FData^ and Byte(7);
    Bmp := (Bmp shl 6) or ((FData + 1)^ and Byte(63));
    Bmp := (Bmp shl 6) or ((FData + 2)^ and Byte(63));
    Bmp := (Bmp shl 6) or ((FData + 3)^ and Byte(63));
    Bmp := Bmp - 65536;
    W1 := 55296;
    W1 := W1 or ((Integer((Bmp shr 10))) and 2047);
    W2 := 56320;
    W2 := W2 or Integer((Bmp and 2047));
    SetLength(FUtf8data,12);
    FUtf8length := 12;
    FUtf8data[0] := Ord('\');
    FUtf8data[1] := Ord('u');
    FUtf8data[2] := DecimalToHex((W1 and 61440) shr 12);
    FUtf8data[3] := DecimalToHex((W1 and 3840) shr 8);
    FUtf8data[4] := DecimalToHex((W1 and 240) shr 4);
    FUtf8data[5] := DecimalToHex(W1 and 15);
    FUtf8data[6] := Ord('\');
    FUtf8data[7] := Ord('u');
    FUtf8data[8] := DecimalToHex((W2 and 61440) shr 12);
    FUtf8data[9] := DecimalToHex((W2 and 3840) shr 8);
    FUtf8data[10] := DecimalToHex((W2 and 240) shr 4);
    FUtf8data[11] := DecimalToHex(W2 and 15);
    Inc(FData, 4);
  end
  else
    raise EJSONParseException.Create(Offset, Self, nil, @SUTF8InvalidHeaderByte, []);
end;

function TJSONByteReader.PeekRawByte: Byte;
begin
  if not FIsUTF8 then
    Exit(FData^);
  if FUtf8offset < FUtf8length then
    Exit(FUtf8data[FUtf8offset]);
  Result := FData^;
end;

function TJSONByteReader.PeekByte: Byte;
begin
  Result := PeekRawByte;
  if (Result and Byte(128)) <> 0 then
  begin
    ProcessMBCS;
    Result := FUtf8data[FUtf8offset];
  end;
end;

function TJSONByteReader.IsEof: Boolean;
begin
  Result := (FData > FDataEnd) and (FUtf8offset >= FUtf8length);
end;

procedure TJSONByteReader.SkipWhitespaces;
begin
  while not IsEof and (PeekRawByte in [32, 9, 10, 13]) do
    SkipByte;
end;

function TJSONByteReader.HasMore(const Size: Integer): Boolean;
begin
  if FData + Size <= FDataEnd then
    Result := True
  else if FUtf8offset + Size <= FUtf8length then
    Result := True
  else
    Result := False;
end;

procedure TJSONByteReader.AddChar(Ch: Char);
begin
  if FCharPos = FCharLen then
  begin
    FCharLen := FCharLen * 2;
    SetLength(FCharData, FCharLen);
  end;
  FCharData[FCharPos] := Ch;
  Inc(FCharPos);
end;

procedure TJSONByteReader.ResetString;
begin
  FCharPos := 0;
end;

{$IFOPT Q+}
  {$Q-}
  {$DEFINE Q_ON}
{$ENDIF}
procedure TJSONByteReader.FlushString(var ADest: string; ACache: Boolean);

  function HashString(const s: string): Cardinal; inline;
  var
    P, PEnd: PChar;
  begin
    Result := Length(s);
    P := Pointer(s);
    PEnd := P + Result;
    while P < PEnd do
    begin
      Result := (Result xor Ord(P^)) * 16777619;
      Inc(P);
    end;
  end;

  procedure CheckCache;
  var
    LCached: string;
    LHash: Cardinal;
  begin
    LHash := HashString(ADest);
    // NOTE: We have strings that produce the same hashes here,
    //       only the first benefits from cache (which is really an intern pool).
    if FStringCache.ContainsKey(LHash) then
    begin
      LCached := FStringCache[LHash];
      if LCached = ADest then
        ADest := LCached;
    end
    else
      FStringCache.Add(LHash, ADest);
  end;

begin
  SetString(ADest, PChar(FCharData), FCharPos);
  ResetString;
  if ACache and FCache then
    CheckCache;
end;
{$IFDEF Q_ON}
  {$Q+}
  {$UNDEF Q_ON}
{$ENDIF}

procedure TJSONByteReader.OffsetToPos(AOffset: Integer; var ALine,
  APos: Integer);
var
  P: PByte;
  I: Integer;
begin
  P := FDataStart;
  ALine := 1;
  APos := 1;
  while (P <= FDataEnd) and (AOffset > 0) do
  begin
    if (P^ and Byte(128)) = 0 then
    begin
      I := 1;
      if (P^ = 13) or (P^ = 10) then
      begin
        Inc(ALine);
        APos := 0;
        if (((P + 1)^ = 13) or ((P + 1)^ = 10)) and ((P + 1)^ <> P^) then
          Inc(I);
      end;
    end
    else if (P^ and Byte(224)) = Byte(192) then
      I := 2
    else if (P^ and Byte(240)) = Byte(224) then
      I := 3
    else if (P^ and Byte(248)) = Byte(240) then
      I := 4
    else
      I := 1;
    Inc(P, I);
    Dec(AOffset, I);
    Inc(APos);
  end;
end;

procedure TJSONByteReader.EnterLevel;
begin
  if FLevel >= MaximumNestingLevel then
    raise EJSONParseException.Create(Offset, Self, nil, @STooMuchNesting, [MaximumNestingLevel]);
  Inc(FLevel);
end;

procedure TJSONByteReader.ExitLevel;
begin
  Dec(FLevel);
end;

{ TJSONValue }

function TJSONValue.GetValue<T>(const APath: string; ADefaultValue: T): T;
var
  LJSONValue: TJSONValue;
  LTypeInfo: PTypeInfo;
begin
  LJSONValue := FindValue(APath);

  // Treat JSONNull as nil
  if LJSONValue is TJSONNull then
  begin
    LTypeInfo := System.TypeInfo(T);
    if LTypeInfo.TypeData.ClassType <> nil then
      LJSONValue := nil;
  end;

  if LJSONValue <> nil then
    Result := LJSONValue.AsType<T>
  else
    Result := ADefaultValue
end;

function TJSONValue.GetValueP(const APath: string): TJSONValue;
begin
  Result := FindValue(APath);
  if Result = nil then
    raise EJSONException.CreateResFmt(@SValueNotFound, [APath]);
end;

function TJSONValue.GetValue<T>(const APath: string): T;
begin
  Result := P[APath].AsType<T>;
end;

function TJSONValue.GetValueA(const AIndex: Integer): TJSONValue;
begin
  Result := P['[' + AIndex.ToString + ']'];
end;

function TJSONValue.AsTValue(ATypeInfo: PTypeInfo; var AValue: TValue): Boolean;
begin
  Result := True;
  case ATypeInfo^.Kind of
    tkClass:
      TValue.Make(@Self, ATypeInfo, AValue);
    else
      Result := False;
  end;
end;

function TJSONValue.AsType<T>: T;
var
  LTypeInfo: PTypeInfo;
  LValue: TValue;
begin
  LTypeInfo := System.TypeInfo(T);
  if not AsTValue(LTypeInfo, LValue) then
    raise EJSONException.CreateResFmt(@SCannotConvertJSONValueToType,
      [ClassName, LTypeInfo.Name]);
  Result := LValue.AsType<T>;
end;

function TJSONValue.TryGetValue<T>(out AValue: T): Boolean;
begin
  Result := TryGetValue<T>('', AValue);
end;

function TJSONValue.TryGetValue<T>(const APath: string; out AValue: T): Boolean;
var
  LJSONValue: TJSONValue;
begin
  LJSONValue := FindValue(APath);
  Result := LJSONValue <> nil;
  if Result then
    try
      AValue := LJSONValue.AsType<T>;
    except
      Result := False;
    end;
end;

class function TJSONValue.ParseObject(const Br: TJSONByteReader; const Parent: TJSONAncestor; UseBool: Boolean): Integer;
var
  JsonObj: TJSONObject;
begin
  Br.EnterLevel;
  JsonObj := TJSONObject.Create;
  Parent.AddDescendant(JsonObj);
  Result := JsonObj.Parse(Br, UseBool);
  Br.ExitLevel;
end;

class function TJSONValue.ParsePair(const Br: TJSONByteReader; const Parent: TJSONObject; UseBool: Boolean): Integer;
var
  Pair: TJSONPair;
  CommaPos: Integer;
begin
  Pair := TJSONPair.Create;
  Parent.AddDescendant(Pair);
  CommaPos := ParseString(Br, Pair);
  if CommaPos > 0 then
  begin
    Br.SkipWhitespaces;
    if Br.IsEof then
      Exit(-Br.Offset);
    if Br.PeekByte <> Ord(':') then
      Exit(-Br.Offset);
    Br.SkipByte;
    Br.SkipWhitespaces;
    CommaPos := ParseValue(Br, Pair, UseBool);
  end;
  Result := CommaPos;
end;

class function TJSONValue.ParseArray(const Br: TJSONByteReader; const Parent: TJSONAncestor; UseBool: Boolean): Integer;
var
  ValueExpected: Boolean;
  JsonArray: TJSONArray;
  Pos: Integer;
begin
  Br.SkipWhitespaces;
  if Br.IsEof then
    Exit(-Br.Offset);
  if Br.PeekByte <> Ord('[') then
    Exit(-Br.Offset);
  Br.SkipByte;
  Br.EnterLevel;
  JsonArray := TJSONArray.Create;
  Parent.AddDescendant(JsonArray);
  ValueExpected := False;
  Br.SkipWhitespaces;
  while ValueExpected or (Br.PeekByte <> Ord(']')) do
  begin
    Br.SkipWhitespaces;
    Pos := ParseValue(Br, JsonArray, UseBool);
    if Pos <= 0 then
      Exit(Pos);
    Br.SkipWhitespaces;
    if Br.IsEof then
      Exit(-Br.Offset);
    ValueExpected := False;
    if Br.PeekByte = Ord(',') then
    begin
      Br.SkipByte;
      ValueExpected := True;
    end
    else if Br.PeekByte <> Ord(']') then
      Exit(-Br.Offset);
  end;
  Br.SkipByte;
  Br.SkipWhitespaces;
  Br.ExitLevel;
  Result := Br.Offset;
end;

class function TJSONValue.ParseValue(const Br: TJSONByteReader; const Parent: TJSONAncestor; UseBool: Boolean): Integer;
var
  Pos: Integer;
begin
  Pos := Br.Offset;
  if Br.IsEof then
    Exit(-Pos);
  case Br.PeekByte of
    Ord('"'):
      Exit(ParseString(Br, Parent));
    Ord('-'),
    Ord('0'),
    Ord('1'),
    Ord('2'),
    Ord('3'),
    Ord('4'),
    Ord('5'),
    Ord('6'),
    Ord('7'),
    Ord('8'),
    Ord('9'):
      Exit(ParseNumber(Br, Parent));
    Ord('{'):
      Exit(ParseObject(Br, Parent, UseBool));
    Ord('['):
      Exit(ParseArray(Br, Parent, UseBool));
    Ord('t'):
      begin
        if not Br.HasMore(3) then
          Exit(-Pos);
        Br.SkipByte;
        if (Br.ConsumeByte <> Ord('r')) or (Br.ConsumeByte <> Ord('u')) or (Br.ConsumeByte <> Ord('e')) then
          Exit(-Pos);
        if UseBool then
          Parent.AddDescendant(TJSONBool.Create(True))
        else
          Parent.AddDescendant(TJSONTrue.Create);
        Exit(Br.Offset);
      end;
    Ord('f'):
      begin
        if not Br.HasMore(4) then
          Exit(-Pos);
        Br.SkipByte;
        if (Br.ConsumeByte <> Ord('a')) or (Br.ConsumeByte <> Ord('l')) or (Br.ConsumeByte <> Ord('s')) or (Br.ConsumeByte <> Ord('e')) then
          Exit(-Pos);
        if UseBool then
          Parent.AddDescendant(TJSONBool.Create(False))
        else
          Parent.AddDescendant(TJSONFalse.Create);
        Exit(Br.Offset);
      end;
    Ord('n'):
      begin
        if not Br.HasMore(3) then
          Exit(-Pos);
        Br.SkipByte;
        if (Br.ConsumeByte <> Ord('u')) or (Br.ConsumeByte <> Ord('l')) or (Br.ConsumeByte <> Ord('l')) then
          Exit(-Pos);
        Parent.AddDescendant(TJSONNull.Create);
        Exit(Br.Offset);
      end;
  end;
  Result := -Pos;
end;

class function TJSONValue.ParseNumber(const Br: TJSONByteReader; const Parent: TJSONAncestor): Integer;
var
  Nb: TJSONNumber;
  Consume: Boolean;
  Exponent: Boolean;
  OneAdded: Boolean;

  function FlushString(Br: TJSONByteReader; Nb: TJSONNumber): Integer; inline;
  begin
    Br.FlushString(Nb.FValue, False);
    Result := Br.Offset;
  end;

begin
  Nb := TJSONNumber.Create('');
  Parent.AddDescendant(Nb);
  Br.ResetString;
  if Br.PeekByte = Ord('-') then
  begin
    Br.AddChar('-');
    Br.SkipByte;
    if Br.IsEof or not (Br.PeekByte in [Ord('0') .. Ord('9'), Ord('e'), Ord('E')]) then
      Exit(-Br.Offset);
  end;
  if Br.PeekByte = Ord('0') then
  begin
    Br.AddChar('0');
    Br.SkipByte;
    if Br.IsEof then
      Exit(FlushString(Br, Nb));
    if Br.PeekByte in [Ord('0') .. Ord('9')] then
      Exit(-Br.Offset);
  end;
  Consume := True;
  while Consume do
    if Br.PeekByte in [Ord('0') .. Ord('9')] then
    begin
      Br.AddChar(Char(Br.ConsumeByte));
      if Br.IsEof then
        Exit(FlushString(Br, Nb));
    end
    else
      Consume := False;
  Exponent := False;
  if Br.PeekByte = Ord(JSONFormatSettings.DecimalSeparator) then
  begin
    Br.AddChar(JSONFormatSettings.DecimalSeparator);
    Br.SkipByte;
    if Br.IsEof then
      Exit(-Br.Offset);
  end
  else if (Br.PeekByte = Ord('e')) or (Br.PeekByte = Ord('E')) then
  begin
    Br.AddChar(Char(Br.ConsumeByte));
    Exponent := True;
    if Br.IsEof then
      Exit(-Br.Offset);
    if (Br.PeekByte = Ord('-')) or (Br.PeekByte = Ord('+')) then
    begin
      Br.AddChar(Char(Br.ConsumeByte));
      if Br.IsEof then
        Exit(-Br.Offset);
    end;
  end
  else
    Exit(FlushString(Br, Nb));
  OneAdded := False;
  Consume := True;
  while Consume do
    if Br.PeekByte in [Ord('0') .. Ord('9')] then
    begin
      Br.AddChar(Char(Br.ConsumeByte));
      OneAdded := True;
      if Br.IsEof then
        Exit(FlushString(Br, Nb));
    end
    else
      Consume := False;
  if not OneAdded then
    Exit(-Br.Offset);
  if not Exponent and ((Br.PeekByte = Ord('e')) or (Br.PeekByte = Ord('E'))) then
  begin
    Br.AddChar(Char(Br.ConsumeByte));
    if Br.IsEof then
      Exit(-Br.Offset);
    if (Br.PeekByte = Ord('-')) or (Br.PeekByte = Ord('+')) then
    begin
      Br.AddChar(Char(Br.ConsumeByte));
      if Br.IsEof then
        Exit(-Br.Offset);
    end;
    OneAdded := False;
    Consume := True;
    while Consume do
      if Br.PeekByte in [Ord('0') .. Ord('9')] then
      begin
        Br.AddChar(Char(Br.ConsumeByte));
        OneAdded := True;
        if Br.IsEof then
          Exit(FlushString(Br, Nb));
      end
      else
        Consume := False;
    if not OneAdded then
      Exit(-Br.Offset);
  end;
  Result := FlushString(Br, Nb);
end;

class function TJSONValue.ParseString(const Br: TJSONByteReader; const Parent: TJSONAncestor): Integer;
var
  UnicodeCh: Integer;
  Ch: Char;
  Str: TJSONString;
  B: Byte;
  i: Integer;
begin
  if Br.PeekByte <> Ord('"') then
    Exit(-Br.Offset);
  Br.SkipByte;
  if Br.IsEof then
    Exit(-Br.Offset);
  Str := TJSONString.Create('');
  Parent.AddDescendant(Str);
  Br.ResetString;
  while True do
  begin
    B := Br.PeekByte;
    case B of
      Ord('"'):
        Break;
      Ord('\'):
        begin
          Br.SkipByte;
          if Br.IsEof then
            Exit(-Br.Offset);
          case Br.PeekRawByte of
            Ord('"'):
              Ch := '"';
            Ord('\'):
              Ch := '\';
            Ord('/'):
              Ch := '/';
            Ord('b'):
              Ch := #$8;
            Ord('f'):
              Ch := #$c;
            Ord('n'):
              Ch := #$a;
            Ord('r'):
              Ch := #$d;
            Ord('t'):
              Ch := #$9;
            Ord('u'):
              begin
                Br.SkipByte;
                if not Br.HasMore(4) then
                  Exit(-Br.Offset);
                i := 12;
                UnicodeCh := 0;
                while True do
                begin
                  B := Br.PeekRawByte;
                  if not (B in [Ord('0') .. Ord('9'), Ord('a') .. Ord('f'), Ord('A') .. Ord('F')]) then
                    Exit(-Br.Offset);
                  UnicodeCh := UnicodeCh or HexToDecimal(B) shl i;
                  Dec(i, 4);
                  if i < 0 then
                    Break;
                  Br.SkipByte;
                end;
                Ch := Char(UnicodeCh);
              end;
            else
              Exit(-Br.Offset);
          end;
        end;
      else
        Ch := Char(B);
    end;
    Br.AddChar(Ch);
    Br.SkipByte;
    if Br.IsEof then
      Exit(-Br.Offset);
  end;
  Br.SkipByte;
  Br.FlushString(Str.FValue, Br.FCache and (Parent.ClassType = TJSONPair) and (TJSONPair(Parent).JsonValue = nil));
  Result := Br.Offset;
end;

class function TJSONValue.ParseJSONValue(const Data: PByte; const Offset: Integer;
  const ALength: Integer; Options: TJSONParseOptions): TJSONValue;
var
  Parent: TJSONArray;
  Br: TJSONByteReader;
  FinOff: Integer;
  LExc: Boolean;
begin
  Parent := TJSONArray.Create;
  Result := nil;
  LExc := False;
  Br := TJSONByteReader.Create(Data, Offset, ALength, TJSONParseOption.IsUTF8 in Options);
  try
    try
      Br.SkipWhitespaces;
      FinOff := ParseValue(Br, Parent, TJSONParseOption.UseBool in Options);
    except
      on E: EJSONParseException do
        if TJSONParseOption.RaiseExc in Options then
          raise
        else
        begin
          LExc := True;
          FinOff := E.Offset;
        end;
    end;
    if not LExc and (FinOff = ALength) and (Parent.Count = 1) then
      Result := Parent.Pop
    else if TJSONParseOption.RaiseExc in Options then
      if Parent.Count >= 1 then
        raise EJSONParseException.Create(FinOff, Br, Parent.Items[0])
      else
        raise EJSONParseException.Create(FinOff, Br, nil);
  finally
    Parent.Free;
    Br.Free;
  end;
end;

class function TJSONValue.ParseJSONValue(const Data: TArray<Byte>; const Offset: Integer;
  const ALength: Integer; Options: TJSONParseOptions): TJSONValue;
begin
  Result := ParseJSONValue(PByte(Data), Offset, ALength, Options);
end;

class function TJSONValue.MakeParseOptions(IsUTF8, UseBool, RaiseExc: Boolean): TJSONValue.TJSONParseOptions;
begin
  Result := [];
  if IsUTF8 then Include(Result, TJSONObject.TJSONParseOption.IsUTF8);
  if UseBool then Include(Result, TJSONObject.TJSONParseOption.UseBool);
  if RaiseExc then Include(Result, TJSONObject.TJSONParseOption.RaiseExc);
end;

class function TJSONValue.ParseJSONValue(const Data: TArray<Byte>; const Offset: Integer;
  Options: TJSONParseOptions): TJSONValue;
begin
  Result := ParseJSONValue(PByte(Data), Offset, Length(Data), Options);
end;

class function TJSONValue.ParseJSONValue(const Data: TArray<Byte>; const Offset: Integer;
  IsUTF8: Boolean): TJSONValue;
begin
  Result := ParseJSONValue(PByte(Data), Offset, Length(Data), MakeParseOptions(IsUTF8, False, False));
end;

class function TJSONValue.ParseJSONValue(const Data: TArray<Byte>; const Offset: Integer;
  const ALength: Integer; IsUTF8: Boolean): TJSONValue;
begin
  Result := ParseJSONValue(PByte(Data), Offset, ALength, MakeParseOptions(IsUTF8, False, False));
end;

class function TJSONValue.ParseJSONValue(const Data: string; UseBool, RaiseExc: Boolean): TJSONValue;
begin
  Result := ParseJSONValue(TEncoding.UTF8.GetBytes(Data), 0, MakeParseOptions(True, UseBool, RaiseExc));
end;

{$IFNDEF NEXTGEN}
class function TJSONValue.ParseJSONValue(const Data: UTF8String; UseBool, RaiseExc: Boolean): TJSONValue;
begin
  Result := ParseJSONValue(PByte(Data), 0, Length(Data), MakeParseOptions(True, UseBool, RaiseExc));
end;

class function TJSONValue.ParseJSONValueUTF8(const Data: TArray<Byte>; const Offset: Integer;
  const ACount: Integer): TJSONValue;
begin
  Result := ParseJSONValue(Data, Offset, ACount, MakeParseOptions(True, False, False));
end;

class function TJSONValue.ParseJSONValueUTF8(const Data: TArray<Byte>; const Offset: Integer): TJSONValue;
begin
  Result := ParseJSONValue(PByte(Data), Offset, Length(Data), MakeParseOptions(True, False, False));
end;
{$ENDIF !NEXTGEN}

class function TJSONValue.ParseJSONFragment(const Data: PByte; var Offset: Integer;
  const ALength: Integer; Options: TJSONParseOptions): TJSONValue;
var
  Parent: TJSONArray;
  Br: TJSONByteReader;
  FinOff: Integer;
  LExc: Boolean;
begin
  Parent := TJSONArray.Create;
  Result := nil;
  LExc := False;
  Br := TJSONByteReader.Create(Data, Offset, ALength, TJSONParseOption.IsUTF8 in Options);
  try
    try
      Br.SkipWhitespaces;
      FinOff := ParseValue(Br, Parent, TJSONParseOption.UseBool in Options);
    except
      on E: EJSONParseException do
        if TJSONParseOption.RaiseExc in Options then
          raise
        else
        begin
          LExc := True;
          FinOff := E.Offset;
        end;
    end;
    if not LExc and (FinOff > Offset) and (Parent.Count = 1) then
    begin
      Offset := FinOff;
      Result := Parent.Pop;
    end
    else if TJSONParseOption.RaiseExc in Options then
      if Parent.Count >= 1 then
        raise EJSONParseException.Create(FinOff, Br, Parent.Items[0])
      else
        raise EJSONParseException.Create(FinOff, Br, nil);
  finally
    Parent.Free;
    Br.Free;
  end;
end;

class function TJSONValue.ParseJSONFragment(const Data: TArray<Byte>; var Offset: Integer;
  Options: TJSONParseOptions): TJSONValue;
begin
  Result := ParseJSONFragment(PByte(Data), Offset, Length(Data), Options);
end;

class function TJSONValue.ParseJSONFragment(const Data: string; var Offset: Integer;
  Options: TJSONParseOptions): TJSONValue;
begin
  Result := ParseJSONFragment(TEncoding.UTF8.GetBytes(Data), Offset, Options +
    [TJSONParseOption.IsUTF8]);
end;

{ TJSONTrue }

constructor TJSONTrue.Create;
begin
  inherited Create(True);
end;

function TJSONTrue.Clone: TJSONAncestor;
begin
  Result := TJSONTrue.Create;
end;

{ TJSONString }

constructor TJSONString.Create;
begin
  inherited Create;
  FIsNull := True;
end;

constructor TJSONString.Create(const Value: string);
begin
  inherited Create;
  FValue := Value;
  FIsNull := False;
end;

procedure TJSONString.AddChar(const Ch: Char);
begin
  FValue := FValue + Ch;
  FIsNull := False;
end;

function TJSONString.IsNull: Boolean;
begin
  Result := FIsNull;
end;

function TJSONString.AsTValue(ATypeInfo: PTypeInfo; var AValue: TValue): Boolean;
begin
  case ATypeInfo^.Kind of
    tkInteger, tkInt64, tkFloat,
    tkString, tkLString, tkWString, tkUString,
{$IFNDEF NEXTGEN}
    tkChar,
{$ENDIF !NEXTGEN}
    tkWChar,
    tkEnumeration:
      Result := StrToTValue(FValue, ATypeInfo, AValue)
    else
      Result := inherited;
  end;
end;

function TJSONString.EstimatedByteSize: Integer;
begin
  if FIsNull then
    Result := 4
  else
    Result := 2 + 6 * System.Length(FValue);
end;

function TJSONString.ToBytes(const Data: TArray<Byte>; Offset: Integer): Integer;
var
  CurrentChar: Char;
  UnicodeValue: Integer;
begin
  if FIsNull then
  begin
    Data[IncrAfter(Offset)] := Ord('n');
    Data[IncrAfter(Offset)] := Ord('u');
    Data[IncrAfter(Offset)] := Ord('l');
    Data[IncrAfter(Offset)] := Ord('l');
  end
  else
  begin
    Data[IncrAfter(Offset)] := Ord('"');
    for CurrentChar in FValue do
    begin
      case CurrentChar of
        '"':
          begin
            Data[IncrAfter(Offset)] := Ord('\');
            Data[IncrAfter(Offset)] := Ord('"');
          end;
        '\':
          begin
            Data[IncrAfter(Offset)] := Ord('\');
            Data[IncrAfter(Offset)] := Ord('\');
          end;
        '/':
          begin
            Data[IncrAfter(Offset)] := Ord('\');
            Data[IncrAfter(Offset)] := Ord('/');
          end;
        #$8:
          begin
            Data[IncrAfter(Offset)] := Ord('\');
            Data[IncrAfter(Offset)] := Ord('b');
          end;
        #$c:
          begin
            Data[IncrAfter(Offset)] := Ord('\');
            Data[IncrAfter(Offset)] := Ord('f');
          end;
        #$a:
          begin
            Data[IncrAfter(Offset)] := Ord('\');
            Data[IncrAfter(Offset)] := Ord('n');
          end;
        #$d:
          begin
            Data[IncrAfter(Offset)] := Ord('\');
            Data[IncrAfter(Offset)] := Ord('r');
          end;
        #$9:
          begin
            Data[IncrAfter(Offset)] := Ord('\');
            Data[IncrAfter(Offset)] := Ord('t');
          end;
        else
          if (CurrentChar >= Char(32)) and (CurrentChar <= Char(127)) then
            Data[IncrAfter(Offset)] := Ord(CurrentChar)
          else
          begin
            Data[IncrAfter(Offset)] := Ord('\');
            Data[IncrAfter(Offset)] := Ord('u');
            UnicodeValue := Ord(CurrentChar);
            Data[IncrAfter(Offset)] := DecimalToHex((UnicodeValue and 61440) shr 12);
            Data[IncrAfter(Offset)] := DecimalToHex((UnicodeValue and 3840) shr 8);
            Data[IncrAfter(Offset)] := DecimalToHex((UnicodeValue and 240) shr 4);
            Data[IncrAfter(Offset)] := DecimalToHex((UnicodeValue and 15));
          end;
      end;
    end;
    Data[IncrAfter(Offset)] := Ord('"');
  end;
  Result := Offset;
end;

procedure TJSONString.ToChars(Builder: TStringBuilder; Options: TJSONAncestor.TJSONOutputOptions);

  procedure AppendWithSpecialChars(Builder: TStringBuilder; Options: TJSONAncestor.TJSONOutputOptions);
  var
    P, PEnd: PChar;
    UnicodeValue: Integer;
    Buff: array [0 .. 5] of Char;
  begin
    P := Pointer(FValue);
    PEnd := P + Length(FValue);
    while P < PEnd do
    begin
      case P^ of
      '"': Builder.Append('\"');
      '\': Builder.Append('\\');
      '/': Builder.Append('\/');
      #$8: Builder.Append('\b');
      #$9: Builder.Append('\t');
      #$a: Builder.Append('\n');
      #$c: Builder.Append('\f');
      #$d: Builder.Append('\r');
      #0 .. #7, #$b, #$e .. #31, #$0080 .. High(Char):
        begin
          UnicodeValue := Ord(P^);
          if (TJSONOutputOption.EncodeBelow32 in Options) and (UnicodeValue < 32) or
             (TJSONOutputOption.EncodeAbove127 in Options) and (UnicodeValue > 127) then
          begin
            Buff[0] := '\';
            Buff[1] := 'u';
            Buff[2] := Char(DecimalToHex((UnicodeValue and 61440) shr 12));
            Buff[3] := Char(DecimalToHex((UnicodeValue and 3840) shr 8));
            Buff[4] := Char(DecimalToHex((UnicodeValue and 240) shr 4));
            Buff[5] := Char(DecimalToHex((UnicodeValue and 15)));
            Builder.Append(@Buff[0], 0, High(Buff) + 1);
          end
          else
            Builder.Append(P^);
        end;
      else
        Builder.Append(P^);
      end;
      Inc(P);
    end;
  end;

{$WARNINGS OFF}
  function ContainsSpecialChars: Boolean;
  var
    P, PEnd: PChar;
  begin
    P := Pointer(FValue);
    PEnd := P + Length(FValue);
    while P < PEnd do
    begin
      if P^ in ['"', '\', '/', #$8, #$9, #$a, #$c, #$d] then
        Exit(True);
      Inc(P);
    end;
    Result := False;
  end;

  function ContainsSpecialCharsExt(Options: TJSONOutputOptions): Boolean;
  var
    P, PEnd: PChar;
  begin
    P := Pointer(FValue);
    PEnd := P + Length(FValue);
    while P < PEnd do
    begin
      case P^ of
      '"', '\', '/', #$8, #$9, #$a, #$c, #$d:
        Exit(True);
      #0 .. #7, #$b, #$e .. #31:
        if TJSONOutputOption.EncodeBelow32 in Options then
          Exit(True);
      #$0080 .. High(Char):
        if TJSONOutputOption.EncodeAbove127 in Options then
          Exit(True);
      end;
      Inc(P);
    end;
    Result := False;
  end;
{$WARNINGS ON}

var
  LSpecChars: Boolean;
begin
  if FIsNull then
    Builder.Append('null')
  else
  begin
    Builder.Append('"');
    if Options <> [] then
      LSpecChars := ContainsSpecialCharsExt(Options)
    else
      LSpecChars := ContainsSpecialChars;
    if LSpecChars then
      AppendWithSpecialChars(Builder, Options)
    else
      Builder.Append(FValue);
    Builder.Append('"');
  end;
end;

function TJSONString.Value: string;
begin
  Result := FValue;
end;

function TJSONString.Clone: TJSONAncestor;
begin
  if FIsNull then
    Result := TJSONString.Create
  else
    Result := TJSONString.Create(Value);
end;

function TJSONString.Equals(const Value: string): Boolean;
begin
  Result := FValue = Value;
end;

{ TJSONNumber }

constructor TJSONNumber.Create(const Value: Double);
begin
  inherited Create(FloatToJson(Value));
end;

constructor TJSONNumber.Create(const Value: string);
begin
  if Value.Trim <> '' then
    JsonToFloat(Value);
  inherited Create(Value);
end;

constructor TJSONNumber.Create(const Value: Int64);
begin
  inherited Create(IntToStr(Value));
end;

constructor TJSONNumber.Create(const Value: Integer);
begin
  inherited Create(IntToStr(Value));
end;

function TJSONNumber.EstimatedByteSize: Integer;
begin
  Result := System.Length(FValue);
end;

function TJSONNumber.ToBytes(const Data: TArray<Byte>; Offset: Integer): Integer;
var
  CurrentChar: Char;
begin
  for CurrentChar in FValue do
    Data[IncrAfter(Offset)] := Ord(CurrentChar);
  Result := Offset;
end;

procedure TJSONNumber.ToChars(Builder: TStringBuilder; Options: TJSONAncestor.TJSONOutputOptions);
begin
  Builder.Append(FValue);
end;

function TJSONNumber.Clone: TJSONAncestor;
begin
  if FIsNull then
    Result := TJSONNumber.Create
  else
    Result := TJSONNumber.Create(FValue);
end;

function TJSONNumber.GetAsDouble: Double;
begin
  Result := JsonToFloat(FValue);
end;

function TJSONNumber.GetAsInt: Integer;
begin
  Result := StrToInt(FValue);
end;

function TJSONNumber.GetAsInt64: Int64;
begin
  Result := StrToInt64(FValue);
end;

{ TJSONPair }

constructor TJSONPair.Create(const Str: TJSONString; const Value: TJSONValue);
begin
  inherited Create;
  FJsonString := Str;
  FJsonValue := Value;
end;

constructor TJSONPair.Create(const Str: string; const Value: TJSONValue);
begin
  Create(TJSONString.Create(Str), Value);
end;

constructor TJSONPair.Create(const Str: string; const Value: string);
begin
  Create(TJSONString.Create(Str), TJSONString.Create(Value));
end;

constructor TJSONPair.Create(const Str: string; const Value: Int64);
begin
  Create(TJSONString.Create(Str), TJSONNumber.Create(Value));
end;

constructor TJSONPair.Create(const Str: string; const Value: Integer);
begin
  Create(TJSONString.Create(Str), TJSONNumber.Create(Value));
end;

constructor TJSONPair.Create(const Str: string; const Value: Double);
begin
  Create(TJSONString.Create(Str), TJSONNumber.Create(Value));
end;

constructor TJSONPair.Create(const Str: string; const Value: Boolean);
begin
  Create(TJSONString.Create(Str), TJSONBool.Create(Value));
end;

constructor TJSONPair.Create;
begin
  Create(nil, nil);
end;

destructor TJSONPair.Destroy;
begin
  if (FJsonString <> nil) and FJsonString.Owned then
    FreeAndNil(FJsonString);
  if (FJsonValue <> nil) and FJsonValue.Owned then
    FreeAndNil(FJsonValue);
  inherited Destroy;
end;

procedure TJSONPair.AddDescendant(const Descendant: TJSONAncestor);
begin
  if FJsonString = nil then
    FJsonString := TJSONString(Descendant)
  else if FJsonValue = nil then
    FJsonValue := TJSONValue(Descendant)
  else
    inherited AddDescendant(Descendant);
end;

procedure TJSONPair.SetJsonString(const Descendant: TJSONString);
begin
  if Descendant <> nil then
  begin
    if (FJsonString <> nil) and FJsonString.Owned then
      FreeAndNil(FJsonString);
    FJsonString := Descendant;
  end;
end;

procedure TJSONPair.SetJsonValue(const Val: TJSONValue);
begin
  if Val <> nil then
  begin
    if (FJsonValue <> nil) and FJsonValue.Owned then
      FreeAndNil(FJsonValue);
    FJsonValue := Val;
  end;
end;

function TJSONPair.EstimatedByteSize: Integer;
begin
  Result := 1 + FJsonString.EstimatedByteSize + FJsonValue.EstimatedByteSize;
end;

function TJSONPair.ToBytes(const Data: TArray<Byte>; Offset: Integer): Integer;
begin
  Offset := FJsonString.ToBytes(Data, Offset);
  Data[IncrAfter(Offset)] := Ord(':');
  Result := FJsonValue.ToBytes(Data, Offset);
end;

procedure TJSONPair.ToChars(Builder: TStringBuilder; Options: TJSONAncestor.TJSONOutputOptions);
begin
  if (FJsonString <> nil) and (FJsonValue <> nil) then
  begin
    FJsonString.ToChars(Builder, Options);
    Builder.Append(':');
    FJsonValue.ToChars(Builder, Options);
  end;
end;

function TJSONPair.Clone: TJSONAncestor;
begin
  Result := TJSONPair.Create(TJSONString(FJsonString.Clone), TJSONValue(FJsonValue.Clone));
end;

function TJSONPair.HasName(const Name: string): Boolean;
begin
  Result := FJsonString.Equals(Name);
end;

{ TJSONObject }

constructor TJSONObject.Create;
begin
  inherited Create;
  FMembers := TList<TJSONPair>.Create;
end;

constructor TJSONObject.Create(const Pair: TJSONPair);
begin
  Create;
  if Pair <> nil then
    FMembers.Add(Pair);
end;

procedure TJSONObject.SetPairs(const AList: TList<TJSONPair>);
begin
  FMembers.Free;
  FMembers := AList;
end;

function TJSONObject.GetCount: Integer;
begin
  Result := FMembers.Count;
end;

function TJSONObject.GetPair(const Index: Integer): TJSONPair;
begin
  Result := FMembers[Index];
end;

function TJSONObject.GetPairByName(const PairName: string): TJSONPair;
var
  Candidate: TJSONPair;
  I: Integer;
begin
  for i := 0 to Count - 1 do
  begin
    Candidate := FMembers.List[I];
    if Candidate.HasName(PairName) then
      Exit(Candidate);
  end;
  Result := nil;
end;

function TJSONObject.Size: Integer;
begin
  Result := GetCount;
end;

function TJSONObject.Get(const Index: Integer): TJSONPair;
begin
  Result := Pairs[Index];
end;

function TJSONObject.Get(const Name: string): TJSONPair;
begin
  Result := GetPairByName(Name);
end;

function TJSONObject.GetValue(const Name: string): TJSONValue;
var
  Candidate: TJSONPair;
  I: Integer;
begin
  for i := 0 to Count - 1 do
  begin
    Candidate := FMembers.List[I];
    if Candidate.HasName(Name) then
      Exit(Candidate.JsonValue);
  end;
  Result := nil;
end;

destructor TJSONObject.Destroy;
var
  Member: TJSONAncestor;
  I: Integer;
begin
  for i := 0 to FMembers.Count - 1 do
  begin
    Member := FMembers.List[I];
    if Member.Owned then
      Member.Free;
  end;
  FreeAndNil(FMembers);
  inherited Destroy;
end;

function TJSONObject.AddPair(const Pair: TJSONPair): TJSONObject;
begin
  if Pair <> nil then
    AddDescendant(Pair);
  Result := Self;
end;

function TJSONObject.AddPair(const Str: TJSONString; const Val: TJSONValue): TJSONObject;
begin
  if (Str <> nil) and (Val <> nil) then
    AddPair(TJSONPair.Create(Str, Val));
  Result := Self;
end;

function TJSONObject.AddPair(const Str: string; const Val: TJSONValue): TJSONObject;
begin
  if not Str.IsEmpty and (Val <> nil) then
    AddPair(TJSONPair.Create(Str, Val));
  Result := Self;
end;

function TJSONObject.AddPair(const Str: string; const Val: string): TJSONObject;
begin
  if not Str.IsEmpty then
    AddPair(TJSONPair.Create(Str, Val));
  Result := Self;
end;

function TJSONObject.AddPair(const Str: string; const Val: Int64): TJSONObject;
begin
  if not Str.IsEmpty then
    AddPair(TJSONPair.Create(Str, Val));
  Result := Self;
end;

function TJSONObject.AddPair(const Str: string; const Val: Integer): TJSONObject;
begin
  if not Str.IsEmpty then
    AddPair(TJSONPair.Create(Str, Val));
  Result := Self;
end;

function TJSONObject.AddPair(const Str: string; const Val: Double): TJSONObject;
begin
  if not Str.IsEmpty then
    AddPair(TJSONPair.Create(Str, Val));
  Result := Self;
end;

function TJSONObject.AddPair(const Str: string; const Val: Boolean): TJSONObject;
begin
  if not Str.IsEmpty then
    AddPair(TJSONPair.Create(Str, Val));
  Result := Self;
end;

function TJSONObject.RemovePair(const PairName: string): TJSONPair;
var
  Candidate: TJSONPair;
  I: Integer;
begin
  for I := 0 to Count - 1 do
  begin
    Candidate := TJSONPair(FMembers.List[I]);
    if (Candidate.JsonString.Value = PairName) then
    begin
      FMembers.Remove(Candidate);
      Exit(Candidate);
    end;
  end;
  Result := nil;
end;

procedure TJSONObject.AddDescendant(const Descendant: TJSONAncestor);
begin
  FMembers.Add(TJSONPair(Descendant));
end;

function TJSONObject.EstimatedByteSize: Integer;
var
  I: Integer;
begin
  Result := 1;
  for i := 0 to FMembers.Count - 1 do
    Inc(Result, FMembers.List[I].EstimatedByteSize + 1);
  if Result = 1 then
    Result := 2;
end;

function TJSONObject.ToBytes(const Data: TArray<Byte>; Offset: Integer): Integer;
var
  Size: Integer;
  I: Integer;
begin
  Size := FMembers.Count;
  Data[IncrAfter(Offset)] := Ord('{');
  if Size > 0 then
    Offset := FMembers.List[0].ToBytes(Data, Offset);
  for i := 1 to Size - 1 do
  begin
    Data[IncrAfter(Offset)] := Ord(',');
    Offset := FMembers.List[I].ToBytes(Data, Offset);
  end;
  Data[IncrAfter(Offset)] := Ord('}');
  Result := Offset;
end;

procedure TJSONObject.ToChars(Builder: TStringBuilder; Options: TJSONAncestor.TJSONOutputOptions);
var
  Size: Integer;
  I: Integer;
begin
  Size := FMembers.Count;
  Builder.Append('{');
  if Size > 0 then
    FMembers.List[0].ToChars(Builder, Options);
  for I := 1 to Size - 1 do
  begin
    Builder.Append(',');
    FMembers.List[I].ToChars(Builder, Options);
  end;
  Builder.Append('}');
end;

procedure TJSONObject.Format(Builder: TStringBuilder; const ParentIdent, Ident: string);
var
  LIdent: string;
  i: Integer;
begin
  Builder.Append('{').Append(sLineBreak);
  LIdent := ParentIdent + Ident;
  for i := 0 to Count - 1 do
  begin
    Builder.Append(LIdent);
    Pairs[i].JsonString.Format(Builder, '', Ident);
    Builder.Append(': ');
    Pairs[i].JsonValue.Format(Builder, LIdent, Ident);
    if i < Count - 1 then
      Builder.Append(',');
    Builder.Append(sLineBreak);
  end;
  Builder.Append(ParentIdent).Append('}');
end;

function TJSONObject.Clone: TJSONAncestor;
var
  Data: TJSONObject;
  I: Integer;
begin
  Data := TJSONObject.Create;
  for I := 0 to FMembers.Count - 1 do
    Data.AddPair(TJSONPair(Pairs[I].Clone));
  Result := Data;
end;

function TJSONObject.Parse(const Data: TArray<Byte>; const Pos: Integer; UseBool: Boolean = False): Integer;
begin
  Result := Parse(Data, Pos, Length(Data), UseBool);
end;

function TJSONObject.Parse(const Data: TArray<Byte>; const Pos: Integer; const Count: Integer; UseBool: Boolean = False): Integer;
var
  Br: TJSONByteReader;
begin
  if (Data = nil) or (Pos < 0) or (Pos >= Count) then
    Exit(-1);
  Br := TJSONByteReader.Create(PByte(Data), Pos, Count, True);
  try
    Result := Parse(Br, UseBool);
  finally
    Br.Free;
  end;
end;

function TJSONObject.Parse(const Br: TJSONByteReader; UseBool: Boolean): Integer;
var
  SepPos: Integer;
  PairExpected: Boolean;
begin
  Br.SkipWhitespaces;
  if Br.IsEof then
    Exit(-Br.Offset);
  if Br.PeekByte <> Ord('{') then
    Exit(-Br.Offset);
  Br.SkipByte;
  Br.SkipWhitespaces;
  if Br.IsEof then
    Exit(-Br.Offset);
  PairExpected := False;
  while PairExpected or (Br.PeekByte <> Ord('}')) do
  begin
    SepPos := ParsePair(Br, Self, UseBool);
    if SepPos <= 0 then
      Exit(SepPos);
    Br.SkipWhitespaces;
    if Br.IsEof then
      Exit(-Br.Offset);
    PairExpected := False;
    if Br.PeekByte = Ord(',') then
    begin
      Br.SkipByte;
      Br.SkipWhitespaces;
      PairExpected := True;
      if Br.PeekByte = Ord('}') then
        Exit(-Br.Offset);
    end
    else if Br.PeekByte <> Ord('}') then
      Exit(-Br.Offset);
  end;
  Br.SkipByte;
  Br.SkipWhitespaces;
  Result := Br.Offset;
end;

{ TJSONObject.TEnumerator }

constructor TJSONObject.TEnumerator.Create(const AObject: TJSONObject);
begin
  inherited Create;
  FIndex := -1;
  FObject := AObject;
end;

function TJSONObject.TEnumerator.GetCurrent: TJSONPair;
begin
  Result := FObject.FMembers.List[FIndex];
end;

function TJSONObject.TEnumerator.MoveNext: Boolean;
begin
  Inc(FIndex);
  Result := FIndex < FObject.Count;
end;

function TJSONObject.GetEnumerator: TEnumerator;
begin
  Result := TEnumerator.Create(Self);
end;

{ TJSONNull }

function TJSONNull.AsTValue(ATypeInfo: PTypeInfo; var AValue: TValue): Boolean;
begin
  Result := True;
  case ATypeInfo^.Kind of
    tkString, tkLString, tkUString, TkWString:
      AValue := '';
    else
      Result := inherited;
  end;
end;

function TJSONNull.IsNull: Boolean;
begin
  Result := True;
end;

function TJSONNull.EstimatedByteSize: Integer;
begin
  Result := 4;
end;

function TJSONNull.ToBytes(const Data: TArray<Byte>; Offset: Integer): Integer;
begin
  Data[IncrAfter(Offset)] := Ord('n');
  Data[IncrAfter(Offset)] := Ord('u');
  Data[IncrAfter(Offset)] := Ord('l');
  Data[IncrAfter(Offset)] := Ord('l');
  Result := Offset;
end;

procedure TJSONNull.ToChars(Builder: TStringBuilder; Options: TJSONAncestor.TJSONOutputOptions);
begin
  Builder.Append(NULLString);
end;

function TJSONNull.Value: string;
begin
  Result := NULLString;
end;

function TJSONNull.Clone: TJSONAncestor;
begin
  Result := TJSONNull.Create;
end;

{ TJSONFalse }

constructor TJSONFalse.Create;
begin
  inherited Create(False);
end;

function TJSONFalse.Clone: TJSONAncestor;
begin
  Result := TJSONFalse.Create;
end;

{ TJSONArray }

constructor TJSONArray.Create;
begin
  inherited Create;
  FElements := TList<TJSONValue>.Create;
end;

procedure TJSONArray.AddElement(const Element: TJSONValue);
begin
  AddDescendant(Element);
end;

constructor TJSONArray.Create(const FirstElem: TJSONValue);
begin
  Create;
  AddElement(FirstElem);
end;

constructor TJSONArray.Create(const FirstElem: TJSONValue; const SecondElem: TJSONValue);
begin
  Create;
  AddElement(FirstElem);
  AddElement(SecondElem);
end;

constructor TJSONArray.Create(const FirstElem: string; const SecondElem: string);
begin
  Create;
  AddElement(TJSONString.Create(FirstElem));
  AddElement(TJSONString.Create(SecondElem));
end;

destructor TJSONArray.Destroy;
var
  Element: TJSONAncestor;
  I: Integer;
begin
  for I := 0 to FElements.Count - 1 do
  begin
    Element := FElements[I];
    if Element.Owned then
      Element.Free;
  end;
  FreeAndNil(FElements);
  inherited Destroy;
end;

procedure TJSONArray.SetElements(const AList: TList<TJSONValue>);
begin
  FElements.Free;
  FElements := AList;
end;

function TJSONArray.GetCount: Integer;
begin
  Result := FElements.Count;
end;

function TJSONArray.GetValue(const Index: Integer): TJSONValue;
begin
  Result := FElements[Index];
end;

function TJSONArray.GetValueA(const Index: Integer): TJSONValue;
begin
  Result := GetValue(Index);
end;

function TJSONArray.Size: Integer;
begin
  Result := GetCount;
end;

function TJSONArray.Get(const Index: Integer): TJSONValue;
begin
  Result := Items[Index];
end;

procedure TJSONArray.AddDescendant(const Descendant: TJSONAncestor);
begin
  FElements.Add(TJSONValue(Descendant));
end;

function TJSONArray.Pop: TJSONValue;
begin
  Result := Remove(0);
end;

function TJSONArray.Remove(Index: Integer): TJSONValue;
begin
  Result := FElements.ExtractAt(Index);
end;

function TJSONArray.Add(const Element: string): TJSONArray;
begin
  AddElement(TJSONString.Create(Element));
  Result := Self;
end;

function TJSONArray.Add(const Element: Integer): TJSONArray;
begin
  AddElement(TJSONNumber.Create(Element));
  Result := Self;
end;

function TJSONArray.Add(const Element: Double): TJSONArray;
begin
  AddElement(TJSONNumber.Create(Element));
  Result := Self;
end;

function TJSONArray.Add(const Element: Boolean): TJSONArray;
begin
  if Element then
    AddElement(TJSONTrue.Create)
  else
    AddElement(TJSONFalse.Create);
  Result := Self;
end;

function TJSONArray.Add(const Element: TJSONObject): TJSONArray;
begin
  if Element <> nil then
    AddElement(Element)
  else
    AddElement(TJSONNull.Create);
  Result := Self;
end;

function TJSONArray.Add(const Element: TJSONArray): TJSONArray;
begin
  AddElement(Element);
  Result := Self;
end;

function TJSONArray.EstimatedByteSize: Integer;
var
  I: Integer;
begin
  Result := 1;
  for I := 0 to FElements.Count - 1 do
    Inc(Result, FElements[I].EstimatedByteSize + 1);
  if Result = 1 then
    Result := 2;
end;

function TJSONArray.ToBytes(const Data: TArray<Byte>; Offset: Integer): Integer;
var
  Size: Integer;
  I: Integer;
begin
  Size := FElements.Count;
  Data[IncrAfter(Offset)] := Ord('[');
  if Size > 0 then
    Offset := FElements[0].ToBytes(Data, Offset);
  for I := 1 to Size - 1 do
  begin
    Data[IncrAfter(Offset)] := Ord(',');
    Offset := FElements[I].ToBytes(Data, Offset);
  end;
  Data[IncrAfter(Offset)] := Ord(']');
  Result := Offset;
end;

procedure TJSONArray.ToChars(Builder: TStringBuilder; Options: TJSONAncestor.TJSONOutputOptions);
var
  Size: Integer;
  I: Integer;
begin
  Size := FElements.Count;
  Builder.Append('[');
  if Size > 0 then
    FElements[0].ToChars(Builder, Options);
  for I := 1 to Size - 1 do
  begin
    Builder.Append(',');
    FElements[i].ToChars(Builder, Options);
  end;
  Builder.Append(']');
end;

procedure TJSONArray.Format(Builder: TStringBuilder; const ParentIdent, Ident: string);
var
  LIdent: string;
  i: Integer;
begin
  Builder.Append('[').Append(sLineBreak);
  LIdent := ParentIdent + Ident;
  for i := 0 to Count - 1 do
  begin
    Builder.Append(LIdent);
    Items[i].Format(Builder, LIdent, Ident);
    if i < Count - 1 then
      Builder.Append(',');
    Builder.Append(sLineBreak);
  end;
  Builder.Append(ParentIdent).Append(']');
end;

function TJSONArray.Clone: TJSONAncestor;
var
  Data: TJSONArray;
  I: Integer;
begin
  Data := TJSONArray.Create;
  for I := 0 to Count - 1 do
    Data.AddDescendant(Items[I].Clone);
  Result := Data;
end;

function TJSONArray.AsTValue(ATypeInfo: PTypeInfo; var AValue: TValue): Boolean;
var
  LSet, I: Integer;
  LpEnumInfo: PPTypeInfo;
  LPtr, LArr: Pointer;
  LDims: array[0..0] of NativeInt;
  LVal: TValue;
  LpItem: PByte;
  LItemInfo: PTypeInfo;
  LItemSize: Integer;
begin
  Result := True;
  LPtr := nil;
  LArr := nil;
  try
    case ATypeInfo^.Kind of
    tkSet:
      begin
        LSet := 0;
        LpEnumInfo := GetTypeData(ATypeInfo)^.CompType;
        if LpEnumInfo = nil then
          LItemInfo := System.TypeInfo(Integer)
        else
          LItemInfo := LpEnumInfo^;
        for I := 0 to Count - 1 do
        begin
          if not Items[I].AsTValue(LItemInfo, LVal) then
            Exit(False);
          Include(TIntegerSet(LSet), LVal.AsOrdinal);
        end;
        LPtr := @LSet;
      end;
    tkDynArray:
      begin
        LDims[0] := Count;
        DynArraySetLength(LArr, ATypeInfo, 1, @LDims[0]);
        LItemInfo := ATypeInfo^.TypeData^.elType2^;
        LItemSize := ATypeInfo^.TypeData^.elSize;
        LpItem := LArr;
        for I := 0 to Count - 1 do
        begin
          if not Items[I].AsTValue(LItemInfo, LVal) then
            Exit(False);
          LVal.ExtractRawData(LpItem);
          LpItem := LpItem + LItemSize;
        end;
        LPtr := @LArr;
      end;
    tkArray:
      begin
        if ATypeInfo^.TypeData^.ArrayData.ElCount <> Count then
          Exit(False);
        GetMem(LArr, ATypeInfo^.TypeData^.ArrayData.Size);
        if IsManaged(ATypeInfo) then
          InitializeArray(LArr, ATypeInfo, Count);
        LItemInfo := ATypeInfo^.TypeData^.ArrayData.ElType^;
        LItemSize := ATypeInfo^.TypeData^.ArrayData.Size div ATypeInfo^.TypeData^.ArrayData.ElCount;
        LpItem := LArr;
        for I := 0 to Count - 1 do
        begin
          if not Items[I].AsTValue(LItemInfo, LVal) then
            Exit(False);
          LVal.ExtractRawData(LpItem);
          LpItem := LpItem + LItemSize;
        end;
        LPtr := LArr;
      end;
    else
      Result := inherited;
    end;
    if Result and (LPtr <> nil) then
      TValue.MakeWithoutCopy(LPtr, ATypeInfo, AValue, False);
  finally
    if LArr <> nil then
      case ATypeInfo^.Kind of
      tkDynArray:
        if LPtr = nil then
          DynArrayClear(LArr, ATypeInfo);
      tkArray:
        begin
          if (LPtr = nil) and IsManaged(ATypeInfo) then
            FinalizeArray(LArr, ATypeInfo, Count);
          FreeMem(LArr);
        end;
      end;
  end;
end;

{ TJSONArray.TEnumerator }

constructor TJSONArray.TEnumerator.Create(const AArray: TJSONArray);
begin
  inherited Create;
  FIndex := -1;
  FArray := AArray;
end;

function TJSONArray.TEnumerator.GetCurrent: TJSONValue;
begin
  Result := FArray.FElements.List[FIndex];
end;

function TJSONArray.TEnumerator.MoveNext: Boolean;
begin
  Inc(FIndex);
  Result := FIndex < FArray.Count;
end;

function TJSONArray.GetEnumerator: TEnumerator;
begin
  Result := TEnumerator.Create(Self);
end;

{ TJSONBool }

function TJSONBool.AsTValue(ATypeInfo: PTypeInfo; var AValue: TValue): Boolean;
begin
  Result := True;
  case ATypeInfo^.Kind of
    tkEnumeration:
      Result := StrToTValue(Value, ATypeInfo, AValue);
    tkInteger, tkInt64, tkFloat:
      if FValue then
        AValue := 1
      else
        AValue := 0;
    tkString, tkLString, tkWString, tkUString:
      AValue := Value;
    else
      Result := inherited;
  end;
end;

function TJSONBool.Clone: TJSONAncestor;
begin
  Result := TJSONBool.Create(FValue);
end;

constructor TJSONBool.Create(AValue: Boolean);
begin
  inherited Create;
  FValue := AValue;
end;

function TJSONBool.EstimatedByteSize: Integer;
begin
  if FValue then
    Result := Length(TrueBytes)
  else
    Result := Length(FalseBytes);
end;

function TJSONBool.ToBytes(const Data: TArray<Byte>; Offset: Integer): Integer;
begin
  if FValue then
  begin
    Move(TrueBytes[0], Data[Offset], Length(TrueBytes));
    Result := Offset + Length(TrueBytes);
  end
  else
  begin
    Move(FalseBytes[0], Data[Offset], Length(FalseBytes));
    Result := Offset + Length(FalseBytes);
  end;
end;

procedure TJSONBool.ToChars(Builder: TStringBuilder; Options: TJSONAncestor.TJSONOutputOptions);
begin
  Builder.Append(Value);
end;

function TJSONBool.Value: string;
begin
  if FValue then
    Result := TrueString
  else
    Result := FalseString;
end;

// Moved here after all referenced inline methods
function TJSONValue.FindValue(const APath: string): TJSONValue;
var
  LParser: TJSONPathParser;
  LCurrentValue: TJSONValue;
begin
  if (Self = nil) or (APath = '') then
    Exit(Self);
  Result := nil;
  LParser := TJSONPathParser.Create(APath);
  LCurrentValue := Self;
  while not LParser.IsEof do
  begin
    case LParser.NextToken of
      TJSONPathParser.TToken.Name:
        if LCurrentValue.ClassType = TJSONObject then
        begin
          LCurrentValue := TJSONObject(LCurrentValue).Values[LParser.TokenName];
          if LCurrentValue = nil then
            Exit;
        end
        else
          Exit;
      TJSONPathParser.TToken.ArrayIndex:
        if LCurrentValue.ClassType = TJSONArray then
          if LParser.TokenArrayIndex < TJSONArray(LCurrentValue).Count then
            LCurrentValue := TJSONArray(LCurrentValue).Items[LParser.TokenArrayIndex]
          else
            Exit
        else
          Exit;
      TJSONPathParser.TToken.Error,
      TJSONPathParser.TToken.Undefined:
        Exit;
      TJSONPathParser.TToken.Eof:
        ;
    end;
  end;
  Result := LCurrentValue;
end;

initialization
  JSONFormatSettings := TFormatSettings.Invariant;

end.

