{*******************************************************}
{                                                       }
{            Delphi Visual Component Library            }
{                                                       }
{ Copyright(c) 1995-2022 Embarcadero Technologies, Inc. }
{              All rights reserved                      }
{                                                       }
{*******************************************************}

unit ToolsAPI;

{$WARN SYMBOL_DEPRECATED OFF}

interface

{ !!! Please keep this unit's uses clause clean of *any* private IDE             !!! }
{ !!! units.  Before making modifications to this unit, please see senior IDE R&D engineer !!! }
{$IFDEF MSWINDOWS}
uses Winapi.Windows, System.SysUtils, System.Classes, Winapi.ActiveX, System.TypInfo, DockForm, DesignIntf, Vcl.Menus,
  Vcl.ActnList, Vcl.Graphics, Vcl.ImgList, Vcl.Forms, Vcl.Controls, Vcl.ComCtrls, Vcl.Themes, Xml.XMLIntf, System.IniFiles,
  System.Types, PersonalityConst;
{$ENDIF}
{$IFDEF LINUX}
uses Types, SysUtils, Classes, TypInfo, DockForm, DesignIntf, Menus, ActnList,
  Graphics, ImgList, Forms, Controls, ComCtrls, PersonalityConst;
{$NOINCLUDE Menus}
{$NOINCLUDE ActnList}
{$NOINCLUDE Graphics}
{$NOINCLUDE ImgList}
{$NOINCLUDE Forms}
{$NOINCLUDE ComCtrls}
{$ENDIF}

(*$HPPEMIT 'DEFINE_GUID(IID_IBorlandIDEServices,0xC9E8E577,0xB5D8,0x43F3,0xBC,0x84,0x6A,0x73,0x4A,0x01,0x57,0x32);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IBorlandIDEServices70,0x7FD1CE92,0xE053,0x11D1,0xAB,0x0B,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAAddInOptions,0x4B348F3E,0x6D01,0x4D88,0xA5,0x65,0x4C,0x8C,0x0E,0xBF,0x43,0x35);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAComponent,0x34B2E2D1,0xE36F,0x11D1,0xAB,0x0E,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTACustomDockableForm,0xF8EF756F,0x4E95,0x4F1F,0xB2,0x29,0xA3,0xDE,0xF7,0xBC,0xC3,0x50);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTACustomDrawCodeInsightViewer,0x32CA7B43,0x9AFC,0x49CF,0xAB,0xC9,0x7E,0xCD,0x77,0x24,0x88,0xD9);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTACustomDrawMessage,0x589BBDA2,0xF995,0x11D1,0xAB,0x27,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTACustomEditorSubView,0x655AA26C,0x5898,0x4DB5,0xB2,0x1F,0x4F,0x55,0xE9,0xB2,0xB4,0x07);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTACustomEditorSubView190,0x356C05A7,0x78C0,0x477F,0xB5,0x9A,0x01,0x7D,0x1A,0xC7,0x4B,0x00);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTACustomEditorView,0xE9465FAF,0xB671,0x4098,0x9E,0xD9,0xAE,0x4C,0x05,0xC5,0x45,0x4A);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTACustomEditorView150,0x08A5E5C0,0xE3D5,0x44E0,0xBE,0x0F,0x4A,0xDC,0x93,0xC3,0x69,0xA4);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTACustomEditorView280,0x76F27D95,0xE7F3,0x4A01,0x9C,0x2C,0xFB,0x27,0x89,0xA4,0xFE,0xB7);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTACustomEditorViewState,0xAA6AA3D4,0x1A63,0x4A93,0x89,0x64,0x45,0x04,0x84,0xF4,0xB4,0xD8);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTACustomEditorViewStatusPanel,0x39B8ECEB,0x3048,0x4733,0xBF,0x3D,0xC7,0x65,0x40,0xD8,0x7A,0xE2);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTACustomizeToolbarNotifier,0x34F2C852,0x0B8C,0x4352,0x90,0x8D,0x94,0x03,0x8E,0x79,0xCC,0x0D);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTACustomizeToolbarNotifier190,0xE288D5FE,0xCC41,0x4D2F,0xAD,0xE6,0x1D,0xDC,0x2D,0x5C,0xCF,0xFA);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAEditServicesNotifier,0xF954AA40,0x23E7,0x412C,0xBD,0x59,0xCC,0x34,0x28,0xDE,0x29,0x39);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAEditViewNotifier,0x8990AA6E,0xC1C5,0x4CF9,0x80,0x51,0xC5,0xB4,0xF6,0xEE,0x11,0xD8);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAEditWindow,0x8CC6430B,0xE721,0x11D2,0xA8,0xCC,0x00,0xC0,0x4F,0xA3,0x2F,0x53);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAEditorServices,0x3CC6849A,0x6C72,0x49F8,0xBF,0x63,0xE9,0x50,0x83,0x78,0x91,0x41);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAEditorViewServices,0x29F85F0F,0xE210,0x4577,0x9F,0x5D,0x2B,0x6E,0xD7,0xC0,0x53,0x98);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAEnvironmentOptionsServices,0x88EAA6AC,0xB8C0,0x42F7,0x9C,0x00,0xE5,0xD3,0x1B,0x81,0x59,0x98);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAFormEditor,0x56931EB9,0x329A,0xD411,0x87,0xC6,0x9B,0x27,0x30,0x41,0x22,0x00);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAIDEInsightItem,0x539EE5EB,0x7A17,0x4756,0x9E,0x98,0x09,0xEE,0x71,0x55,0x1A,0xE0);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAIDEInsightService,0x1780CF98,0x614F,0x4BB9,0xA8,0x56,0x3D,0x1D,0x2E,0xA0,0x5A,0x57);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAIDEInsightService180,0x6B0977D7,0xDE13,0x4715,0xAB,0x0B,0x37,0x91,0x12,0x6C,0xAB,0xE9);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAIDEThemingServicesNotifier,0x4CBFAA40,0x89E6,0x412C,0xB6,0x67,0x90,0x34,0x66,0x6E,0x29,0x31);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAMessageNotifier,0x0AE796BE,0xB5D7,0x4830,0x91,0x59,0xDE,0xFF,0x82,0xAC,0x07,0x6B);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAPersonalityDevelopers,0x765E768E,0xCF71,0x427C,0xAC,0x9C,0xCF,0x4B,0xFE,0xBC,0xFE,0xD5);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAProcess,0x089CAD6D,0xF1C4,0x4D33,0xA3,0x88,0xA0,0xF9,0x90,0x43,0xF4,0xDE);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAProcess150,0xD65533D2,0x52B1,0x460F,0xAB,0xF1,0x48,0xCA,0x41,0x55,0x24,0xF5);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAProjectMenuCreatorNotifier,0x8209348C,0x2114,0x439C,0xAD,0x4E,0xBF,0xB7,0x04,0x9A,0x63,0x6A);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAReadToolbarNotifier,0x748F68BB,0x599C,0x4BE4,0x83,0xA3,0xEE,0xEB,0xD9,0x20,0xB6,0xEE);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAServices,0x8209041F,0xF37F,0x4570,0x88,0xB8,0x6C,0x31,0x0F,0xFF,0xF8,0x1A);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAServices120,0x26B056B7,0xFB49,0x41BC,0xA8,0xC2,0x15,0x1D,0xE1,0xEB,0xF4,0x65);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAServices40,0x3C7F3267,0xF0BF,0x11D1,0xAB,0x1E,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAServices70,0xC17B3DF1,0xDFE5,0x11D2,0xA8,0xC7,0x00,0xC0,0x4F,0xA3,0x2F,0x53);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAServices90,0x89160C3A,0x8EF4,0x4D2E,0x8F,0xD5,0xD8,0x49,0x2F,0x61,0xDB,0x3E);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAStrings,0xFDAFB316,0x82E7,0x47B3,0xA2,0x82,0xD7,0x60,0x5A,0xDF,0x2A,0xAF);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAThread,0x381708B8,0xA0FA,0x44DC,0xB1,0x73,0x33,0x28,0xAE,0xFA,0x04,0x32);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAToDoItem,0x094003D8,0xE7AA,0x11D2,0xAA,0x99,0x00,0xC0,0x4F,0xA3,0x5C,0xE8);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAToolbarStreamNotifier,0xA2D9F2F7,0x815E,0x4E5B,0xBD,0x83,0x2B,0xD4,0xA5,0x7A,0x45,0xE1);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAToolbarStreamNotifier190,0x9170ADE2,0x7D04,0x4B6C,0xAF,0x74,0x9F,0x56,0xFB,0x1A,0xA2,0x9B);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_INTAWriteToolbarNotifier,0x89B84491,0xA034,0x4097,0xAD,0x64,0x4B,0xAA,0x52,0x11,0xBF,0x2E);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAAboutBoxServices,0x62A2F7FD,0x16F1,0x45B9,0x94,0x17,0xA2,0xD2,0x93,0xD0,0x7A,0x22);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAAboutBoxServices120,0x1DD6FC0B,0x32F9,0x4161,0xA8,0x1A,0x9B,0xE2,0x14,0xF9,0xF3,0x0D);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAActionServices,0xF17A7BC9,0xE07D,0x11D1,0xAB,0x0B,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAAdditionalFilesModuleCreator,0xBACD1450,0x1AC5,0x11D4,0xA4,0x55,0x00,0xC0,0x4F,0x6B,0xB8,0x53);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAAdditionalModuleFiles,0x2D73A12F,0x6FB3,0x11D4,0xA4,0xB8,0x00,0xC0,0x4F,0x6B,0xB8,0x53);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAAddressBreakpoint,0x09063878,0xE43A,0x11D1,0xAB,0x0F,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAAlignable,0x346E7BA3,0xD47E,0x11D3,0xBA,0x96,0x00,0x80,0xC7,0x8A,0xDC,0xDB);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAAlignableState,0x481A90D6,0x95AD,0x4AC8,0x8C,0x53,0xE8,0x62,0xDF,0x16,0x4B,0xD7);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAAsyncCodeInsightManager,0x2BB78A32,0xBF68,0x4223,0x99,0x93,0x50,0xA0,0x68,0x82,0x04,0xE4);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAAsyncCodeInsightManager270,0x15EA6CCC,0x7AF8,0x40EC,0xB9,0x57,0x87,0xDC,0x90,0x1F,0x60,0xAF);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTABaseCustomDifferenceViewer,0x8302DA7D,0x1FDA,0x4043,0x95,0xC7,0xF2,0xC1,0xC6,0xBC,0xE1,0x27);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTABreakpoint,0x8950E1C9,0xC32F,0x4132,0x87,0xDD,0x62,0x78,0x6A,0x3F,0x99,0x04);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTABreakpoint120,0x614D8D87,0xF3E2,0x46B7,0x80,0x33,0x4E,0x8B,0x37,0xE6,0x97,0xBB);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTABreakpoint40,0x34B2E2D4,0xE36F,0x11D1,0xAB,0x0E,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTABreakpoint50,0x569EFCFB,0xC69B,0x11D2,0xAC,0x67,0x00,0xC0,0x4F,0xB1,0x73,0xDC);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTABreakpoint80,0x446F637B,0x3EBD,0x4E33,0xB0,0x11,0x71,0x4C,0xE9,0x64,0x7B,0xB9);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTABreakpointNotifier,0x34B2E2D5,0xE36F,0x11D1,0xAB,0x0E,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTABufferOptions,0x38E7F12C,0x7682,0x40E9,0xB1,0x3B,0x9C,0x2E,0x36,0xBD,0xBA,0xFC);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTABufferOptions60,0x8C748540,0xC6C1,0x11D2,0x81,0x39,0x00,0x60,0x97,0x92,0xF1,0x34);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTABufferOptions70,0xF8F13ACE,0x1124,0x408F,0x93,0x4F,0x8E,0x92,0xDA,0x13,0x54,0x24);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTABuildConfiguration,0x986E6AB2,0x3C11,0x43E2,0x93,0x41,0xAC,0x0A,0xEF,0x6A,0x99,0xD1);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTABuildConfiguration140,0x92A52A72,0xB0D2,0x4898,0x8A,0x20,0x29,0x81,0x32,0xF7,0x4C,0x16);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTABuildConfiguration150,0x803E66A4,0x0B49,0x4A9D,0xB2,0x36,0x55,0xBF,0xF2,0x61,0x0B,0x9A);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTABuildEvent,0xD00E9978,0x43EE,0x442F,0x92,0x96,0xA1,0x75,0x03,0x7D,0xF5,0x81);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTABuildEventProvider,0x803BC8A0,0xE6B5,0x47FA,0x80,0x7C,0x68,0x5E,0x26,0xFF,0x55,0x1D);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACodeBrowsePreview,0x929C8812,0x4DB1,0x4338,0xB3,0xB8,0xC1,0xBE,0x79,0x69,0xE2,0xBF);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACodeInsightCustomParameterHighlight,0xA75D8C18,0x14D7,0x465F,0x8C,0xCB,0xEB,0x1B,0x1F,0x62,0xB4,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACodeInsightManager,0x013F5F71,0xC500,0x44C8,0x90,0x4C,0x55,0x4F,0x98,0xC2,0xEC,0x28);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACodeInsightManager100,0xBA5B444A,0x6E78,0x4A79,0xBF,0x05,0xE1,0x84,0xC1,0x13,0x2B,0x30);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACodeInsightManager90,0x3408E3C3,0xB6C1,0x4B02,0x8C,0x5C,0xFD,0x54,0xD7,0x1A,0x08,0x2F);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACodeInsightManagerEnvOptions,0x5ED252A8,0x813F,0x4963,0x81,0x6C,0x2F,0xF1,0x40,0x19,0x9F,0x7E);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACodeInsightManagerEnvOptions270,0x5E593875,0xDB7F,0x43AC,0xBD,0x6F,0xC2,0x9C,0xF8,0xC3,0x1F,0xB7);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACodeInsightParamQuery,0xB1842926,0xC7F7,0x4869,0xB5,0x5A,0xCF,0xDB,0x6B,0xF7,0x05,0xB5);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACodeInsightParameterList,0x99B6A644,0x3E97,0x48A1,0x97,0x58,0x0A,0x5F,0xE9,0x47,0x67,0xC7);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACodeInsightParameterList100,0xEC7B37F6,0x8AB8,0x4B09,0x85,0xA4,0xAA,0x53,0xD5,0x85,0x6C,0x0F);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACodeInsightSelection,0x48AFA25C,0xBFDD,0x408F,0xB8,0x1B,0x6B,0xDF,0xDA,0x0A,0xBB,0x1C);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACodeInsightServices,0xFD980885,0xAF2D,0x4D29,0x8E,0xFB,0x2E,0xAE,0x52,0xC3,0x75,0x96);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACodeInsightServices270,0xEE5C42A9,0xDBC8,0x4C5D,0xB2,0x8E,0x52,0x80,0x24,0xCB,0xC9,0x7C);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACodeInsightServices60,0x476904F8,0x89A9,0x4CD8,0xA7,0x1E,0x16,0x46,0x60,0x65,0x97,0x63);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACodeInsightSymbolList,0x4CA1CDFD,0xBD9A,0x4628,0x94,0xAE,0x9B,0xF3,0xEB,0x2D,0xA2,0x2E);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACodeInsightSymbolList80,0x9D76DD60,0x0D5A,0x405B,0x96,0x95,0xC1,0xF1,0x30,0x92,0x89,0x8E);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACodeInsightUIOverride,0x47D57C60,0xAB08,0x4A03,0x9A,0x5E,0x2D,0xC2,0xC8,0x9A,0xCA,0xF6);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACodeInsightViewer,0x6268E073,0xD469,0x41BB,0x84,0xC5,0xD9,0x6A,0x34,0xEA,0x3D,0x17);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACodeInsightViewer90,0xAAA55FAC,0x350E,0x4F43,0x9C,0x42,0x4F,0xC2,0x8B,0x6B,0xFE,0x33);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACompileNotifier,0xC138C3D0,0x2806,0x479F,0x99,0x60,0x95,0x0C,0xD0,0xB8,0xA8,0x74);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACompileServices,0x68C486EF,0xC079,0x4D40,0xB4,0x62,0x2C,0x0D,0xD2,0x1F,0xE3,0x42);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAComponent,0xAC139ADF,0x329A,0xD411,0x87,0xC6,0x9B,0x27,0x30,0x41,0x22,0x00);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACreateOrderable,0x346E7BA5,0xD47E,0x11D3,0xBA,0x96,0x00,0x80,0xC7,0x8A,0xDC,0xDB);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACreator,0x6EDB9B9E,0xF57A,0x11D1,0xAB,0x23,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACustomDifferenceManager,0x6440B99E,0xAD2A,0x485B,0xBC,0x9E,0xE4,0x3E,0x8D,0x81,0xC9,0x99);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACustomDifferenceViewer,0xE20CA9AF,0x799E,0x4AE1,0x9C,0x74,0xDB,0xB2,0xB9,0xC5,0x45,0x29);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACustomEditView,0x845EDB0E,0xD107,0x4748,0x84,0x44,0x70,0x7C,0x68,0x0D,0x8A,0x65);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACustomMergeManager,0xB04FCE64,0xE57F,0x47E8,0xBA,0x6A,0x2E,0x96,0xAD,0x73,0x7B,0xBA);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACustomMergeViewer,0x06D2060C,0x5FA0,0x4216,0xA3,0x28,0x12,0x71,0x27,0x9D,0xE2,0xAE);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACustomMessage,0x589BBDA1,0xF995,0x11D1,0xAB,0x27,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACustomMessage100,0x824153E3,0x6336,0x48BA,0x80,0x5E,0x1A,0x35,0xE4,0x29,0x78,0x7E);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACustomMessage50,0xB7523AB7,0xEB81,0x11D2,0xAC,0x7B,0x00,0xC0,0x4F,0xB1,0x73,0xDC);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTACustomOptions,0x153495D4,0x7512,0x4203,0xBA,0x67,0x44,0x59,0xAA,0x20,0x18,0x80);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTADebuggerNotifier,0x34B2E2D8,0xE36F,0x11D1,0xAB,0x0E,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTADebuggerNotifier100,0xFE684C77,0x220C,0x4999,0xAC,0xFA,0xC4,0xC0,0xC7,0xFB,0x6A,0x42);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTADebuggerNotifier110,0x20E36B81,0xE987,0x4947,0xAA,0xFA,0xAC,0x0E,0x2F,0x0E,0x72,0xEF);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTADebuggerNotifier90,0x68558E84,0xA7EC,0x499F,0xAD,0x08,0xCB,0x00,0x87,0x6A,0xC5,0xBE);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTADebuggerServices,0x587EAFAE,0xB8B2,0x4007,0xA2,0x33,0xBE,0x09,0x05,0x2B,0xB6,0x7A);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTADebuggerServices120,0x29AE42CE,0x006A,0x4A96,0xA0,0xBB,0x0D,0x63,0xD9,0xE8,0x3A,0x5C);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTADebuggerServices150,0xDC682429,0xBB92,0x4AF7,0x9E,0x62,0x26,0x55,0x7D,0x68,0xDE,0x75);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTADebuggerServices60,0x0E3B9D7A,0xE119,0x11D1,0xAB,0x0C,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTADebuggerServices90,0xA797823A,0x6BD7,0x41A4,0xB3,0x6B,0x3A,0x83,0x1A,0x73,0x7B,0x2D);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTADebuggerVisualizer,0x744B7632,0x9F86,0x49B6,0xAE,0xD5,0x7A,0x48,0xDA,0x25,0xE3,0x76);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTADebuggerVisualizer250,0xDC0C8D82,0xB783,0x4205,0xB3,0xF4,0xD3,0x25,0xBA,0x8B,0x3E,0xEB);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTADebuggerVisualizerExternalViewer,0xA0D5CAF5,0x83A3,0x446E,0xB0,0x40,0xB3,0xE4,0x0A,0x92,0x6A,0x72);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTADebuggerVisualizerExternalViewerUpdater,0x4FA77EAB,0x4BA4,0x4203,0xB4,0x51,0x3B,0x3C,0x5B,0x42,0x8D,0x39);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTADebuggerVisualizerValueReplacer,0x6BBFB765,0xE76F,0x449D,0xB0,0x59,0xA7,0x94,0xFA,0x06,0xF9,0x17);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTADefaultPreviewTrait,0x0BFB4FE6,0x77F3,0x43AE,0x97,0xA9,0xF7,0x40,0xF8,0x81,0x61,0x26);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTADesignerCommandNotifier,0xF862787A,0x4FF5,0x4B91,0xB6,0x26,0xD9,0xAD,0x53,0xEA,0x98,0xA6);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTADesignerCommandServices,0xC18D655E,0x54B1,0x412D,0xBE,0xCF,0x58,0x4B,0x08,0x83,0x88,0x27);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditActions,0x332DBE22,0xAB36,0x44B7,0xB8,0x35,0xBC,0x95,0xF6,0xF9,0xE6,0x88);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditActions100,0x9A073F11,0x2732,0xD611,0x95,0x8B,0x00,0xC0,0x4F,0xA0,0x6A,0xFC);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditActions60,0xECB23623,0xE2D8,0x11D2,0xAB,0xE5,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditBlock,0x371F9A07,0x94E2,0x4708,0x9D,0xB0,0x93,0x51,0x4F,0xD2,0xFE,0x14);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditBlock90,0x9C510463,0xC7BC,0x11D2,0x9A,0xEB,0x00,0xA0,0x24,0x57,0x62,0x1F);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditBuffer,0xEB6465CE,0xD901,0x43C4,0xAB,0x69,0x24,0x0A,0x74,0x00,0xB9,0xAA);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditBuffer60,0x9C510460,0xC7BC,0x11D2,0x9A,0xEB,0x00,0xA0,0x24,0x57,0x62,0x1F);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditBufferIterator,0x8ECB33AA,0xD0BD,0x11D2,0xAB,0xD6,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditLineNotifier,0xD9D48F50,0xE6CC,0x11D2,0xAB,0xE8,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditLineTracker,0xD9D48F4F,0xE6CC,0x11D2,0xAB,0xE8,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditOptions,0x02999EF7,0x669C,0x406B,0x8E,0x14,0x4F,0xE8,0xB2,0x75,0x42,0xB8);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditOptions60,0x487BEA91,0xDBC0,0x11D2,0xAB,0xDE,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditPosition,0x9C510464,0xC7BC,0x11D2,0x9A,0xEB,0x00,0xA0,0x24,0x57,0x62,0x1F);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditReader,0x26EB0E4F,0xF97B,0x11D1,0xAB,0x27,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditView,0x66D8D413,0x9D17,0x47B9,0x9B,0xC4,0x6D,0x75,0x50,0x43,0x7D,0x1E);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditView140,0x9C510462,0xC7BC,0x11D2,0x9A,0xEB,0x00,0xA0,0x24,0x57,0x62,0x1F);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditView145,0x5EBBA00C,0x059D,0x4571,0xB3,0x0A,0x32,0x8D,0x12,0x64,0xBB,0xB8);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditView220,0xBD1A97F8,0x2346,0x4856,0x8A,0x19,0x51,0x78,0x7E,0xAC,0x32,0x40);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditView40,0x0E3B9D78,0xE119,0x11D1,0xAB,0x0C,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditWriter,0x26EB0E50,0xF97B,0x11D1,0xAB,0x27,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditor,0xF17A7BD0,0xE07D,0x11D1,0xAB,0x0B,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditorColorSpeedSetting,0xC9BF69D9,0x06D4,0x4B10,0xA6,0x58,0xB7,0x5B,0xBB,0xBE,0xFD,0xF9);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditorContent,0x748FB436,0x59B9,0x495D,0x8A,0xC8,0x80,0x7C,0xF6,0x62,0x29,0x67);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditorExplorerPersonalityTrait,0x76B0B1C4,0xA87D,0x473D,0xB6,0xF5,0xCA,0xDC,0xDE,0xF7,0x8F,0x30);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditorNotifier,0x0E3B9D7B,0xE119,0x11D1,0xAB,0x0C,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditorServices,0xBE733055,0x5ED8,0x45B4,0xBA,0xB1,0x19,0xC4,0x6C,0x23,0x74,0x08);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditorServices60,0xC2812BA7,0xC48D,0x11D2,0x9A,0xE8,0x00,0xA0,0x24,0x57,0x62,0x1F);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditorServices70,0x2596F557,0x44A3,0x49A6,0x86,0x7E,0x91,0xE2,0x1E,0x00,0xF5,0x3E);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditorServices80,0xF37E8C46,0x0A02,0x4FD4,0x8D,0x57,0xE5,0x5F,0x9A,0x57,0x83,0xEC);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditorViewServices,0x75FE2D18,0x622B,0x4198,0xA0,0x92,0xAD,0xD1,0xE9,0x16,0x12,0xBD);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEditorViewServices140,0xCCE8FBE0,0xE121,0x450C,0x93,0x66,0x1A,0xC6,0xBF,0xD6,0xCF,0x81);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAElideActions,0x06EF0818,0xE4DF,0x414F,0xBD,0x86,0xBC,0xD2,0x96,0x80,0xD5,0x53);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAElideActions120,0x3AB41D14,0xD290,0x4674,0x89,0x78,0xD0,0xAB,0x4E,0x70,0xC1,0x4B);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAElideActions150,0x8080361F,0x888F,0x4D0E,0x9E,0xCF,0x3F,0xE2,0x1F,0xA7,0x68,0xB5);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAElisionPreview,0x5637D9D8,0x9310,0x4D46,0xB4,0x0D,0x1D,0xFE,0xB1,0x56,0x77,0xD2);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEnvironmentOptions,0x8BE50634,0x54B0,0x4D9C,0xB5,0x3A,0xBB,0x99,0x50,0x9A,0x33,0xE9);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAEnvironmentOptions140,0x9C0E91FB,0xFA5A,0x11D1,0xAB,0x28,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAFile,0x6E2AD9B0,0xF7F0,0x11D1,0xAB,0x26,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAFileFilter,0x14DBB1D5,0x9802,0x458E,0xA8,0xC3,0x60,0x62,0x37,0x70,0x89,0x39);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAFileFilterByName,0x0624E15E,0xA4E1,0x45D6,0x8D,0x24,0xFD,0xF6,0x71,0x33,0xE4,0x83);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAFileFilterServices,0x84302AE6,0x646C,0x4547,0x85,0xF1,0x4F,0xB0,0x83,0x90,0x38,0xE2);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAFileFilterWithCheckEncode,0x17E89149,0x6F65,0x416F,0x88,0xEA,0xB9,0x49,0x44,0x9B,0xA9,0xA0);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAFileSystem,0xA9D1389D,0xF4B0,0x11D1,0xAB,0x22,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAFileSystem80,0xA9C2BD51,0x0372,0x47B6,0x88,0x31,0xAA,0x77,0x4C,0xD5,0xAC,0x37);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAFormEditor,0xF17A7BD2,0xE07D,0x11D1,0xAB,0x0B,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAFormNotifier,0x0E3B9D7C,0xE119,0x11D1,0xAB,0x0C,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAFormWizard,0x36C8BF35,0xEFFE,0x11D1,0xAB,0x1D,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAFormWizard100,0x56D61347,0xC74D,0x4BF7,0x89,0xA9,0xF4,0x22,0xF3,0x1C,0xF2,0x59);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAGalleryCategory,0xCCEA8A72,0x46BA,0x4CCF,0x86,0x3C,0x97,0x18,0xCC,0x06,0xDA,0xBF);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAGalleryCategoryManager,0x5FAFFE12,0xE1A4,0x4286,0x94,0xF9,0xA0,0x25,0xB3,0xC0,0xBF,0x41);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAGetItService,0x6DA2C99A,0x212A,0x4A24,0xB3,0xCA,0x8C,0x67,0xCF,0x4B,0x71,0x23);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAGetItService220,0x767984C8,0xF8CE,0x4BC5,0x95,0x62,0x72,0x5A,0xC0,0x66,0x57,0x10);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAGetItService230,0xCB83D480,0xDC2D,0x4881,0xAF,0x2A,0xE6,0x84,0x96,0xEE,0x52,0xBF);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAHelpInsight,0xD05FBF46,0x8468,0x4934,0xBF,0x70,0x7E,0xAE,0x1A,0xB8,0xFE,0xAB);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAHelpServices,0x25F4CC12,0xEA93,0x4AEC,0xBC,0x4A,0xDF,0xDF,0x42,0x70,0x53,0xB0);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAHelpTrait,0xDEE36173,0x1597,0x498A,0xA8,0x5A,0xC9,0x0B,0xFC,0xAE,0x9B,0x74);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAHighlightServices,0x78C26089,0x6CAD,0x40D1,0xBA,0xC2,0x37,0xA8,0x4D,0xF8,0xF3,0xE6);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAHighlighter,0x79D28DA1,0x42F6,0x44B9,0xAE,0x33,0xD0,0x01,0xFD,0x75,0xDC,0x40);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAHighlighterPreview,0x86A7ABCC,0xF81C,0x479D,0xB2,0x5D,0xC1,0x05,0xF0,0xDF,0x12,0x54);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAHistoryItem,0x4D97EDB8,0x16BE,0x4BD2,0xA6,0x24,0x3E,0xE9,0x1E,0xB4,0xC8,0xBC);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAHistoryServices,0x0EFF550D,0x305C,0x466C,0x94,0xC1,0x1D,0x40,0x6D,0xF9,0xB7,0x3A);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAIDEInsightCategory,0xD943D3FE,0xBC3F,0x4405,0xBF,0x2A,0x4F,0x9F,0x00,0x1A,0xD1,0x9E);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAIDEInsightNotifier,0xFDEC7D0D,0x9633,0x424A,0xA9,0x25,0x5D,0xC1,0xDE,0x13,0xFD,0x48);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAIDEInsightNotifier150,0x6B051B2F,0x1EB6,0x41BC,0xAA,0x94,0xDB,0x97,0x27,0xA7,0x70,0x2B);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAIDEInsightService,0xD1258D2C,0xDE95,0x4A0A,0x9A,0x7E,0x8C,0x61,0x67,0xF4,0x8B,0x31);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAIDENotifier,0xE052204F,0xECE9,0x11D1,0xAB,0x19,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAIDENotifier50,0xAC7D29F1,0xD9A9,0x11D2,0xA8,0xC1,0x00,0xC0,0x4F,0xA3,0x2F,0x53);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAIDENotifier80,0x41679BBC,0x660E,0x4948,0xAD,0x80,0x63,0xC6,0x79,0xCB,0x97,0x3C);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAIDEThemingServices,0xDEAD2647,0x9B2C,0x4084,0xA6,0x1E,0x1E,0x69,0xA9,0x17,0x96,0x37);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAIDEThemingServices250,0xDEAD2648,0x9B21,0x4084,0x77,0x1E,0x1E,0x69,0xA9,0x17,0x66,0x37);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAIDEThemingServices260,0xBDEBDA9B,0x7001,0x4A25,0x96,0x39,0xA3,0x69,0x9A,0xE9,0xFC,0x51);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAIDEWaitDialogServices,0x30CD7CFE,0x3EE4,0x4CED,0xAF,0x4A,0xC8,0xC7,0x6B,0xE4,0x87,0xF5);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAIDEWaitDialogServices270,0x61858165,0x9756,0x4B3A,0xA5,0xA5,0x19,0x2A,0x39,0x2C,0xEA,0x4A);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAInsertWideChar,0xA43AC8A9,0x7641,0x427B,0xA5,0xF2,0xF3,0xDF,0xE9,0x37,0xE9,0x74);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAKeyBindingServices,0xF8CAF8D8,0xD263,0x11D2,0xAB,0xD8,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAKeyContext,0x3E7790CB,0xD2BB,0x11D2,0xAB,0xD8,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAKeyboardBinding,0xF8CAF8D7,0xD263,0x11D2,0xAB,0xD8,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAKeyboardDiagnostics,0xAEFC65F1,0x2504,0x11D3,0xAC,0x25,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAKeyboardServices,0xF8CAF8D5,0xD263,0x11D2,0xAB,0xD8,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTALocalMenu,0x83ECCBDF,0x939D,0x4F8D,0xB9,0x6D,0xA0,0xC6,0x7A,0xCC,0x86,0xEA);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAMenuContext,0x378F0D38,0xED5F,0x4128,0xB7,0xD6,0x9D,0x42,0x3F,0xC1,0x50,0x2F);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAMenuWizard,0xB75C0CE2,0xEEA6,0x11D1,0x95,0x04,0x00,0x60,0x8C,0xCB,0xF1,0x53);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAMessageGroup,0x52A6CDC6,0x2225,0x4D3C,0xAC,0x02,0xA6,0x8C,0x9B,0x19,0xA9,0x67);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAMessageGroup80,0x233F4508,0x6022,0x4DDF,0xB6,0xD3,0xD2,0x10,0x8B,0xAF,0x80,0xDB);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAMessageGroup90,0xCF2B68C9,0x9ED0,0x461E,0xA5,0xF4,0xDF,0xC3,0xB0,0x26,0x8A,0x85);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAMessageNotifier,0xFDCB2ED4,0xB89C,0x4D00,0xB0,0xDB,0x19,0x56,0x29,0x51,0xCD,0xBB);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAMessageServices,0x29E893DB,0xDD9A,0x4CEA,0xB2,0xEE,0x57,0x53,0x2E,0x01,0xA9,0xB9);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAMessageServices40,0x26EB0E4E,0xF97B,0x11D1,0xAB,0x27,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAMessageServices50,0x3263774B,0xE959,0x11D2,0xAC,0x7B,0x00,0xC0,0x4F,0xB1,0x73,0xDC);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAMessageServices60,0x58A40C76,0x7EC6,0x41DA,0xA2,0xEF,0x4B,0x3A,0xF3,0x1D,0x39,0x77);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAMessageServices70,0xB3F7D3A6,0xD1F7,0x48A0,0x8B,0xB0,0xF4,0x9C,0xF6,0x0F,0xB8,0x15);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAMessageServices80,0x02DD618A,0x30A0,0x4DCE,0x9D,0x04,0x6B,0x73,0x66,0x46,0xFF,0xCB);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAModule,0xC0D4CBA8,0x54A3,0x48EA,0xBE,0x63,0x98,0xCE,0x3D,0x9F,0x0F,0x43);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAModule140,0x7FF96161,0xE610,0x4414,0xB8,0xB1,0xD1,0xEC,0xA7,0x6F,0xEA,0xFB);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAModule40,0xF17A7BCC,0xE07D,0x11D1,0xAB,0x0B,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAModule50,0x15D3FB81,0xEF27,0x488E,0xB2,0xB4,0x26,0xB5,0x9C,0xA8,0x9D,0x9D);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAModule70,0x2438BFB8,0xC742,0x48CD,0x8F,0x50,0xDE,0x6C,0x7F,0x76,0x4A,0x55);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAModuleCleanup,0x682E85BB,0xAF62,0x4868,0xBE,0xFF,0x0C,0x15,0x15,0xF0,0x06,0xA8);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAModuleCreator,0x6EDB9B9A,0xF57A,0x11D1,0xAB,0x23,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAModuleData,0xFFD0A5AF,0x49CB,0x4EC2,0xA6,0x58,0x95,0x71,0x46,0x03,0x0C,0xEC);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAModuleErrors,0x8626BF14,0x1526,0x4B88,0x82,0x6E,0x09,0x35,0xDB,0x0D,0xBB,0x25);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAModuleInfo,0x006DD7BE,0x55FD,0x4707,0x8C,0x7E,0x36,0x02,0xC9,0x72,0x18,0x10);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAModuleInfo160,0xB3EEB4D2,0xECDD,0x4CDC,0xB9,0x6E,0xB5,0xC8,0xF6,0xD0,0x50,0xA8);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAModuleInfo50,0xF17A7BD6,0xE07D,0x11D1,0xAB,0x0B,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAModuleNotifier,0xF17A7BCE,0xE07D,0x11D1,0xAB,0x0B,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAModuleNotifier80,0x6C4714BB,0x223A,0x4CDF,0xA7,0x10,0x42,0x9F,0xE8,0xFA,0x0B,0x91);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAModuleNotifier90,0x53B90D0D,0x0E70,0x472A,0x88,0x5E,0x05,0x66,0xB2,0x71,0x1C,0x15);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAModuleRegions,0xA7E7D74C,0xD123,0x4FAF,0xBE,0x36,0xC4,0xFE,0x12,0x6B,0x07,0xFC);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAModuleServices,0x55A5E848,0x27FB,0x4880,0x8E,0x7C,0x7F,0x05,0xA9,0x80,0x24,0x82);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAModuleServices70,0xF17A7BCD,0xE07D,0x11D1,0xAB,0x0B,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTANotifier,0xF17A7BCF,0xE07D,0x11D1,0xAB,0x0B,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAOptions,0x9C0E91FC,0xFA5A,0x11D1,0xAB,0x28,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAPackageInfo,0xF41DB233,0x500B,0x4B0D,0x93,0xA0,0x90,0x72,0xE1,0x0E,0xE0,0x69);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAPackageServices,0x1E8AB2DA,0xCC56,0x4FA5,0x85,0x1A,0x9C,0xDC,0x95,0x7D,0x1D,0x65);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAPackageServices140,0x26EB0E4D,0xF97B,0x11D1,0xAB,0x27,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAPackageServices210,0x2C96711A,0x267A,0x4024,0x9C,0x54,0xB1,0x1F,0xCC,0x59,0x6A,0x6F);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAPerformanceTimer,0x7C04C7AA,0xA699,0x41AA,0xB6,0xF7,0xC3,0x69,0xCF,0xF8,0xEB,0x5F);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAPersonalityHelpTrait,0x914E82DB,0x4123,0x4AA8,0x91,0xD9,0xDB,0x10,0x5E,0x1F,0xEC,0x64);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAPersonalityServices,0xF6B15FD1,0xE9D6,0x4DCC,0x8A,0xCD,0x06,0x14,0x3F,0x1F,0x67,0xBE);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAPersonalityServices100,0xF66FB6B3,0x24DC,0x4BC0,0x8A,0x6B,0x41,0x59,0xB5,0x27,0xA1,0xFC);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAPersonalityServices140,0x92D70AB5,0xF54F,0x4432,0x8E,0x0E,0x5B,0xEE,0xF4,0xB3,0xBE,0x77);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAPrimaryCodeInsightManager,0xE935146E,0xB88C,0x4E4F,0x9F,0xAC,0x69,0x97,0x39,0x52,0xD5,0x34);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProcess,0xFBECB2A2,0x80BF,0x400D,0xB4,0xA6,0x0B,0xCE,0xAB,0xC2,0xFF,0x7D);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProcess150,0x1C540740,0xE350,0x4DD1,0xB0,0x26,0xC2,0x33,0xD1,0xC3,0x80,0xD4);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProcess60,0x34B2E2D2,0xE36F,0x11D1,0xAB,0x0E,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProcess70,0x64FC3321,0xBEC8,0x4E88,0xB1,0x7A,0x3E,0x78,0xEA,0x15,0xF1,0x0E);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProcess90,0xBEBD67CA,0xF6FC,0x44A7,0xAC,0xBF,0xE3,0x14,0xDB,0x08,0x58,0x27);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProcessModNotifier,0x0906387A,0xE43A,0x11D1,0xAB,0x0F,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProcessModule,0x41171E69,0xE830,0x40B4,0xA8,0xC6,0x1A,0x11,0x53,0x07,0xC8,0xA1);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProcessModule110,0xEA1D9277,0xC318,0x4E5C,0x8B,0xDC,0x03,0x52,0x9E,0x81,0xDF,0x8E);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProcessModule80,0x09063879,0xE43A,0x11D1,0xAB,0x0F,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProcessModule90,0x9B4A6BC8,0xCC15,0x42A9,0xA4,0x1D,0x81,0x6A,0x72,0xCA,0x0A,0xF1);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProcessNotifier,0x34B2E2D6,0xE36F,0x11D1,0xAB,0x0E,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProcessNotifier90,0xE2725B23,0xE67C,0x4CF1,0xB9,0x28,0xFA,0x0F,0x5B,0x9C,0x2C,0x29);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProject,0x0E4BFB1D,0x2F3B,0x4CD6,0xA9,0xA2,0x49,0x03,0x71,0x3B,0x59,0xE0);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProject100,0xD0090018,0xD879,0x41FC,0x8F,0x83,0xAA,0x4F,0x40,0x09,0x8A,0xCF);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProject120,0x3D7E07CB,0x392D,0x4EFB,0x84,0x1D,0xA6,0xC6,0xE3,0x38,0xCF,0x13);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProject140,0x6B1A57F9,0x34A3,0x4824,0x96,0xF0,0x75,0x0A,0x63,0x32,0x8C,0x4E);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProject150,0xA6287B50,0xDA09,0x44EF,0xAA,0x80,0x9D,0x1C,0xAF,0xDE,0x78,0x57);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProject160,0xF5EA2A72,0x485D,0x49E8,0xB6,0x0A,0xB0,0xE7,0xC7,0xB8,0x0A,0x27);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProject40,0xF17A7BCA,0xE07D,0x11D1,0xAB,0x0B,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProject70,0x06C88136,0xF367,0x4D47,0xB8,0xB4,0xCC,0xAC,0xB3,0xD7,0x43,0x9A);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProject90,0xBBBE4CC6,0x36DE,0x4986,0xBD,0x9E,0x9D,0xF0,0xF0,0x6F,0xC8,0xF1);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectBuilder,0x76AD8696,0xB58C,0x44B4,0xB4,0xAE,0xC5,0x47,0x02,0x23,0x72,0x79);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectBuilder140,0x08A5B1F5,0xFCDA,0x11D2,0xAC,0x82,0x00,0xC0,0x4F,0xB1,0x73,0xDC);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectBuilder40,0xF17A7BD5,0xE07D,0x11D1,0xAB,0x0B,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectCompileNotifier,0xD78E04B9,0x80D8,0x4214,0x92,0x0F,0xCB,0x15,0xB5,0x71,0x65,0x4F);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectCreator,0x6EDB9B9D,0xF57A,0x11D1,0xAB,0x23,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectCreator160,0x4334DF37,0xC1B6,0x4135,0xA6,0x65,0x76,0x2D,0xC2,0xDA,0x40,0x86);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectCreator190,0x2E0ABEEB,0xF885,0x4BA5,0xBF,0x6C,0x3A,0x11,0xF9,0x63,0xF9,0x3E);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectCreator50,0x64312F82,0x62F3,0x48E9,0xBA,0xF6,0xB0,0x3D,0xF4,0x50,0x31,0x2A);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectCreator80,0x9A1D6AF5,0x84FA,0x481C,0xA4,0x46,0x74,0x6D,0x9A,0x50,0xF5,0x3E);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectCurrentFolder,0xD86ED6B5,0x974A,0x4657,0xB9,0x4A,0xD3,0x4F,0x05,0x97,0xFE,0xDD);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectDependenciesList,0x4D87F08B,0xA6A6,0x4C0F,0xAC,0x33,0xD6,0xCE,0x79,0x2E,0xC5,0x22);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectFileStorage,0x81515027,0xEEED,0x442F,0x97,0x7C,0x8F,0x39,0xF5,0x3D,0x8D,0x0A);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectFileStorageNotifier,0xD6B7B13F,0xF5EA,0x4320,0xBD,0xCE,0x55,0x23,0x66,0x38,0xBD,0xE2);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectGroup,0xB9EAE73C,0x8A03,0x4729,0xA2,0x32,0xEE,0xE6,0x26,0x80,0x1A,0x0B);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectGroup160,0xF17A7BCB,0xE07D,0x11D1,0xAB,0x0B,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectGroupCreator,0x6EDB9B9F,0xF57A,0x11D1,0xAB,0x23,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectGroupProjectDependencies,0x9B6203FF,0x7019,0x49D5,0xB3,0xDF,0x6F,0xBD,0xFC,0x61,0xBA,0xCE);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectManager,0xB142EF92,0x0A91,0x4614,0xA7,0x2A,0xCE,0x46,0xF9,0xC8,0x8B,0x7B);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectManagerMenu,0x5E3B2F18,0x306E,0x4922,0x90,0x67,0x3F,0x71,0x84,0x3C,0x51,0xFA);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectMenuContext,0xECEC33FD,0x837A,0x46DC,0xA0,0xAD,0x1F,0xFE,0xBE,0xEA,0x23,0xAF);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectMenuItemCreatorNotifier,0xCFEE5A57,0x2B04,0x4CD6,0x96,0x8E,0x1C,0xBF,0x8B,0xF9,0x65,0x22);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectNotifier,0x75A09281,0xAD20,0x427B,0xA5,0x06,0x47,0x12,0xD0,0xA6,0x41,0x64);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectOptions,0x2888E741,0xE7FB,0x4BBC,0xA0,0x93,0x4B,0x09,0x03,0xD9,0xD9,0x90);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectOptions40,0xF17A7BD4,0xE07D,0x11D1,0xAB,0x0B,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectOptions70,0xF899EBC6,0xE6E2,0x11D2,0xAA,0x90,0x00,0xC0,0x4F,0xA3,0x70,0xE9);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectOptionsConfigurations,0x55A4A36F,0x210E,0x4B0B,0xBD,0x2D,0xA1,0x53,0x54,0x99,0x2A,0x5C);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectOptionsConfigurations140,0xE158B38A,0x90BF,0x425E,0xA6,0x34,0x03,0x58,0xB7,0x94,0x87,0x0E);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectOptionsConfigurations230,0xBDC06BC9,0xA56C,0x41D2,0xBF,0x41,0xDD,0xA7,0x65,0x70,0x80,0x9A);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectResource,0x26EB0E52,0xF97B,0x11D1,0xAB,0x27,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectUnitScopes,0x3D724710,0x9F56,0x4BFB,0x88,0x04,0x24,0x10,0x02,0x2B,0xAA,0xE9);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectWizard,0x36C8BF36,0xEFFE,0x11D1,0xAB,0x1D,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAProjectWizard100,0x809D578B,0xAE79,0x4CC2,0xA6,0xED,0xD7,0xA8,0xCD,0x24,0xC7,0x4D);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTARecord,0xF8CAF8D6,0xD263,0x11D2,0xAB,0xD8,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAReplaceOptions,0xD1766F8C,0xD915,0x11D2,0xA8,0xC1,0x00,0xC0,0x4F,0xA3,0x2F,0x53);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTARepositoryWizard,0xB75C0CE1,0xEEA6,0x11D1,0x95,0x04,0x00,0x60,0x8C,0xCB,0xF1,0x53);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTARepositoryWizard160,0x034C3976,0xA0CB,0x4376,0xA2,0x96,0xF3,0xC2,0x86,0x89,0x15,0x73);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTARepositoryWizard190,0x66141605,0xAA2A,0x4F82,0x84,0xDE,0xDB,0x82,0x5D,0x52,0x64,0x7C);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTARepositoryWizard260,0x7063BAEB,0x7C97,0x4B22,0x9D,0x8F,0xB3,0xD5,0xA0,0x9F,0x25,0x45);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTARepositoryWizard60,0x08FCCD88,0x3A21,0x4281,0xAD,0xC9,0x62,0xFC,0x03,0x4C,0xDD,0x12);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTARepositoryWizard80,0xD7714D41,0xBC4A,0x445E,0xB6,0x95,0x25,0xA6,0x5C,0x2F,0x56,0x1E);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAResourceEntry,0x26EB0E51,0xF97B,0x11D1,0xAB,0x27,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAScaleable,0x346E7BA6,0xD47E,0x11D3,0xBA,0x96,0x00,0x80,0xC7,0x8A,0xDC,0xDB);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTASearchOptions,0xD1766F8B,0xD915,0x11D2,0xA8,0xC1,0x00,0xC0,0x4F,0xA3,0x2F,0x53);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAServices,0xD1358CFB,0x9B5C,0x4E6C,0xBC,0x4B,0xC6,0xD0,0x6C,0x66,0x89,0xC1);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAServices100,0x33B33186,0x3CEC,0x4624,0x97,0x0E,0x41,0x7A,0x8F,0xE1,0x40,0x89);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAServices110,0x17A48937,0x2C9C,0x4543,0xAB,0x6D,0x2C,0xF1,0x3B,0xAE,0x54,0x4B);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAServices140,0x80E56DFA,0x82B2,0x425A,0x92,0x1E,0x8E,0x5E,0xD6,0x16,0x4A,0x11);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAServices160,0x86602DE0,0x50BF,0x4AE5,0xBA,0xF4,0xD9,0x43,0x8B,0xD3,0x32,0x18);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAServices50,0x7FD1CE91,0xE053,0x11D1,0xAB,0x0B,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAServices60,0x577ECE00,0x59EE,0x4F21,0x81,0x90,0x9F,0xD8,0xA4,0x5F,0xE5,0x50);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAServices70,0x0044BB24,0x425D,0xD611,0x9C,0xF1,0x00,0xC0,0x4F,0xA0,0x6A,0xFC);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTASourceBreakpoint,0x09063877,0xE43A,0x11D1,0xAB,0x0F,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTASourceEditor,0x4D460588,0x10A6,0x4CAD,0x87,0xE7,0x56,0x54,0x26,0x60,0x73,0xF9);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTASourceEditor180,0x5D965803,0x8147,0x4D32,0xB8,0xC5,0x71,0x2F,0x6D,0xDC,0xF9,0x8E);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTASourceEditor70,0xF17A7BD1,0xE07D,0x11D1,0xAB,0x0B,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTASpeedSetting,0xB5CDCE07,0xE093,0x11D2,0xAB,0xE2,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTASplashScreenServices,0x1A3CDFB0,0xEBF6,0x449D,0x88,0xD4,0x3D,0x29,0x91,0xF8,0x97,0x4F);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAStreamModifyTime,0x49F2F63F,0x60CB,0x4FD4,0xB1,0x2F,0x81,0x67,0xFC,0x79,0xB2,0x93);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAStrings,0x36A00C9A,0x58D9,0x42EE,0x8B,0x10,0x47,0x8C,0x1B,0x66,0x91,0xE8);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTASyncEditNotifier,0xFA65E734,0x7F38,0x48F2,0x9A,0x9C,0xB0,0x96,0x50,0x15,0x9E,0x34);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTASyncEditPoint,0xB724144B,0xD292,0x4BAB,0x92,0x5F,0xBE,0x84,0xD7,0xE7,0x50,0x7C);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTASyncEditPoint100,0x59492E58,0x8CE3,0x45D8,0x90,0x2F,0xD8,0x04,0x75,0xDE,0xFE,0x9D);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTASyncEditPoints,0x5E7AD63A,0xCB78,0x4BF4,0x9F,0x1D,0xB2,0x57,0x68,0x98,0xDC,0xB4);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTATabOrderable,0x346E7BA4,0xD47E,0x11D3,0xBA,0x96,0x00,0x80,0xC7,0x8A,0xDC,0xDB);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAThread,0x2CBF37C1,0x8845,0x4C06,0x86,0x58,0x79,0xE1,0x1F,0x6D,0x76,0xEA);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAThread110,0x3A96CD8F,0xA5CD,0x4AFE,0x8A,0x73,0xDA,0xE1,0x26,0x50,0x95,0xD9);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAThread120,0xDF4C57A6,0x8674,0x4D7E,0xB7,0x5E,0x67,0x04,0xBB,0x5F,0x1A,0x54);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAThread140,0xBC146984,0x1E20,0x4695,0x87,0x9A,0x25,0xE6,0xA8,0x2F,0x52,0xF7);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAThread150,0x7030D03B,0xEB04,0x47EC,0x9E,0x3B,0x6D,0xB5,0x0D,0x3B,0x89,0x68);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAThread50,0x34B2E2D3,0xE36F,0x11D1,0xAB,0x0E,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAThread60,0x2646D502,0x95F8,0x4E6F,0xA1,0xEC,0x97,0x6E,0x96,0x63,0xC9,0xB6);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAThread70,0x24064FD3,0x5D3C,0xD611,0x88,0xBC,0x00,0xC0,0x4F,0xA0,0x6A,0xFC);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAThread90,0x175F985B,0x4F54,0x41B2,0xA0,0xA1,0x54,0xF3,0xB6,0x6E,0xCD,0x07);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAThreadNotifier,0x34B2E2D7,0xE36F,0x11D1,0xAB,0x0E,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAThreadNotifier160,0x46F94C52,0xE225,0x4054,0xA5,0xF0,0xF5,0xE6,0x7E,0x29,0xB2,0xC2);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTATimerServices,0xE7D682D3,0x3540,0x4981,0x9A,0xBF,0x16,0x08,0x28,0x75,0x41,0x91);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAToDoManager,0x3D4A0565,0xEB77,0x11D2,0xAA,0x9A,0x00,0xC0,0x4F,0xA3,0x5C,0xE8);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAToDoServices,0xF8FC00EF,0xE61A,0x11D2,0xAA,0x99,0x00,0xC0,0x4F,0xA3,0x5C,0xE8);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAToolsFilter,0x891B2757,0xFC6F,0x4DE9,0xB6,0x53,0xF5,0x5A,0x52,0x73,0x33,0x24);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAToolsFilter60,0x8864B891,0x9B6D,0x4002,0xBB,0x2E,0x1D,0x6E,0x59,0xBF,0xA4,0x9A);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAToolsFilterNotifier,0xCEF1F13A,0xE877,0x4F20,0x88,0xF2,0xF7,0xE2,0xBA,0x61,0xAA,0xF4);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTATransactionItem,0xF947EF3D,0x13C7,0x465F,0xAD,0x78,0x62,0x1A,0xFF,0x0A,0x7E,0x8C);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTATypeLibEditor,0xF17A7BD3,0xE07D,0x11D1,0xAB,0x0B,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTATypeLibModule,0x0BBAEEA0,0xEF74,0x11D1,0xAB,0x1C,0x00,0xC0,0x4F,0xB1,0x6F,0xB3);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTATypeLibrary,0x7A2F5910,0x58D2,0x448E,0xB4,0x57,0x2D,0xC0,0x1E,0x85,0x3D,0x46);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAVersionControlNotifier,0xC301E578,0xD2AE,0x48EA,0x9E,0xEA,0xAE,0xE4,0x8D,0x57,0x8F,0xE7);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAVersionControlNotifier150,0xDDAB6FCC,0xABE7,0x46C8,0x80,0x40,0xAB,0xFE,0x7E,0x1D,0x76,0x04);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAVersionControlServices,0x1BFE2647,0x9BFC,0x4084,0xAE,0x3E,0x3E,0x09,0xA9,0x17,0x9E,0x34);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAWizard,0xB75C0CE0,0xEEA6,0x11D1,0x95,0x04,0x00,0x60,0x8C,0xCB,0xF1,0x53);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAWizardServices,0xB75C0CE3,0xEEA6,0x11D1,0x95,0x04,0x00,0x60,0x8C,0xCB,0xF1,0x53);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAVersionSKUInfoService280,0x03DBF50C,0xB649,0x4AAF,0xAF,0x5E,0x28,0xE1,0xB3,0x59,0xD2,0x9B);'*)
(*$HPPEMIT 'DEFINE_GUID(IID_IOTAVersionSKUInfoService,0x530C43C7,0x7A23,0x45D6,0xBD,0xDC,0xAD,0x9C,0x5C,0x10,0x8C,0x58);'*)

{ OTA Prefix - Open Tools API
  Accessing these interfaces only requires that the user use the Borlndmm.dll via
  sharemem. }
{ NTA Prefix - Native Tools API
  Accessing these interfaces requires that the user compile requiring vclxx.bpl
  since actual objects are passed among the interfaces. }

const
  utForm          = 0;
  utDataModule    = 1;
  utProjUnit      = 2;
  utUnit          = 3;
  utRc            = 4;
  utAsm           = 5;
  utDef           = 6;
  utObj           = 7;
  utRes           = 8;
  utLib           = 9;
  utTypeLib       = 10;
  utPackageImport = 11;
  utFormResource  = 12;
  utNoMake        = 13;

  atWhiteSpace     = 0;
  atComment        = 1;
  atReservedWord   = 2;
  atIdentifier     = 3;
  atSymbol         = 4;
  atString         = 5;
  atNumber         = 6;
  atFloat          = 7;
  atOctal          = 8; // not used in Pascal tokenizer
  atHex            = 9;
  atCharacter      = 10; // not used in Pascal tokenizer
  atPreproc        = 11;
  atIllegal        = 12; // not used in Pascal tokenizer
  atAssembler      = 13;
  SyntaxOff        = 14;
  atOverridable    = $8000;

  MarkedBlock      = 15;
  SearchMatch      = 16;

  atHotLink        = 17;

  atTags           = 20;
  atAttrNames      = 21;
  atAttrValues     = 22;
  atScripts        = 23;

  RightMargin      = 37;

  lfCurrentEIP          = $0001;
  lfBreakpointEnabled   = $0002;
  lfBreakpointDisabled  = $0004;
  lfBreakpointInvalid   = $0008;
  lfErrorLine           = $0010;
  lfBreakpointVerified  = $0020;
  lfBackgroundBkpt      = $0040; // Breakpoint only valid in a non-active process
  lfBackgroupEIP        = $0080; // Execution point only valid in a non-active process

  { RegionKind constants }

  rkRegion = 0;
  rkIf = 1;
  rkNameSpace = 2;
  rkType = 3;
  rkMethod = 4;
  rkNestedMethod = 5;
  rkGlobal = 6;
  rkDocumentation = 7;

  // The following string constants are the internal names of editor macro
  // "scripts" that get executed in response to certain menu commands.  This
  // allows a menu command to execute the exact same internal "macro script"
  // as the direct key binding.

  mcGetFindString = 'GetFindString';
  mcReplace = 'Replace';
  mcRepeatSearch = 'RepeatSearch';
  mcIncrementalSearch = 'IncrementalSearch';
  mcGotoLine = 'GotoLine';
  mcClipCut = 'ClipCut';
  mcClipCopy = 'ClipCopy';
  mcClipPaste = 'ClipPaste';
  mcClipClear = 'ClipClear';
  mcHelpKeywordSearch = 'HelpKeywordSearch';
  mcOpenFileAtCursor = 'OpenFileAtCursor';
  mcToggleBreakpoint = 'ToggleBreakpoint';
  mcRunToHere = 'RunToHere';
  mcUndo = 'Undo';
  mcRedo = 'Redo';
  mcModify = 'Modify';
  mcAddWatchAtCursor = 'AddWatchAtCursor';
  mcInspectAtCursor = 'InspectAtCursor';
  mcSetMark0 = 'setMark0';
  mcSetMark1 = 'setMark1';
  mcSetMark2 = 'setMark2';
  mcSetMark3 = 'setMark3';
  mcSetMark4 = 'setMark4';
  mcSetMark5 = 'setMark5';
  mcSetMark6 = 'setMark6';
  mcSetMark7 = 'setMark7';
  mcSetMark8 = 'setMark8';
  mcSetMark9 = 'setMark9';
  mcMoveToMark0 = 'moveToMark0';
  mcMoveToMark1 = 'moveToMark1';
  mcMoveToMark2 = 'moveToMark2';
  mcMoveToMark3 = 'moveToMark3';
  mcMoveToMark4 = 'moveToMark4';
  mcMoveToMark5 = 'moveToMark5';
  mcMoveToMark6 = 'moveToMark6';
  mcMoveToMark7 = 'moveToMark7';
  mcMoveToMark8 = 'moveToMark8';
  mcMoveToMark9 = 'moveToMark9';

  // the following constant defines the name of the IDE's editor keymapping
  // table.  This keyboard is *always* defined and should not be popped
  // from the stack.

  sEditor = 'editor';

  // The following constants define the currently available form designers.
  // Use dAny for a wizard that doesn't care under which designer
  // it is invoked.

  dVCL = 'dfm';
  dCLX = 'xfm';
  dFMX = 'fmx';
  dFMI = 'fmi';
  dVCLNet = 'nfm';
  dDotNet = '.NET';
  dHTML = 'HTML';
  dAny = 'Any';

  WizardEntryPoint = 'INITWIZARD0001';
  isWizards = 'Wizards';

  { IDE's Toolbar names }
  sCustomToolBar = 'CustomToolBar';
  sStandardToolBar = 'StandardToolBar';
  sDebugToolBar = 'DebugToolBar';
  sViewToolBar = 'ViewToolBar';
  sDesktopToolBar = 'DesktopToolBar';
  sInternetToolBar = 'InternetToolBar'; // deprecated
  sCORBAToolBar = 'CORBAToolBar'; // deprecated
  sAlignToolbar = 'AlignToolbar';
  sBrowserToolbar = 'BrowserToolbar';
  sHTMLDesignToolbar = 'HTMLDesignToolbar';
  sHTMLFormatToolbar = 'HTMLFormatToolbar';
  sHTMLTableToolbar = 'HTMLTableToolbar';
  sPersonalityToolBar = 'PersonalityToolBar';
  sPositionToolbar = 'PositionToolbar';
  sSpacingToolbar = 'SpacingToolbar';
  sIDEInsightToolbar = 'IDEInsightToolBar';
  sPlatformDeviceToolbar = 'PlatformDeviceToolBar';

  { Default IDE application/project types }
  sApplication = 'Application';
  sLibrary = 'Library';
  sConsole = 'Console';
  sPackage = 'Package';
  sStaticLibrary = 'StaticLibrary';
  sOptionSet = 'OptionSet';
//  sAndroidService = 'AndroidService';

  { Framework type strings }
  sFrameworkTypeNone = 'None';
  sFrameworkTypeVCL = 'VCL';
  sFrameworkTypeFMX = 'FMX';
  sFrameworkTypeFMI = 'FMI';
  sFrameworkTypeDotNet = 'DotNet';

  { Default IDE Module/Unit types }
  sUnit = 'Unit'; // Raw no form designer unit/C++ module and skeleton code
  sForm = 'Form'; // Unit/C++ module with a form designer
  sText = 'Text'; // Raw single file module with no skeleton code

  {Build actions types. See IOTAModuleInfo }
  sbaPCHCompile = 'PCHCompile'; // To compile header as precompiled header file in C++ 64 platform.

  { C# module/application types }
  sCSApplication = sApplication;
  sCSLibrary = sLibrary;
  sCSConsole = sConsole;
  sCSPackage = sPackage; // same as sLibrary
  sAssembly = 'Assembly'; // Equivalent to sLibrary
  sUserControl = 'UserControl'; // When used as an application type, a new user control assembly is created
                                // when used as a module type, a new user control module is created
  sClass = 'Class'; // Used to create a new module source as a generic class
  sWinForm = 'WinForm'; // Equivalent to sForm

  { C++ Application Types }
  sCppConsoleExe = 'CppConsoleApplication'; // unmanaged console application
  sCppGuiApplication = 'CppGuiApplication'; // unmanaged windows GUI application
  sCppVCLApplication = 'CppVCLApplication'; // VCL Forms Application
  sCppDynamicLibrary = 'CppDynamicLibrary'; // unmanaged dynamic-link library
  sCppPackage = 'CppPackage'; // package
  sCppStaticLibrary = 'CppStaticLibrary'; // Static library
  sCppManagedConsoleExe = 'CppManagedConsoleApp'; // managed console application
  sCppManagedDll = 'CppManagedDynamicLibrary'; // managed dynamic-link library
  sClxGuiApp = 'ClxGuiApplication';
  sFmxGuiApp = 'FmxGuiApplication';
  sFmiGuiApp = 'FmiGuiApplication';

  { TMoveCursorMasks }
  { The move cursor mask can be built from one of the following
    mmSkipWord       - Skip to the next alphanumeric character
    mmSkipNonWord    - Skip to the next non-alphanumeric character
    mmSkipWhite      - Skip to the next whitespace character (space, tab, newline)
    mmSkipNonWhite   - Skip to the next non-whitespace character
    mmSkipSpecial    - Skip to the next non-alphanumeric and non-whitespace character
    mmSkipNonSpecial - Skip to the next alphanumeric or whitespace character

    The following can be combined with any of the above
    mmSkipLeft       - Move to the left or toward the beginning of the file
    mmSkipRight      - Move to the right or toward the end of the file

    The following can be combined with any of the above
    mmSkipStream     - Ignore line ends when skipping.  When used with
                       mmSkipWhite, and the cursor is at the beginning or end
                       of a line, the cursor will continue to move until it
                       reaches a non-white character, non-EOL character, BOF or
                       EOF }
  mmSkipWord       = $00;
  mmSkipNonWord    = $01;
  mmSkipWhite      = $02;
  mmSkipNonWhite   = $03;
  mmSkipSpecial    = $04;
  mmSkipNonSpecial = $05;
  mmSkipLeft       = $00;
  mmSkipRight      = $10;
  mmSkipStream     = $20;

  { TCodeCompleteStyle }
  { The code completion style can be built from one the following
    csCodeList     - Invoke the IDE's CodeInsight Code completion function
    csParamList    - Invoke the IDE's CodeInsight Code parameters function

    One of the above can be combined with the following
    csManual       - This will cause the operation to be invoked immediately,
                     otherwise the IDE will use the delay timer set through the
                     Code Insight option before invoking the operation.
  }

  csCodelist       = $01;
  csParamList      = $02;
  csManual         = $80;

  { TKeyBindingFlags }
  { When assign a keybinding you may pass a combination of the following flags.
      NOTE: This *only* affects the terminal key (the last in a multi-key
            sequence).
    kfImplicitShift    - if the keycode is alpha, assign both the upper and
                         lower case versions.
    kfImplicitModifier - <Ctrl+k><Ctrl+b> = <Ctrl+K><b>
    kfImplicitKeypad   - When an assignment is made to a sequence with a
                         numeric keypad (Keypad) equivalent, such as PageUp,
                         a second assignment is implicitly made for the
                         equivalent
    kfLiteralChar      - Binds the literal character of the keycode instead of
                         the key that it represents. Cannot be combined with any
                         other keybinding flags.
  }
  kfImplicitShift = $01;
  kfImplicitModifier = $02;
  kfImplicitKeypad = $04;
  kfLiteralChar = $08;

  { TRipFlags }
  { When calling RipText use these flags to control the most common character
    sets to include is the text ripped from the editor.

    rfBackward               - Rip the text backward or toward the beginning of the file
    rfInvertLegalChars       - Include in ripped text characters that are *not* in the set
    rfIncludeUpperAlphaChars - Automatically include all the upper case alpha characters
    rfIncludeLowerAlphaChars - Automatically include all the lower case alpha characters
    rfIncludeAlphaChars      - Automatically include all the upper and lower case alpha characters
    rfIncludeNumericChars    - Automatically include all the numeric characters
    rfIncludeSpecialChars    - Automatically include all the special characters such as "()[]..."
  }

  rfBackward               = $0100;
  rfInvertLegalChars       = $1000;
  rfIncludeUpperAlphaChars = $0001;
  rfIncludeLowerAlphaChars = $0002;
  rfIncludeAlphaChars      = $0003;
  rfIncludeNumericChars    = $0004;
  rfIncludeSpecialChars    = $0008;

  { Possible values for TOTAModuleType }

  omtForm          = 0;
  omtDataModule    = 1;
  omtProjUnit      = 2;
  omtUnit          = 3;
  omtRc            = 4;
  omtAsm           = 5;
  omtDef           = 6;
  omtObj           = 7;
  omtRes           = 8;
  omtLib           = 9;
  omtTypeLib       = 10;
  omtPackageImport = 11;
  omtFormResource  = 12;
  omtCustom        = 13;
  omtIDL           = 14;

  sNonePersonality = PersonalityConst.sNonePersonality;
  { This is the default personality that is used to register default file
    personality traits. }
  sDefaultPersonality = PersonalityConst.sDefaultPersonality;
  { The following are Borland created personalities }
  sDelphiPersonality = PersonalityConst.sDelphiPersonality;
  sDelphiDotNetPersonality = PersonalityConst.sDelphiDotNetPersonality;
  sCBuilderPersonality = PersonalityConst.sCBuilderPersonality;
  sCSharpPersonality = PersonalityConst.sCSharpPersonality;
  sVBPersonality = PersonalityConst.sVBPersonality;
  sDesignPersonality = PersonalityConst.sDesignPersonality;
  sGenericPersonality = PersonalityConst.sGenericPersonality;


  { Gallery Categories }
  { You can now add your wizards to specific categories in the Gallery.
    You must first register or find your category before using it.
    The following categories will (probably) exist. }
  sCategoryRoot = 'Borland.Root';
  sCategoryGalileoOther = 'Borland.Galileo.Other';
  sCategoryDelphiNew = 'Borland.Delphi.New';
  sCategoryDelphiNewFiles = 'Borland.Delphi.NewFiles';
  sCategoryDelphiDotNetNew = 'Borland.Delphi.NET.New';
  sCategoryDelphiDotNetNewFiles = 'Borland.Delphi.NET.NewFiles';
  sCategoryCBuilderNew = 'Borland.CBuilder.New';
  sCategoryCBuilderNewFiles = 'Borland.CBuilder.NewFiles';
  sCategoryCurrentProject = 'Borland.CurrentProject';
  sCategoryCSharpNew = 'Borland.CSharp.New';
  sCategoryCSharpNewFiles = 'Borland.CSharp.NewFiles';
  sCategoryMarkupNew = 'Borland.Markup.New';
  sCategoryMarkupNewFiles = 'Borland.Markup.NewFiles';
  sCategoryVBNew = 'Borland.VB.New';
  sCategoryVBNewFiles = 'Borland.VB.NewFiles';
  sCategoryNewUnitTest = 'UnitTest.Test';

  sCategoryDelphiWindows = 'Borland.Delphi.Windows';
  sCategoryDelphiMultiDevice = 'Borland.Delphi.MultiDevice';
  sCategoryDelphiRADServer = 'Borland.Delphi.RADServer';
  sCategoryDelphiWeb = 'Borland.Delphi.Web';
  sCategoryDelphiIndividualFiles = 'Borland.Delphi.IndividualFiles';
  sCategoryDelphiDatabase = 'Borland.Delphi.Database';
  sCategoryDelphiActiveX = 'Borland.Delphi.ActiveX';

  sCategoryCBuilderWindows = 'Borland.CBuilder.Windows';
  sCategoryCBuilderMultiDevice = 'Borland.CBuilder.MultiDevice';
  sCategoryCBuilderRADServer = 'Borland.CBuilder.RADServer';
  sCategoryCBuilderWeb = 'Borland.CBuilder.Web';
  sCategoryCBuilderIndividualFiles = 'Borland.CBuilder.IndividualFiles';
  sCategoryCBuilderDatabase = 'Borland.CBuilder.Database';
  sCategoryCBuilderActiveX = 'Borland.CBuilder.ActiveX';

  { IOTAEditOptions now are associated with file types. See
    IOTAEditorServices for more information }
  cDefEdOptions = 'Borland.EditOptions.';
  cDefEdDefault = cDefEdOptions + 'Default';
  cDefEdPascal = cDefEdOptions + 'Pascal';
  cDefEdC = cDefEdOptions + 'C';
  cDefEdObjCpp = cDefEdOptions + 'ObjectiveC++';
  cDefEdCSharp = cDefEdOptions + 'C#';
  cDefEdHTML = cDefEdOptions + 'HTML';
  cDefEdXML = cDefEdOptions + 'XML';
  cDefEdSQL = cDefEdOptions + 'SQL';
  cDefEdIDL = cDefEdOptions + 'IDL';
  cDefEdVisualBasic = cDefEdOptions + 'VisualBasic';
  cDefEdJavaScript = cDefEdOptions + 'JavaScript';
  cDefEdStyleSheet = cDefEdOptions + 'StyleSheet';
  cDefEdINI = cDefEdOptions + 'INI';
  cDefEdPHP = cDefEdOptions + 'PHP';

  { Designer command string constants.  These are strings so that new commands
    can be added without affecting the interfaces.  This allows commands to be
    added without affecting the IDE core. }

  dcAlign = 'Align';
  dcSize = 'Size';
  dcScale = 'Scale';
  dcTabOrder = 'TabOrder';
  dcCreationOrder = 'CreationOrder';
  dcLockControls = 'LockControls';
  dcFlipChildrenAll = 'FlipChildrenAll';
  dcFlipChildrenSelected = 'FilpChildrenSelected';
  dcToggleNonVisualComponentVisibility = 'ToggleNonVisualComponentVisibility';

  { Use these constants calling INTAEditWindow.CreateDockableForm in order to
    fulfill a loose contract with all personalities who wish to implement a
    specific type of functionality.  For instance, a personality (or group of
    personalities) may ask to create a Borland.CodeExplorer dockable window.
    Then all subsequent personalities that ask to the Borland.CodeExplorer will
    get this same window.  This allows a *type* of window to share the same
    space with all the other personalities. }

  sBorlandEditorCodeExplorer = 'BorlandEditorCodeExplorer';

 { Some of the preset identifers that could be passed to
  INTAProjectMenuCreatorNotifier.  Other values could be file names.
 }
  sBaseContainer = 'BaseContainer';
  sFileContainer = 'FileContainer';
  sProjectContainer = 'ProjectContainer';
  sProjectGroupContainer = 'ProjectGroupContainer';
  sCategoryContainer = 'CategoryContainer';
  sDirectoryContainer = 'DirectoryContainer';
  sReferencesContainer = 'References';
  sContainsContainer = 'Contains';
  sRequiresContainer = 'Requires';
  sVirtualFoldContainer = 'VirtualFold';
  sBuildConfigContainer = 'BuildConfig';
  sOptionSetContainer = 'OptionSet';
  sTargetPlatformContainer = 'TargetPlatformContainer';

  vvfPrivate = $00;
  vvfProtected = $01;
  vvfPublic = $02;
  vvfPublished = $03;
  vvfVisMask = $04;
  vvfDeprecated = $08;

  sBaseConfigurationKey = 'Base';

  sBT_BuildType = 'BT_BuildType';
  { Build types }
  cbtiOSDeviceDebug = 'Debug';
  cbtiOSDeviceAdhoc = 'Adhoc';
  cbtiOSDeviceAppStore = 'AppStore';


  { These constants can be used to specify the priority of an INTACustomEditorSubView }
  svpHighest = Low(Integer);
  svpHigh = -255;
  svpNormal = 0;
  svpLow = 255;
  svpLowest = High(Integer);

  { Project manager menu item position constants.  Menus are built in numeric order }
  pmmpBuildSection = 1000000;
  pmmpCompile = pmmpBuildSection + 100;

  pmmpMake = pmmpBuildSection + 100;
  pmmpBuild = pmmpBuildSection + 1010;
  pmmpBuildFile = pmmpBuild;
  pmmpClean = pmmpBuildSection + 1030;
  pmmpLink = pmmpBuildSection + 1040;

  pmmpFromHere = pmmpBuildSection + 5000;
  pmmpCompileFromHere = pmmpBuildSection + 5010;
  pmmpMakeFromHere = pmmpBuildSection + 5020;
  pmmpBuildFromHere = pmmpBuildSection + 5030;
  pmmpCleanFromHere = pmmpBuildSection + 5040;

  pmmpMakeAll = pmmpBuildSection + 5100;
  pmmpCompileAll = pmmpBuildSection + 5110;
  pmmpBuildAll = pmmpBuildSection + 5120;
  pmmpCleanAll = pmmpBuildSection + 5130;

  pmmpRunSeparator = pmmpBuildSection + 6000;
  pmmpRun = pmmpBuildSection + 6010;
  pmmpRunNoDebug = pmmpBuildSection + 6020;

  pmmpInstallSeparator = pmmpBuildSection + 7000;
  pmmpInstall = pmmpBuildSection + 7010;
  pmmpUninstall = pmmpBuildSection + 7020;

  pmmpLocalBuildCmdsSeparator = pmmpBuildSection + 8000;
  pmmpLocalBuildCmds = pmmpBuildSection + 8100;
  pmmpPreprocess = pmmpBuildSection + 8110;
  pmmpCompileToAsm = pmmpBuildSection + 8150;
  pmmpDump = pmmpBuildSection + 8160;
  pmmpShowDependencies = pmmpBuildSection + 8170;

  pmmpBuildSoonerSeparator = pmmpBuildSection + 10000;
  pmmpBuildSooner = pmmpBuildSection + 10010;
  pmmpBuildLater = pmmpBuildSection + 10020;

  // -------------------

  pmmpOpenSection = 2000000;
  pmmpOpen = pmmpOpenSection + 100;

  pmmpOpenAsText = pmmpOpenSection + 200;
  pmmpClose = pmmpOpenSection + 300;
  pmmpExplore = pmmpOpenSection + 450;

  // -------------------

  pmmpAddSection = 3000000;
  pmmpAdd = pmmpAddSection + 100;

  pmmpAddNew = pmmpAddSection + 200;
  pmmpAddItemToProject = pmmpAddSection + 500;
  pmmpAddComponent = pmmpAddSection + 1000;
  pmmpAddReference = pmmpAddSection + 1100;
  pmmpAddFolder = pmmpAddSection + 2000;

  pmmpCreateNewTarget = pmmpAddSection + 5000;
  pmmpAddToProjectGroup = pmmpCreateNewTarget;
  pmmpAddExistingTarget = pmmpAddSection + 5010;

  // -------------------

  pmmpRemoveSection = 4000000;

  pmmpRemove = pmmpRemoveSection + 100;
  pmmpRemoveItem = pmmpRemove + 200;
  pmmpExcludeFromBuild = pmmpRemove + 300;
  pmmpRemoveFolder = pmmpRemove + 400;
  pmmpRemoveProjects = pmmpRemove + 500;

  // -------------------

  pmmpSaveSection = 5000000;

  pmmpSave = pmmpSaveSection + 100;
  pmmpSaveGroup = pmmpSave;
  pmmpSaveAs = pmmpSaveSection + 200;
  pmmpSaveGroupAs = pmmpSaveAs;

  // -------------------

  pmmpRenameSection = 6000000;

  pmmpRename = pmmpRenameSection + 100;
  pmmpRenameGroup = pmmpRename;
  pmmpDelete = pmmpRenameSection + 200;

  // -------------------

  pmmpVersionControlSection = 7000000;
  pmmpVersionControl = pmmpVersionControlSection + 100;

  // -------------------

  pmmpUtilsSection = 8000000;

  pmmpActivate = pmmpUtilsSection + 100;
  pmmpViewSource = pmmpUtilsSection + 150;

  pmmpSortBuildOrder = pmmpUtilsSection + 1000;
  pmmpSort = pmmpUtilsSection + 1000;
  pmmpSortName = pmmpUtilsSection + 1001;
  pmmpSortModified = pmmpUtilsSection + 1002;
  pmmpSortType = pmmpUtilsSection + 1003;
  pmmpSortPath = pmmpUtilsSection + 1004;
  pmmpSortAuto = pmmpUtilsSection + 1100;
  pmmpDependencies = pmmpUtilsSection + 5000;
  pmmpUseForPrecompiling = pmmpUtilsSection + 6000;

  // -------------------

  pmmpReorderSection = 9000000;
  pmmpReorder = pmmpReorderSection + 100;
  pmmpBuildOrder = pmmpReorderSection + 1000;

  // -------------------

  pmmpOptionsSection = 10000000;
  pmmpFolderOptions = pmmpOptionsSection + 100;
  pmmpRemoveLocalOptions = pmmpOptionsSection + 200;
  pmmpEditLocalOptions = pmmpOptionsSection + 201;
  pmmpProjectOptions = pmmpOptionsSection + 90000;

  // -------------------

  pmmpBuildConfig = 11000000;

  { Base user offset }
  pmmpUserOffset = 500000;

  { These constants should be used by addins in order to avoid collisions with built-in menu items.
    If a collision occurs, the order of the menu items may not be predictable }
  pmmpUserBuild = pmmpBuildSection + pmmpUserOffset;
  pmmpUserOpen = pmmpOpenSection + pmmpUserOffset;
  pmmpUserAdd = pmmpAddSection + pmmpUserOffset;
  pmmpUserRemove = pmmpRemoveSection + pmmpUserOffset;
  pmmpUserSave = pmmpSaveSection + pmmpUserOffset;
  pmmpUserRename = pmmpRenameSection + pmmpUserOffset;
  pmmpUserVersionControl = pmmpVersionControl + pmmpUserOffset;
  pmmpUserUtils = pmmpUtilsSection + pmmpUserOffset;
  pmmpUserReorder = pmmpReorderSection + pmmpUserOffset;
  pmmpUserOptions = pmmpOptionsSection + pmmpUserOffset;
  pmmpUserBuildConfig = pmmpUserOffset + pmmpBuildConfig;

  { Constants used to describe what changed when the user edits a Code Insight
    Manager. }
  icNameChanged        = $0001;
  icExecutableChanged  = $0002;
  icLanguageChanged    = $0004;
  icTimeoutChanged     = $0008;
  icInitOptionChanged  = $0010;
  icExtChanged         = $0020;
  icEnabled            = $0040;
  icDisabled           = $0080;


type
  /// <summary>
  /// ENonAIRException exceptions, when unhandled, will not show the user an exception
  /// dialog with a stack trace and will not allow the user to submit an Automated
  /// Incident Report (AIR) to Quality Central.  Exceptions in IDE addins that are
  /// intentionally left unhandled should be of this type (or of a type that is
  /// derived from this type) 
  /// </summary>
  ENonAIRException = class(Exception);

  ///<summary>
  /// Exception class raised for any Personality Manager related exceptions
  ///</summary>
  EPersonalityException = class(ENonAIRException);

  ///<summary>
  /// Describes the action performed during a build
  ///</summary>
  TOTACompileMode = (
    /// <summary>Builds only sources that have changed since the last build or make. </summary>
    cmOTAMake, 
    /// <summary>Builds all sources regardless of whether they have change. </summary>
    cmOTABuild, 
    /// <summary>Verify that there are no syntax errors w/o generating any output files.  </summary>
    cmOTACheck, 
    /// <summary>Builds only one unit.  </summary>
    cmOTAMakeUnit,
    /// <summary>Remove all output files generated when building. </summary>
    cmOTAClean,
    /// <summary>Link intermediates files into final output. </summary>
    cmOTALink
  );


  ///<summary>
  /// Describes the result for a compile/build
  ///</summary>
  TOTACompileResult = (
    /// <summary>the compile/build failed. </summary>
    crOTAFailed, 
    /// <summary>the compile/build was successful. </summary>
    crOTASucceeded, 
    /// <summary>
    /// the compile/build was started in a background thread.
    /// Register an IOTACompileNotifier to be informed when it is finished
    /// </summary>
    crOTABackground
  );

  TOTAModuleType = type Integer;
  TOTAHandle = Pointer;
  TOTAAddress = UInt64;  

  TOTAToDoPriority = 0..5;

  /// <summary>
  /// Editor position expressed as column/line after tabs are expanded to spaces
  /// and include the &quot;virtual&quot; editor space (columns beyond the end of lines) 
  /// </summary>
  TOTAEditPos = packed record
    Col: SmallInt; { Col is one-based }
    Line: Longint; { Line is one-based }
  end;

  /// <summary>
  /// Editor position expressed as character index/line before tabs are expanded
  /// and does not include the indices beyond the end of a line 
  /// </summary>
  TOTACharPos = packed record
    CharIndex: SmallInt; { CharIndex is zero-based }
    Line: Longint; { Line is one-based }
  end;

  /// <summary>
  /// Available option name expressed as a name and a type 
  /// </summary>
  TOTAOptionName = record
    Name: string;
    Kind: TTypeKind;
  end;

  /// <summary>
  /// Dynamic array of option names 
  /// </summary>
  TOTAOptionNameArray = array of TOTAOptionName;

{$IFDEF MSWINDOWS}
  TOTAThreadContext = Winapi.Windows.TContext deprecated;

  TOTAM128A = record
    Low: UInt64;
    High: Int64;
  end;

  TOTAXMM_SAVE_AREA32 = record
    ControlWord: WORD;
    StatusWord: WORD;
    TagWord: Byte;
    Reserved1: Byte;
    ErrorOpcode: WORD;
    ErrorOffset: DWORD;
    ErrorSelector: WORD;
    Reserved2: WORD;
    DataOffset: DWORD;
    DataSelector: WORD;
    Reserved3: WORD;
    MxCsr: DWORD;
    MxCsr_Mask: DWORD;
    FloatRegisters: array[0..7] of TOTAM128A;
    XmmRegisters: array[0..15] of TOTAM128A;
    Reserved4: array[0..95] of Byte;
  end;

  TOTAContextWin32 = Winapi.Windows.TContext;
  TOTAContextOSX32 = Winapi.Windows.TContext;

  TOTAContextWin64 = record
    P1Home: DWORD64;
    P2Home: DWORD64;
    P3Home: DWORD64;
    P4Home: DWORD64;
    P5Home: DWORD64;
    P6Home: DWORD64;
    ContextFlags: DWORD;
    MxCsr: DWORD;
    SegCs: WORD;
    SegDs: WORD;
    SegEs: WORD;
    SegFs: WORD;
    SegGs: WORD;
    SegSs: WORD;
    EFlags: DWORD;
    Dr0: DWORD64;
    Dr1: DWORD64;
    Dr2: DWORD64;
    Dr3: DWORD64;
    Dr6: DWORD64;
    Dr7: DWORD64;
    Rax: DWORD64;
    Rcx: DWORD64;
    Rdx: DWORD64;
    Rbx: DWORD64;
    Rsp: DWORD64;
    Rbp: DWORD64;
    Rsi: DWORD64;
    Rdi: DWORD64;
    R8: DWORD64;
    R9: DWORD64;
    R10: DWORD64;
    R11: DWORD64;
    R12: DWORD64;
    R13: DWORD64;
    R14: DWORD64;
    R15: DWORD64;
    Rip: DWORD64;
    case Integer of
      0: (
        FltSave: TOTAXMM_SAVE_AREA32;
        VectorRegister: array[0..25] of TOTAM128A; 
        VectorControl: DWORD64;
        DebugControl: DWORD64; 
        LastBranchToRip: DWORD64;
        LastBranchFromRip: DWORD64;
        LastExceptionToRip: DWORD64;
        LastExceptionFromRip: DWORD64);
      1: (
        Header: array[0..1] of TOTAM128A;
        Legacy: array[0..7] of TOTAM128A;
        Xmm0: TOTAM128A;
        Xmm1: TOTAM128A;
        Xmm2: TOTAM128A;
        Xmm3: TOTAM128A;
        Xmm4: TOTAM128A;
        Xmm5: TOTAM128A;
        Xmm6: TOTAM128A;
        Xmm7: TOTAM128A;
        Xmm8: TOTAM128A;
        Xmm9: TOTAM128A;
        Xmm10: TOTAM128A;
        Xmm11: TOTAM128A;
        Xmm12: TOTAM128A;
        Xmm13: TOTAM128A;
        Xmm14: TOTAM128A;
        Xmm15: TOTAM128A);
  end;

  TOTAContextOSX64 = TOTAContextWin64;


  TOTAContextARM32 = record
    R0: DWORD;
    R1: DWORD;
    R2: DWORD;
    R3: DWORD;
    R4: DWORD;
    R5: DWORD;
    R6: DWORD;
    R7: DWORD;
    R8: DWORD;
    R9: DWORD;
    R10: DWORD;
    R11: DWORD;
    R12: DWORD;
    Sp: DWORD;    
    Lr: DWORD;
    Pc: DWORD;
    Cpsr: DWORD;
  end;

  TOTAContextARM64 = record
    X0: DWORD64;
    X1: DWORD64;
    X2: DWORD64;
    X3: DWORD64;
    X4: DWORD64;
    X5: DWORD64;
    X6: DWORD64;
    X7: DWORD64;
    X8: DWORD64;
    X9: DWORD64;
    X10: DWORD64;
    X11: DWORD64;
    X12: DWORD64;
    X13: DWORD64;
    X14: DWORD64;
    X15: DWORD64;
    X16: DWORD64;
    X17: DWORD64;
    X18: DWORD64;
    X19: DWORD64;
    X20: DWORD64;   
    X21: DWORD64;
    X22: DWORD64;
    X23: DWORD64;
    X24: DWORD64;
    X25: DWORD64;
    X26: DWORD64;
    X27: DWORD64;
    X28: DWORD64;
    Fp: DWORD64;
    Lr: DWORD64;
    Sp: DWORD64;
    Pc: DWORD64;
    Cpsr: DWORD64;
  end;

  TOTAThreadContextEx = record
    case Integer of
      0: (win32: TOTAContextWin32);
      1: (osx32: TOTAContextOSX32);
      2: (win64: TOTAContextWin64);
      3: (arm32: TOTAContextARM32);
      4: (arm64: TOTAContextARM64);
      5: (osx64: TOTAContextOSX64);
  end;

{$ENDIF}
{$IFDEF LINUX}
  TFloatingSaveArea = record
    ControlWord: DWORD;
    StatusWord: DWORD;
    TagWord: DWORD;
    ErrorOffset: DWORD;
    ErrorSelector: DWORD;
    DataOffset: DWORD;
    DataSelector: DWORD;
    RegisterArea: array[0..79] of Byte;
    Cr0NpxState: DWORD;
  end;

  TOTAThreadContext = record
    ContextFlags: DWORD;
    Dr0: DWORD;
    Dr1: DWORD;
    Dr2: DWORD;
    Dr3: DWORD;
    Dr6: DWORD;
    Dr7: DWORD;
    FloatSave: TFloatingSaveArea;
    SegGs: DWORD;
    SegFs: DWORD;
    SegEs: DWORD;
    SegDs: DWORD;
    Edi: DWORD;
    Esi: DWORD;
    Ebx: DWORD;
    Edx: DWORD;
    Ecx: DWORD;
    Eax: DWORD;
    Ebp: DWORD;
    Eip: DWORD;
    SegCs: DWORD;
    EFlags: DWORD;
    Esp: DWORD;
    SegSs: DWORD;
  end;
{$ENDIF}

  TOTAXMMReg = packed record
    case Integer of
      0: (ByteReg: packed array[0..15] of Byte);
      1: (WordReg: packed array[0..7] of Word);
      2: (LongReg: packed array[0..3] of LongWord);
      3: (Int64Reg: packed array[0..1] of Int64);
      4: (UInt64Reg: packed array[0..1] of UInt64);
      5: (SingleReg: packed array[0..3] of Single);
      6: (DoubleReg: packed array[0..1] of Double);
  end;

  TOTAXMMRegs = packed record
    XMM0: TOTAXMMReg;
    XMM1: TOTAXMMReg;
    XMM2: TOTAXMMReg;
    XMM3: TOTAXMMReg;
    XMM4: TOTAXMMReg;
    XMM5: TOTAXMMReg;
    XMM6: TOTAXMMReg;
    XMM7: TOTAXMMReg;
    XMM8: TOTAXMMReg;
    XMM9: TOTAXMMReg;
    XMM10: TOTAXMMReg;
    XMM11: TOTAXMMReg;
    XMM12: TOTAXMMReg;
    XMM13: TOTAXMMReg;
    XMM14: TOTAXMMReg;
    XMM15: TOTAXMMReg;
    MXCSR: LongWord;
  end;

  IOTAProject = interface;
  IOTAModule = interface;
  IOTANotifier = interface;
  IOTAEditView = interface;
  IOTAEditBuffer = interface;
  IOTAFormEditor = interface;
  IOTAComponent = interface;
  IBorlandIDEServices = interface;
  IOTAEditOptions = interface;
  IOTAEditorServices = interface;
  IOTAKeyboardServices = interface;
  IOTAKeyContext = interface;
  IOTAEditBlock = interface;
  IOTABuildConfiguration = interface;

  /// <summary>
  /// TBindingType - Indicates to the IDE how to manage this keybinding interface
  ///  btComplete  - This keybinding defines a complete keybinding for the editor.
  ///                It is mutually exclusive of *all* other btComplete bindings.
  ///                All pre-defined internal keymaps are btComplete.
  ///  btPartial   - This binding only implements a partial binding.  Many of
  ///                these may be registered and enabled as the user selects.  The
  ///                order of registration is determined by the user through the
  ///                IDE in the Tools|Editor Options dialog, Key Mappings page.
  ///   
  /// </summary>
  TBindingType = (btComplete, btPartial);

  /// <summary>
  /// TKeyBindingResult
  /// krUnhandled - Return this if the key is not to be handled by this proc.
  ///               Will execute the next handler assigned to this key.  This will
  ///               also allow any menu shortcuts to execute if no other handlers
  ///               handle the key.
  /// krHandled   - This proc handled the key and no further processing is
  ///               required.  No menu shortcuts will be processed
  /// krNextProc  - This proc handled the key but execute the next handler if one
  ///               exists. No menu shortcuts will be processed 
  /// </summary>
  TKeyBindingResult = (krUnhandled, krHandled, krNextProc);

  /// <summary>
  /// Keybinding proc 
  /// </summary>
  TKeyBindingProc = procedure (const Context: IOTAKeyContext; KeyCode: TShortcut;
    var BindingResult: TKeyBindingResult) of object;

  TMoveCursorMasks = Byte;

  /// <summary>
  /// TSearchDirection 
  /// </summary>
  TSearchDirection = (sdForward, sdBackward);

  /// <summary>
  /// IOTAStrings 
  /// Base interface for typical TStrings access. 
  /// </summary>
  IOTAStrings = interface(IInterface)
    ['{36A00C9A-58D9-42EE-8B10-478C1B6691E8}']
    procedure Assign(const Strings: IOTAStrings);
    function GetCount: Integer;
                                                                                
    function GetData(const Index: Integer): Integer;
    function GetItem(const Index: Integer): string;
    function GetName(const Index: Integer): string;
    function GetValue(const Name: string): string;
    function GetValueFromIndex(const Index: Integer): string;
                                                                                
    procedure SetData(const Index: Integer; Value: Integer);
    procedure SetItem(const Index: Integer; const Value: string);
    procedure SetValue(const Name, Value: string);
    procedure SetValueFromIndex(const Index: Integer; const Value: string);

    property Count: Integer read GetCount;
    property Data[const Index: Integer]: Integer read GetData write SetData;
    property Items[const Index: Integer]: string read GetItem write SetItem;
    property Names[const Index: Integer]: string read GetName;
    property Values[const Name: string]: string read GetValue write SetValue;
    property ValueFromIndex[const Index: Integer]: string read GetValueFromIndex write SetValueFromIndex;
  end;

  INTAStrings = interface(IOTAStrings)
    ['{FDAFB316-82E7-47B3-A282-D7605ADF2AAF}']
    function GetStrings: TStrings;

    property Strings: TStrings read GetStrings;
  end;

  IOTANotifier = interface(IUnknown)
    ['{F17A7BCF-E07D-11D1-AB0B-00C04FB16FB3}']
    /// <summary>
    /// This procedure is called immediately after the item is successfully saved.
    /// This is not called for IOTAWizards 
    /// </summary>
    procedure AfterSave;
    /// <summary>
    /// This function is called immediately before the item is saved. This is not
    /// called for IOTAWizard 
    /// </summary>
    procedure BeforeSave;
    /// <summary>
    /// The associated item is being destroyed so all references should be dropped.
    /// Exceptions are ignored. 
    /// </summary>
    procedure Destroyed;
    /// <summary>
    /// This associated item was modified in some way. This is not called for
    /// IOTAWizards 
    /// </summary>
    procedure Modified;
  end;

  IOTAEditorNotifier = interface(IOTANotifier)
    ['{0E3B9D7B-E119-11D1-AB0C-00C04FB16FB3}']
    /// <summary>
    /// Called when a new edit view is created(opInsert) or destroyed(opRemove) 
    /// </summary>
    procedure ViewNotification(const View: IOTAEditView; Operation: TOperation);
    /// <summary>
    /// Called when a view is activated 
    /// </summary>
    procedure ViewActivated(const View: IOTAEditView);
  end;

  IOTAFormNotifier = interface(IOTANotifier)
    ['{0E3B9D7C-E119-11D1-AB0C-00C04FB16FB3}']
    /// <summary>
    /// Called when the given form is activated 
    /// </summary>
    procedure FormActivated;
    /// <summary>
    /// This is called immediately prior to the form being streamed out.  This
    /// may be called without first getting a BeforeSave as in the case of
    /// the project being compiled. 
    /// </summary>
    procedure FormSaving;
    /// <summary>
    /// Called when a component on this form was renamed 
    /// </summary>
    procedure ComponentRenamed(ComponentHandle: TOTAHandle;
      const OldName, NewName: string);
  end;

  IOTAEditor = interface(IUnknown)
    ['{F17A7BD0-E07D-11D1-AB0B-00C04FB16FB3}']
    /// <summary>
    /// Call this to register an IOTANotifier. The result is the index to be
    /// used when calling RemoveNotifier. If &lt;0 then an error occurred. 
    /// </summary>
    function AddNotifier(const ANotifier: IOTANotifier): Integer;
    /// <summary>
    /// Returns the actual filename of this module editor. Rename through
    /// IOTAModule
    /// </summary>
    function GetFileName: string;
    /// <summary>
    /// Returns the editor specific modified status 
    /// </summary>
    function GetModified: Boolean;
    /// <summary>
    /// Returns the associated IOTAModule 
    /// </summary>
    function GetModule: IOTAModule;
    /// <summary>
    /// Mark this editor modified.  The associated module will also be modified 
    /// </summary>
    function MarkModified: Boolean;
    /// <summary>
    /// Call with the index obtained from AddNotifier 
    /// </summary>
    procedure RemoveNotifier(Index: Integer);
    /// <summary>
    /// Show this editor.  If no views are active, at least one will be created 
    /// </summary>
    procedure Show;

    property FileName: string read GetFileName;
    property Modified: Boolean read GetModified;
    property Module: IOTAModule read GetModule;
  end;

  /// <summary>
  /// If an IOTAEditor implements this interface, then it supports direct access
  /// to the memory buffer used to store the editor content 
  /// </summary>
  IOTAEditorContent = interface(IInterface)
    ['{748FB436-59B9-495D-8AC8-807CF6622967}']
    /// <summary>
    /// Returns the current buffer content for the corresponding editor 
    /// </summary>
    function GetContent: IStream;
    /// <summary>
    /// Sets the current buffer content for the corresponding editor.  NOTE:
    /// this will do a wholesale replacement of the content and all previous
    /// contents *will* be lost.  Use this at your own risk. You have been warned 
    /// </summary>
    procedure SetContent(const AStream: IStream);
    /// <summary>
    /// Returns the current age of the buffer.  This is the datetime of the last
    /// actual modification of the file.  If the file has not been modified or has
    /// already been saved, this will match the file time on disk. 
    /// </summary>
    function GetContentAge: TDateTime;
    /// <summary>
    /// Call this function to reset the internal setting of the editor's content
    /// disk age value.  The disk age is the age of the time when it was initially
    /// loaded from disk or the last time the file was saved. 
    /// </summary>
    procedure ResetDiskAge;

    property Content: IStream read GetContent write SetContent;
  end;

  IOTAToolsFilterNotifier = interface(IOTANotifier)
    ['{CEF1F13A-E877-4F20-88F2-F7E2BA61AAF4}']
    /// <summary>
    /// Used by tools filter to fill message view with build result information.
    /// FileName is the name of the file that was compiled.
    /// ErrorCode is the error code result from the compile.
    /// StdOut is a string list of the standard out while the tool was executed.
    /// StdError is a string list of the standard error while the tool was executed. 
    /// </summary>
    procedure Filter(FileName: string; ErrorCode: Integer;
      StdOut, StdError: TStrings);
    /// <summary>
    /// Should return a unique name for the filter. 
    /// </summary>
    function GetFilterName: string;
  end;

  /// <summary>
  /// IOTAToolsFilter60 is deprecated.  Since the introduction of MSBuild, this
  /// interface is no longer supported. 
  /// </summary>
  IOTAToolsFilter60 = interface(IUnknown)
    ['{8864B891-9B6D-4002-BB2E-1D6E59BFA49A}']
    /// <summary>
    /// Call this to register an IOTANotifier. The result is the index to be
    /// used when calling RemoveNotifier. If &lt;0 then an error occurred. 
    /// </summary>
    function AddNotifier(const ANotifier: IOTANotifier): Integer; deprecated;
    /// <summary>
    /// Call with the index obtained from AddNotifier 
    /// </summary>
    procedure RemoveNotifier(Index: Integer); deprecated;
  end;

  /// <summary>
  /// IOTAToolsFilter60 is deprecated.  Since the introduction of MSBuild, this
  /// interface is no longer supported. 
  /// </summary>
  IOTAToolsFilter = interface(IOTAToolsFilter60)
    ['{891B2757-FC6F-4DE9-B653-F55A52733324}']
    function FindFilter(const Name: string): IUnknown; deprecated;
  end;

  /// <summary>
  /// Use the IOTAEditReader class to gain read access to an editor buffer:
  /// 
  /// NOTES:
  ///  o The buffer is accessed as a linear &quot;file&quot; with line breaks included.
  ///  o This reader interface could be accessed through a custom read-only
  ///    TStream descendant.
  ///  o &quot;Buffer&quot; will contain UTF8-encoded data if the editor contains Unicode
  ///    characters
  /// 
  /// WARNING!!!
  ///  o An IOTAEditReader should never be active at the same time as an IOTAEditWriter.
  ///   
  /// </summary>

  IOTAEditReader = interface(IUnknown)
    ['{26EB0E4F-F97B-11D1-AB27-00C04FB16FB3}']
    function GetText(Position: Longint; Buffer: PAnsiChar; Count: Longint): Longint;
  end;

  /// <summary>
  /// Use the IOTAEditWriter class to gain write access to an editor buffer:
  /// 
  /// NOTES:
  ///  o As with the reader, the buffer is accessed as a linear &quot;file&quot; with
  ///    line breaks included.  The writer uses a &quot;copy in place&quot; metaphor for
  ///    modifying the editor buffer.  In other words, the writer can be thought
  ///    of as simply copying from one buffer to another.  All positions (Pos)
  ///    passed to the function are positions relative to the original file.  Due
  ///    to the &quot;copy&quot; metaphor of the writer it does not support moving backward
  ///    in the editor buffer. It is recommended that all modifications that must
  ///    be performed should be done from the start to the finish.
  ///  o After the IOTAEditWriter is released, the undo-buffer of the editor
  ///    is flushed unless CreateUndoableWriter was called to obtain the
  ///    IOTAEditWriter.
  ///  o To insert Unicode text using the &quot;Insert&quot; method, the &quot;Text&quot; parameter
  ///    should be UTF8-encoded.
  /// 
  /// WARNING!!!
  ///  o An IOTAEditWriter should never be active at the same time as an IOTAEditReader.
  ///   
  /// </summary>

  IOTAEditWriter = interface(IUnknown)
    ['{26EB0E50-F97B-11D1-AB27-00C04FB16FB3}']
    procedure CopyTo(Pos: Longint);
    procedure DeleteTo(Pos: Longint);
    procedure Insert(Text: PAnsiChar);
    function Position: Longint;
    function GetCurrentPos: TOTACharPos;

    property CurrentPos: TOTACharPos read GetCurrentPos;
  end;

  /// <summary>
  /// TOTASyntaxHighlighter is deprecated 
  /// </summary>
  TOTASyntaxHighlighter = (shNone = 0,
                           shQuery = 1,
                           shPascal = 2,
                           shC = 3,
                           shSQL = 4,
                           shIDL = 5,
                           shMax = $FF);

  /// <summary>
  /// 
  /// TOTASyntaxCode:
  ///   The values which should be used with this type are defined in ToolsAPI as:
  ///     atWhiteSpace     = 0;
  ///     atComment        = 1;
  ///     atReservedWord   = 2;
  ///     atIdentifier     = 3;
  ///     etc...
  /// 
  ///     Do not exceed SyntaxOff
  ///   
  /// </summary>
  POTASyntaxCode = ^TOTASyntaxCode;
  TOTASyntaxCode = Byte;
  /// <summary>
  /// 
  /// TOTALineClass:
  ///   The value which is used for this type in the Highlighter interfaces is
  ///   user definable (it is used to gain context for lines).
  ///   
  /// </summary>
  TOTALineClass  = Byte;
  {$IFDEF FATCHAR}
  OTAEdChar = WideChar;
  POTAEdChar = PWideChar;
  {$ELSE}
  OTAEdChar = AnsiChar;
  POTAEdChar = PAnsiChar;
  {$ENDIF}
  /// <summary>
  /// 
  /// TOTALineSize:
  ///   Length of line buffer to be tokenized.
  ///   
  /// </summary>
  TOTALineSize = Word;

  IOTAHighlighter = interface(IOTANotifier)
    ['{79D28DA1-42F6-44B9-AE33-D001FD75DC40}']
    function GetIDString: string;
    function GetName: string;
    procedure Tokenize(StartClass: TOTALineClass; LineBuf: POTAEdChar;
      LineBufLen: TOTALineSize; HighlightCodes: POTASyntaxCode);
    function TokenizeLineClass(StartClass: TOTALineClass;
      LineBuf: POTAEdChar; LineBufLen: TOTALineSize): TOTALineClass;
    property Name: string read GetName;
    property IDString: string read GetIDString;
  end;

  /// <summary>
  /// If an IOTAHighlighter implements IOTAHighlighterPreview, a
  /// preview of that highlighter's code will be shown in the color page. 
  /// </summary>
  IOTAHighlighterPreview = interface
    ['{86A7ABCC-F81C-479D-B25D-C105F0DF1254}']
    /// <summary>
    /// The display name for the source sample 
    /// </summary>
    function GetDisplayName: string;
    /// <summary>
    /// SampleText to highlight 
    /// </summary>
    function GetSampleText: string;
    /// <summary>
    /// Retrieve the line for current settings. Return -1 to not show it. 
    /// </summary>
    function GetInvalidBreakpointLine: Integer;
    function GetCurrentInstructionLine: Integer;
    function GetValidBreakpointLine: Integer;
    function GetDisabledBreakpointLine: Integer;
    function GetErrorLine: Integer;
    /// <summary>
    /// Sample text to search for in order to show it as highlighted.
    /// Return an empty string to not support it 
    /// </summary>
    function GetSampleSearchText: string;
    /// <summary>
    /// Block start/end positions MUST be valid. 1-based indexes. 
    /// </summary>
    function GetBlockStartLine: Integer;
    function GetBlockStartCol: Integer;
    function GetBlockEndLine: Integer;
    function GetBlockEndCol: Integer;
  end;

  /// <summary>
  /// If implemented by the personality, used to specify the default
  /// highlighter to show. 
  /// </summary>
  IOTADefaultPreviewTrait = interface
    ['{0BFB4FE6-77F3-43AE-97A9-F740F8816126}']
    /// <summary>
    /// Return the IDString for the highlighter to default to for a preview. 
    /// </summary>
    function GetDefaultHighlighterPreview: string;
    property DefaultHighlighterPreview: string read GetDefaultHighlighterPreview;
  end;

  /// <summary>
  /// If an IOTAHighlighter implements IOTAElisionPreview in addition to
  /// IOTAHighlighterPreview, a preview of that highlighter's elision points
  /// will be shown in the color page. A sanity check is performed on the
  /// values returned from these methods to ensure 1) that the End position
  /// is after the Start position and 2) that the elision blocks do not go
  /// beyond the end of the code sample.  Elisions that do not pass this
  /// sanity check are ignored.  You can use this, for example, if you only
  /// want to show an elidable block without also showing an elided block.
  /// To do that, return -1 from the *Elided* methods below.
  /// The Descriptions can be blank.  In that case, no text is shown when
  /// the blocks are elided. 
  /// </summary>
  IOTAElisionPreview = interface
    ['{5637D9D8-9310-4D46-B40D-1DFEB15677D2}']
    function GetElidableBlockStartLine: Integer;
    function GetElidableBlockStartCol: Integer;
    function GetElidableBlockEndLine: Integer;
    function GetElidableBlockEndCol: Integer;
    function GetElidedBlockStartLine: Integer;
    function GetElidedBlockStartCol: Integer;
    function GetElidedBlockEndLine: Integer;
    function GetElidedBlockEndCol: Integer;
    function GetElidedBlockDescription: String;
    function GetElidableBlockDescription: String;
  end;

  IOTAHighlightServices = interface
    ['{78C26089-6CAD-40D1-BAC2-37A84DF8F3E6}']
    function GetHighlighterCount: Integer;
    function GetHighlighter(Index: Integer): IOTAHighlighter;
    function AddHighlighter(const AHighlighter: IOTAHighlighter): Integer;
    procedure RemoveHighlighter(Index: Integer);
    property Highlighter[Index: Integer]: IOTAHighlighter read GetHighlighter;
    property HighlighterCount: Integer read GetHighlighterCount;
  end;

  IOTACustomEditView = interface(IInterface)
    ['{845EDB0E-D107-4748-8444-707C680D8A65}']
    function SameView(const EditView: IOTACustomEditView): Boolean; overload;
  end;

  TOTABlockType = (btInclusive, btLine, btColumn, btNonInclusive, btUnknown);

  IOTAEditView40 = interface(IInterface)
    ['{0E3B9D78-E119-11D1-AB0C-00C04FB16FB3}']
    /// <summary>
    /// Return the Current cursor position 
    /// </summary>
    function GetCursorPos: TOTAEditPos;
    /// <summary>
    /// Set the current Cursor position 
    /// </summary>
    procedure SetCursorPos(const Value: TOTAEditPos);
    /// <summary>
    /// Return the Current top visible position 
    /// </summary>
    function GetTopPos: TOTAEditPos;
    /// <summary>
    /// Set the current top visible position 
    /// </summary>
    procedure SetTopPos(const Value: TOTAEditPos);
    /// <summary>
    /// Get size of the visible portion of the view in character cells 
    /// </summary>
    function GetViewSize: TSize;
    /// <summary>
    /// Converts a linear buffer offset position to a CharPos 
    /// </summary>
    function PosToCharPos(Pos: Longint): TOTACharPos;
    /// <summary>
    /// Convert a CharPos to a linear buffer offset 
    /// </summary>
    function CharPosToPos(CharPos: TOTACharPos): Longint;
    /// <summary>
    /// Convert between a EdPos and a CharPos 
    /// </summary>
    procedure ConvertPos(EdPosToCharPos: Boolean; var EditPos: TOTAEditPos;
      var CharPos: TOTACharPos);
    /// <summary>
    /// Return the token attributes at the given EdPos. If IncludeMargin is true,
    /// the attribute at the right margin line is the margin line attribute, else
    /// it returns the actual char attribute 
    /// </summary>
    procedure GetAttributeAtPos(const EdPos: TOTAEditPos; IncludeMargin: Boolean;
      var Element, LineFlag: Integer);
    /// <summary>
    /// Returns true if this interface instance is connected to the same
    /// underlying view as the indicated instance.  You must use this method
    /// in order to test for equality between views since several interface
    /// instances may share a single view.  You should also not hold onto
    /// these view interfaces for any length of time, unless a notifier is
    /// registered with the IOTASourceEditor so you can determine when the
    /// underlying implementation is vanishing. 
    /// </summary>
    function SameView(const EditView: IOTAEditView): Boolean;

    property CursorPos: TOTAEditPos read GetCursorPos write SetCursorPos;
    property TopPos: TOTAEditPos read GetTopPos write SetTopPos;
    property ViewSize: TSize read GetViewSize;
  end;

  IOTASearchOptions = interface(IUnknown)
    ['{D1766F8B-D915-11D2-A8C1-00C04FA32F53}']
    function GetCaseSensitive: Boolean;
    function GetDirection: TSearchDirection;
    function GetFromCursor: Boolean;
    function GetRegularExpression: Boolean;
    function GetSearchText: string;
    function GetWholeFile: Boolean;
    function GetWordBoundary: Boolean;
    procedure SetCaseSensitive(Value: Boolean);
    procedure SetDirection(Value: TSearchDirection);
    procedure SetFromCursor(Value: Boolean);
    procedure SetRegularExpression(Value: Boolean);
    procedure SetSearchText(const Value: string);
    procedure SetWholeFile(Value: Boolean);
    procedure SetWordBoundary(Value: Boolean);

    property CaseSensitive: Boolean read GetCaseSensitive write SetCaseSensitive;
    property Direction: TSearchDirection read GetDirection write SetDirection;
    property FromCursor: Boolean read GetFromCursor write SetFromCursor;
    property RegularExpression: Boolean read GetRegularExpression write SetRegularExpression;
    property SearchText: string read GetSearchText write SetSearchText;
    property WholeFile: Boolean read GetWholeFile write SetWholeFile;
    property WordBoundary: Boolean read GetWordBoundary write SetWordBoundary;
  end;

  IOTAReplaceOptions = interface(IOTASearchOptions)
    ['{D1766F8C-D915-11D2-A8C1-00C04FA32F53}']
    function GetPromptOnReplace: Boolean;
    function GetReplaceAll: Boolean;
    function GetReplaceText: string;
    procedure SetPromptOnReplace(Value: Boolean);
    procedure SetReplaceAll(Value: Boolean);
    procedure SetReplaceText(const Value: string);

    property PromptOnReplace: Boolean read GetPromptOnReplace write SetPromptOnReplace;
    property ReplaceAll: Boolean read GetReplaceAll write SetReplaceAll;
    property ReplaceText: string read GetReplaceText write SetReplaceText;
  end;

  IOTAEditPosition = interface(IUnknown)
    ['{9C510464-C7BC-11D2-9AEB-00A02457621F}']
    procedure Align(Magnitude: Integer);
    function BackspaceDelete(HowMany: Integer): Boolean;
    function Delete(HowMany: Integer): Boolean;
    function DistanceToTab(Direction: TSearchDirection): Integer;
    function GetCharacter: Char;
    function GetColumn: Integer;
    function GetIsSpecialCharacter: Boolean;
    function GetIsWhitespace: Boolean;
    function GetIsWordCharacter: Boolean;
    function GetLastRow: Integer;
    function GetReplaceOptions: IOTAReplaceOptions;
    function GetRow: Integer;
    function GetSearchErrorString(ErrorCode: Integer): string;
    function GetSearchOptions: IOTASearchOptions;
    function GotoLine(LineNumber: Integer): Boolean;
    procedure InsertBlock(const Block: IOTAEditBlock);
    procedure InsertCharacter(Character: Char);
    procedure InsertFile(const FileName: string);
    procedure InsertText(const Text: string);
    function Move(Row, Col: Integer): Boolean;
    function MoveBOL: Boolean;
    function MoveCursor(MoveMask: TMoveCursorMasks): Boolean;
    function MoveEOF: Boolean;
    function MoveEOL: Boolean;
    function MoveReal(Row, Col: Integer): Boolean;
    function MoveRelative(Row, Col: Integer): Boolean;
    procedure Paste;
    function Read(NumberOfCharacters: Integer): string;
    function RepeatLastSearchOrReplace: Boolean;
    function Replace(const Pattern, ReplaceText: string; CaseSensitive,
      RegularExpression, WholeFile: Boolean; Direction: TSearchDirection;
      var ErrorCode: Integer): Integer; overload;
     
    function Replace: Integer; overload;
     
    function ReplaceAgain: Integer;
    procedure Restore;
    function RipText(const ValidChars: TSysCharSet; RipFlags: Integer): string; overload;

    function RipText(const ValidChars: string; RipFlags: Integer): string; overload;
     
    procedure Save;
    function Search(const Pattern: string; CaseSensitive, RegularExpression,
      WholeFile: Boolean; Direction: TSearchDirection;
      var ErrorCode: Integer): Boolean; overload;
     
    function Search: Boolean; overload;
     
    function SearchAgain: Boolean;
    procedure Tab(Magnitude: Integer);

    property Character: Char read GetCharacter;
    property Column: Integer read GetColumn;
    property IsSpecialCharacter: Boolean read GetIsSpecialCharacter;
    property IsWhiteSpace: Boolean read GetIsWhiteSpace;
    property IsWordCharacter: Boolean read GetIsWordCharacter;
    property LastRow: Integer read GetLastRow;
    property ReplaceOptions: IOTAReplaceOptions read GetReplaceOptions;
    property Row: Integer read GetRow;
    property SearchOptions: IOTASearchOptions read GetSearchOptions;
  end;

  IOTAInsertWideChar = interface(IUnknown)
    ['{A43AC8A9-7641-427B-A5F2-F3DFE937E974}']
    procedure InsertWideCharacter(Character: WideChar);
  end;

  TOTASyncMode = (smNone, smNormal, smTemplates);

  IOTASyncEditPoint100 = interface
    ['{59492E58-8CE3-45D8-902F-D80475DEFE9D}']
    procedure AddOffset(Offset: TOTACharPos);
    procedure RemoveOffset(Index: Integer);
    function GetCount: Integer;
    function GetEditable: Boolean;
    function GetHint: string;
    function GetName: string;
    function GetOffset(Index: Integer): TOTACharPos;
    function GetText: string;
    procedure SetEditable(Value: Boolean);
    procedure SetHint(const Value: string);
    procedure SetName(const Value: string);
    procedure SetOffset(Index: Integer; Value: TOTACharPos);
    procedure SetText(Value: string);

    property Count: Integer read GetCount;
    property Editable: Boolean read GetEditable write SetEditable;
    property Hint: string read GetHint write SetHint;
    property Name: string read GetName write SetName;
    property Offset[Index: Integer]: TOTACharPos read GetOffset write SetOffset;
    property Text: string read GetText write SetText;
  end;

  IOTASyncEditPoint = interface(IOTASyncEditPoint100)
    ['{B724144B-D292-4BAB-925F-BE84D7E7507C}']
    function GetMultiLine: Boolean;
    procedure SetMultiLine(Value: Boolean);
    property MultiLine: Boolean read GetMultiLine write SetMultiLine;
  end;

  IOTASyncEditPoints = interface
    ['{5E7AD63A-CB78-4BF4-9F1D-B2576898DCB4}']
    function AddPoint(const APoint: IOTASyncEditPoint): Integer;
    procedure RemovePoint(const APoint: IOTASyncEditPoint);
    function GetPoints(Index: Integer): IOTASyncEditPoint;
    function GetCount: Integer;
    property Count: Integer read GetCount;
    property Points[Index: Integer]: IOTASyncEditPoint read GetPoints; default;
  end;

  TOTASyncEditPointEventType = (sepEnter, sepLeave, sepExit);

  IOTASyncEditNotifier = interface
    ['{FA65E734-7F38-48F2-9A9C-B09650159E34}']
    procedure OnPoint(const APoint: IOTASyncEditPoint;
      const APoints: IOTASyncEditPoints;
      EventType: TOTASyncEditPointEventType);
    procedure OnSyncEdit(const APoints: IOTASyncEditPoints;
      EventType: TOTASyncEditPointEventType);
  end;

  IOTAEditBlock90 = interface(IUnknown)
    ['{9C510463-C7BC-11D2-9AEB-00A02457621F}']
    procedure BeginBlock;
    procedure Copy(Append: Boolean);
    procedure Cut(Append: Boolean);
    function Delete: Boolean;
    procedure EndBlock;
    function Extend(NewRow, NewCol: Integer): Boolean;
    function ExtendPageUp: Boolean;
    function ExtendPageDown: Boolean;
    function ExtendReal(NewRow, NewCol: Integer): Boolean;
    function ExtendRelative(DeltaRow, DeltaCol: Integer): Boolean;
    function GetEndingColumn: Integer;
    function GetEndingRow: Integer;
    function GetIsValid: Boolean;
    function GetSize: Integer;
    function GetStartingColumn: Integer;
    function GetStartingRow: Integer;
    function GetStyle: TOTABlockType;
    function GetText: string;
    function GetVisible: Boolean;
    procedure Indent(Magnitude: Integer);
    procedure LowerCase;
    function Print: Boolean;
    procedure Reset;
    procedure Restore;
    procedure Save;
    function SaveToFile(const FileName: string): Boolean;
    procedure SetStyle(Value: TOTABlockType);
    procedure SetVisible(Value: Boolean);
    procedure ToggleCase;
    procedure UpperCase;

    property EndingColumn: Integer read GetEndingColumn;
    property EndingRow: Integer read GetEndingRow;
    property IsValid: Boolean read GetIsValid;
    property Size: Integer read GetSize;
    property StartingColumn: Integer read GetStartingColumn;
    property StartingRow: Integer read GetStartingRow;
    property Style: TOTABlockType read GetStyle write SetStyle;
    property Text: string read GetText;
    property Visible: Boolean read GetVisible write SetVisible;
  end;

  IOTAEditBlock = interface(IOTAEditBlock90)
    ['{371F9A07-94E2-4708-9DB0-93514FD2FE14}']
    function GetSyncMode: TOTASyncMode;
    procedure SyncEditBlock(const Points: IOTASyncEditPoints = nil);
    function AddNotifier(const ANotifier: IOTASyncEditNotifier): Integer;
    procedure RemoveNotifier(Index: Integer);
    property SyncMode: TOTASyncMode read GetSyncMode;
  end;

  INTAEditWindow = interface(IUnknown)
    ['{8CC6430B-E721-11D2-A8CC-00C04FA32F53}']
    function GetForm: TCustomForm;
    function GetStatusBar: TStatusBar;
    function CreateDockableForm(const FormName: string): TDockableForm;
    procedure ShowDockableFormFrame(const FormName, Caption: string; AFrame: TFrame);

    property Form: TCustomForm read GetForm;
    property StatusBar: TStatusBar read GetStatusBar;
  end;

  INTAEditServicesNotifier = interface(IOTANotifier)
    ['{F954AA40-23E7-412C-BD59-CC3428DE2939}']
    procedure WindowShow(const EditWindow: INTAEditWindow; Show, LoadedFromDesktop: Boolean);
    procedure WindowNotification(const EditWindow: INTAEditWindow; Operation: TOperation);
    procedure WindowActivated(const EditWindow: INTAEditWindow);
    procedure WindowCommand(const EditWindow: INTAEditWindow; Command, Param: Integer; var Handled: Boolean);
    procedure EditorViewActivated(const EditWindow: INTAEditWindow; const EditView: IOTAEditView);
    procedure EditorViewModified(const EditWindow: INTAEditWindow; const EditView: IOTAEditView);
    procedure DockFormVisibleChanged(const EditWindow: INTAEditWindow; DockForm: TDockableForm);
    procedure DockFormUpdated(const EditWindow: INTAEditWindow; DockForm: TDockableForm);
    procedure DockFormRefresh(const EditWindow: INTAEditWindow; DockForm: TDockableForm);
  end;

  {$IFDEF LINUX}
  {$NODEFINE INTAEditWindow}
  {$ENDIF}

  IOTAEditView140 = interface(IOTAEditView40)
    ['{9C510462-C7BC-11D2-9AEB-00A02457621F}']
    function BookmarkGoto(BookmarkID: Integer): Boolean;
    function BookmarkRecord(BookmarkID: Integer): Boolean;
    function BookmarkToggle(BookmarkID: Integer): Boolean;
    procedure Center(Row, Col: Integer);
    function GetBlock: IOTAEditBlock;
    function GetBookmarkPos(BookmarkID: Integer): TOTACharPos;
    function GetBottomRow: Integer;
    function GetBuffer: IOTAEditBuffer;
    function GetEditWindow: INTAEditWindow;
    function GetLastEditColumn: Integer;
    function GetLastEditRow: Integer;
    function GetLeftColumn: Integer;
    function GetPosition: IOTAEditPosition;
    function GetRightColumn: Integer;
    function GetTopRow: Integer;
    procedure MoveCursorToView;
    procedure MoveViewToCursor;
    procedure PageDown;
    procedure PageUp;
    procedure Paint;
    function Scroll(DeltaRow: Integer; DeltaCol: Integer): Integer;
    procedure SetTopLeft(TopRow, LeftCol: Integer);
    procedure SetTempMsg(const Msg: string);

    property Block: IOTAEditBlock read GetBlock;
    property BottomRow: Integer read GetBottomRow;
    property BookmarkPos[BookMarkID: Integer]: TOTACharPos read GetBookmarkPos;
    property Buffer: IOTAEditBuffer read GetBuffer;
    property LastEditColumn: Integer read GetLastEditColumn;
    property LastEditRow: Integer read GetLastEditRow;
    property LeftColumn: Integer read GetLeftColumn;
    property Position: IOTAEditPosition read GetPosition;
    property RightColumn: Integer read GetRightColumn;
    property TopRow: Integer read GetTopRow;
  end;

  IOTAEditView145 = interface(IOTAEditView140)
    ['{5EBBA00C-059D-4571-B30A-328D1264BBB8}']
    procedure ClearAllBookmarks;
  end;

  /// <summary>
  /// 
  /// mtModSinceLoad -- indicates changes made since the file was loaded that
  ///                   have already been saved to disk.  These lines are marked
  ///                   with the Foreground color of the &quot;Modified Lines&quot; element
  ///                   in the code editor (&quot;Lime&quot; by default)
  /// mtModSinceSave -- indicates changes made since the file was last saved.
  ///                   These lines are marked with the Background color of the
  ///                   &quot;Modified Lines&quot; element in the code editor (&quot;Yellow&quot; by
  ///                   default)
  /// mtAnyMod       -- indicates any modified line.  This is essentially a union
  ///                   of mtModSinceLoad and mtModSinceSave
  ///   
  /// </summary>
  TOTAModificationType = (mtModSinceLoad, mtModSinceSave, mtAnyMod);

  IOTAEditView220 = interface(IOTAEditView145)
    ['{BD1A97F8-2346-4856-8A19-51787EAC3240}']
    /// <summary>
    /// Navigates to the next modified line starting from the current cursor
    /// position, treating contiguous modified lines as a block.  Direction
    /// indicates whether to go forward or backward from this location.
    /// ModificationType indicates which modifications you want to navigate to 
    /// </summary>
    procedure NavigateToModification(Direction: TSearchDirection; ModificationType: TOTAModificationType);
  end;

  INTAEditViewNotifier = interface;
  
  TOTAIncreaseDecreaseFontSizeMode = (idFontIncrease, idFontDecrease);
  
  IOTAEditView = interface(IOTAEditView220)
    ['{66D8D413-9D17-47B9-9BC4-6D7550437D1E}']
    /// <summary>
    /// Increase/Decrease the code editor font size to the next/previous size value 
    /// </summary>
    procedure IncreaseDecreaseFontSize(const ActionMode: TOTAIncreaseDecreaseFontSizeMode);
    function AddNotifier(const Extension: INTAEditViewNotifier): Integer;
    procedure RemoveNotifier(Index: Integer);
  end;

  TOTAAttributeArray = array of Byte;

  INTAEditViewNotifier = interface(IOTANotifier)
    ['{8990AA6E-C1C5-4CF9-8051-C5B4F6EE11D8}']
    /// <summary>
    /// EditorIdle is called after some action has taken place in the view (editing, cursor moving, etc..)
    /// and a period of time has passed with no other action happening. This is roughly equivalent
    /// to when Code Insight is triggered (and is tied to the Code Insight delay setting) 
    /// </summary>
    procedure EditorIdle(const View: IOTAEditView);
    /// <summary>
    /// BeginPaint is called right before the code editor is repainted. By default,
    /// not all lines are always painted - only those lines that have changed are
    /// repainted under most circumstances. To force all lines to be repainted, set
    /// FullRepaint to True (But do so judiciously, as it may have an adverse impact
    /// on the speed of the code editor). NEVER set FullRepaint to False, as other
    /// INTAEditViewNotifiers may have already set it to true. 
    /// </summary>
    procedure BeginPaint(const View: IOTAEditView; var FullRepaint: Boolean);
    /// <summary>
    /// PaintLine is called for each line that is painted in the code editor. When
    /// PaintLine is called, the editor control's canvas has already been painted
    /// for this line, and INTAEditView implementations can paint over it, either
    /// to change the way text is displayed, or add additional decorations to the
    /// existing text. There is no guarantee of the order in which Notifiers will
    /// be invoked. The only Guarantee is that the IDE's built-in editor control painting
    /// has occured before PaintLine is called.
    /// Parameters:
    ///   View: The IOTAEditView being repainted
    ///   LineNumber: The line number that is being repainted
    ///   LineText: Pointer to the UTF-8 encoded text of the line being painted
    ///     (Note: This is UTF-8, NOT a WideString)
    ///   TextWidth: The number of Characters in LineText. (LineText is NOT guaranteed
    ///     to be 0-terminated. Use TextWidth instead of StrLen, etc...)
    ///   LineAttributes: Each item indicates the attributes of the character as used
    ///     for syntax highlighting. Each byte of CharAttributes maps 1-to-1 with the
    ///     characters in LineText
    ///   Canvas: The editor control's canvas object. Draw on this canvas to create custom syntax highlighting, etc...
    ///   TextRect: The area in which the text on this line has been painted. If you draw in this rect, you will be drawing
    ///     over the text that the editor has already drawn.
    ///   LineRect: The area in which the line text is being painted. You should draw only in this rect. Anything drawn outside of this
    ///     area may be painted over by something else, and is not guaranteed to be shown.
    ///   CellSize: The size of a character &quot;cell&quot; in the editor. Because the code
    ///     editor uses monospace fonts, all characters are the same size. This can
    ///     be used to calculate the pixel location of a particular character for custom painting.
    ///     
    /// </summary>
    procedure PaintLine(const View: IOTAEditView; LineNumber: Integer;
      const LineText: PAnsiChar; const TextWidth: Word; const LineAttributes: TOTAAttributeArray;
      const Canvas: TCanvas; const TextRect: TRect; const LineRect: TRect; const CellSize: TSize);
    /// <summary>
    /// EndPaint is called after all the of the lines have been repainted. Use this
    /// to clean up any data structures that have been maintained over the course of
    /// painting lines. 
    /// </summary>
    procedure EndPaint(const View: IOTAEditView);
  end;

  TClassNavigateStyle = Byte;
  TCodeCompleteStyle = Byte;
  TOTANavigateType = (ntUp, ntDown, ntHome, ntEnd);

  IOTAEditActions60 = interface(IUnknown)
    ['{ECB23623-E2D8-11D2-ABE5-00C04FB16FB3}']
    procedure AddWatch;
    procedure AddWatchAtCursor;
    procedure BrowseSymbolAtCursor;
    procedure ClassComplete;
    procedure ClassNavigate(Reserved: TClassNavigateStyle);
    procedure ClosePage;
    procedure CodeTemplate;
    procedure CodeCompletion(Style: TCodeCompleteStyle);
    procedure EvaluateModify;
    procedure HelpKeyword;
    procedure IncrementalSearch;
    procedure InsertCompilerOptions;
    procedure InsertNewGUID;
    procedure InspectAtCursor;
    procedure CompileProject;
    procedure NextError;
    procedure NextPage;
    procedure OpenFile;
    procedure OpenFileAtCursor;
    procedure PriorError;
    procedure PriorPage;
    procedure ProgramReset;
    procedure RunProgram;
    procedure RunToCursor;
    procedure SaveAll;
    procedure Save;
    procedure SaveAs;
    procedure StepOver;
    procedure SwapSourceFormView;
    procedure SwapCPPHeader;
    procedure ToggleFormUnit;
    procedure TraceInto;
    procedure TraceToSource;
    procedure ViewExplorer;
    procedure ViewForms;
    procedure ViewObjectInspector;
    procedure ViewUnits;
    procedure WindowList;
    procedure ZoomWindow;
  end;

  /// <summary>
  /// IOTAEditView implements IOTAEditActions 
  /// </summary>
  IOTAEditActions100 = interface(IOTAEditActions60)
    ['{9A073F11-2732-D611-958B-00C04FA06AFC}']
    procedure NextBufferView;
    procedure PreviousBufferView;
  end;

  /// <summary>
  /// IOTAEditView implements IOTAEditActions 
  /// </summary>
  IOTAEditActions = interface(IOTAEditActions100)
    ['{332DBE22-AB36-44B7-B835-BC95F6F9E688}']
    procedure MethodNavigate(NavigateType: TOTANavigateType);
  end;

  /// <summary>
  /// IOTAEditView implements IOTAElideActions 
  /// </summary>
  IOTAElideActions120 = interface(IUnknown)
    ['{3AB41D14-D290-4674-8978-D0AB4E70C14B}']
    /// <summary>
    /// Elide (fold) the nearest block 
    /// </summary>
    procedure ElideNearestBlock;
    /// <summary>
    /// Unelide (unfold) the nearest block 
    /// </summary>
    procedure UnElideNearestBlock;
    /// <summary>
    /// Unelide all blocks 
    /// </summary>
    procedure UnElideAllBlocks;
    /// <summary>
    /// Enable elisions (folding) 
    /// </summary>
    procedure EnableElisions;
  end;

  /// <summary>
  /// IOTAEditView implements IOTAElideActions 
  /// </summary>
  IOTAElideActions150 = interface(IOTAElideActions120)
    ['{8080361F-888F-4D0E-9ECF-3FE21FA768B5}']
    /// <summary>
    /// Toggle elisions (folding) of nearest block 
    /// </summary>
    procedure ToggleElisions;
    /// <summary>
    /// Elide (fold) all Namespaces 
    /// </summary>
    procedure ElideNamespaces;
    /// <summary>
    /// Elide (fold) all Regions 
    /// </summary>
    procedure ElideRegions;
    /// <summary>
    /// Elide (fold) all Types 
    /// </summary>
    procedure ElideTypes;
    /// <summary>
    /// Elide (fold) all Nested Procedures 
    /// </summary>
    procedure ElideNestedProcs;
    /// <summary>
    /// Elide (fold) all Globals 
    /// </summary>
    procedure ElideGlobals;
    /// <summary>
    /// Elide (fold) all Methods 
    /// </summary>
    procedure ElideMethods;
  end;

  IOTAElideActions = interface(IOTAElideActions150)
    ['{06EF0818-E4DF-414F-BD86-BCD29680D553}']
    /// <summary>
    /// Elide (fold) all inline documentation (XMLDoc) comments 
    /// </summary>
    procedure ElideDocRegions;
  end;

  IOTASourceEditor70 = interface(IOTAEditor)
    ['{F17A7BD1-E07D-11D1-AB0B-00C04FB16FB3}']
    /// <summary>
    /// Create and return an IOTAEditReader 
    /// </summary>
    function CreateReader: IOTAEditReader;
    /// <summary>
    /// Create and return an IOTAEditWriter. Changes are not undoable 
    /// </summary>
    function CreateWriter: IOTAEditWriter;
    /// <summary>
    /// Create and return an IOTAEditWriter. Changes are undoable 
    /// </summary>
    function CreateUndoableWriter: IOTAEditWriter;
    /// <summary>
    /// Return the number of active views on this editor 
    /// </summary>
    function GetEditViewCount: Integer;
    /// <summary>
    /// Return the Indexed view 
    /// </summary>
    function GetEditView(Index: Integer): IOTAEditView;
    /// <summary>
    /// Returns the total number of lines in this source editor 
    /// </summary>
    function GetLinesInBuffer: Longint;
    /// <summary>
    /// Change the syntax highlighter for this buffer or if shQuery is set,
    /// simply return the currently set highlighter.
    /// SetSyntaxHighlighter is deprecated. Use the IOTAEditOptions. 
    /// </summary>
    function SetSyntaxHighlighter(SyntaxHighlighter: TOTASyntaxHighlighter): TOTASyntaxHighlighter; deprecated;
    /// <summary>
    /// These functions will affect all views on this buffer. 
    /// </summary>
    function GetBlockAfter: TOTACharPos;
    function GetBlockStart: TOTACharPos;
    function GetBlockType: TOTABlockType;
    function GetBlockVisible: Boolean;
    procedure SetBlockAfter(const Value: TOTACharPos);
    procedure SetBlockStart(const Value: TOTACharPos);
    procedure SetBlockType(Value: TOTABlockType);
    procedure SetBlockVisible(Value: Boolean);

    property BlockStart: TOTACharPos read GetBlockStart write SetBlockStart;
    property BlockAfter: TOTACharPos read GetBlockAfter write SetBlockAfter;
    property BlockType: TOTABlockType read GetBlockType write SetBlockType;
    property BlockVisible: Boolean read GetBlockVisible write SetBlockVisible;
    property EditViewCount: Integer read GetEditViewCount;
    property EditViews[Index: Integer]: IOTAEditView read GetEditView;
  end;

  IOTASourceEditor180 = interface(IOTASourceEditor70)
    ['{5D965803-8147-4D32-B8C5-712F6DDCF98E}']
    /// <summary>
    /// Get the number of sub-Views on this editor.  This editor itself may be a
    /// sub view and may not be at index 0.  !!NOTE!! that this function will
    /// return 0 if this SourceEditor is not visible in any editor window.  You must
    /// call IOTAEditor.Show before using these functions to manipulate the views. 
    /// </summary>
    function GetSubViewCount: Integer;
    /// <summary>
    /// Returns a view identifier for the given sub-view index.  This may just be
    /// the specific filename of the view or some other unique identifier 
    /// </summary>
    function GetSubViewIdentifier(Index: Integer): string;
    /// <summary>
    /// Returns the sub-view index for this editor.  If this is the main source
    /// editor, its index will always be 0.  However for modules with more than
    /// one source editor, this may return &gt; 0. (ie. Managed .cpp files with an
    /// associated .h file) 
    /// </summary>
    function GetSubViewIndex: Integer;
    /// <summary>
    /// Switches the editor to the specified view by view index 
    /// </summary>
    procedure SwitchToView(Index: Integer); overload;
    /// <summary>
    /// Switches the editor to the specified view by view identifier 
    /// </summary>
    procedure SwitchToView(const AViewIdentifier: string); overload;
  end;

  IOTASourceEditor = interface(IOTASourceEditor180)
    ['{4D460588-10A6-4CAD-87E7-5654266073F9}']
    /// <summary>
    /// Switches the editor to the specified view by view index.
    /// The AViewContext parameter is passed along to the specified view which can be used
    /// to indicate any view-specific context or selection criteria. 
    /// </summary>
    procedure SwitchToView(Index: Integer; const AViewContext: TObject); overload;
    /// <summary>
    /// Switches the editor to the specified view by view identifier.
    /// The AViewContext parameter is passed along to the specified view which can be used
    /// to indicate any view-specific context or selection criteria. 
    /// </summary>
    procedure SwitchToView(const AViewIdentifier: string; const AViewContext: TObject); overload;
  end;

  /// <summary>
  /// IOTAResourceEntry is a raw interface to a resource entry in the project's
  /// resource file (&lt;projectname&gt;.RES).
  /// 
  /// This interface is very raw.  No implication on what is contained within
  /// a particular entry is made.  Is if up to the add-in developer to interpret
  /// the data accessed through this interface.  NOTE: The 'MAINICON' entry and
  /// related entries should not be modified as these are maintained by Delphi/
  /// C++Builder. 
  /// </summary>

  TOTAResHeaderValue = (hvFlags, hvLanguage, hvDataVersion, hvVersion,
    hvCharacteristics);

  IOTAResourceEntry = interface(IUnknown)
    ['{26EB0E51-F97B-11D1-AB27-00C04FB16FB3}']
    /// <summary>
    /// Gets the resource type of this entry.  Follows Windows standard of
    /// specifying a type by name or value.  If the high-word is 0, then the
    /// low-word is the resource type value, otherwise it is a pointer to a null
    /// terminated ANSI (byte per char) string. Most predefined types are by
    /// value. 
    /// </summary>
    function GetResourceType: PChar;
    /// <summary>
    /// Gets the resource name of this entry.  Follows Windows standard of
    /// specifying a type by name or value. If the high-word is 0, then the
    /// low-word is the resource type value, otherwise it is a pointer to a null
    /// terminated ANSI (byte per char) string. 
    /// </summary>
    function GetResourceName: PChar;
    /// <summary>
    /// Changes the Type and name of this resource entry 
    /// </summary>
    function Change(NewType, NewName: PChar): Boolean;
    /// <summary>
    /// Gets and sets various resource header values.  Pass in one of the \
    /// TResHeaderValues enums to indicate which value to get/set.  Although
    /// some values are 16bits (Word) these functions operation only on
    /// 32bits (Integer). 
    /// </summary>
    function GetHeaderValue(HeaderValue: TOTAResHeaderValue;
      var Value: Integer): Boolean;
    /// <summary>
    /// See GetHeaderValue 
    /// </summary>
    function SetHeaderValue(HeaderValue: TOTAResHeaderValue;
      Value: Integer): Boolean;
    /// <summary>
    /// Returns a raw pointer to the actual resource data buffer. 
    /// </summary>
    function GetData: Pointer;
    /// <summary>
    /// Returns the current size of the data buffer. 
    /// </summary>
    function GetDataSize: Integer;
    /// <summary>
    /// Resizes the current data buffer.  If the size is smaller than the
    /// current size, the data is simply truncated without regard to its
    /// current contents. 
    /// </summary>
    procedure SetDataSize(NewSize: Integer);
    /// <summary>
    /// Returns a unique handle value identifying the resource entry. 
    /// </summary>
    function GetEntryHandle: TOTAHandle;

    property DataSize: Integer read GetDataSize write SetDataSize;
  end;

  /// <summary>
  /// The IOTAProjectResource is an interface on the project's resource file
  /// (&lt;projectname&gt;.RES). 
  /// </summary>

  IOTAProjectResource = interface(IOTAEditor)
    ['{26EB0E52-F97B-11D1-AB27-00C04FB16FB3}']
    /// <summary>
    /// Returns the number of Resource entries. 
    /// </summary>
    function GetEntryCount: Integer;
    /// <summary>
    /// Given an index, returns an IOTAResourceEntry of the index'th entry. 
    /// </summary>
    function GetEntry(Index: Integer): IOTAResourceEntry;
    /// <summary>
    /// Given an entry handle, return the IOTAResourceEntry 
    /// </summary>
    function GetEntryFromHandle(EntryHandle: TOTAHandle): IOTAResourceEntry;
    /// <summary>
    /// Given a Resource type and name, return an IOTAResourceEntry or nil
    /// if not found. 
    /// </summary>
    function FindEntry(ResType, Name: PChar): IOTAResourceEntry;
    /// <summary>
    /// Given an entry handle, delete the given resource entry. 
    /// </summary>
    procedure DeleteEntry(EntryHandle: TOTAHandle);
    /// <summary>
    /// Creates a new resource entry of the given type and name and returns a
    /// IOTAResourceEntry.  Returns nil if the entry already exists or any other
    /// error occurs. 
    /// </summary>
    function CreateEntry(ResType, Name: PChar; Flags, LanguageId: Word;
      DataVersion, Version, Characteristics: Integer): IOTAResourceEntry;
  end;

  TOTAGetChildCallback = procedure (Param: Pointer; Component: IOTAComponent;
    var Result: Boolean) of object;

  /// <summary>
  /// INTAComponent - This is the native component interface.  You can get
  /// this interface by checking if IOTAComponent supports it. 
  /// </summary>

  INTAComponent = interface(IUnknown)
    ['{34B2E2D1-E36F-11D1-AB0E-00C04FB16FB3}']
    /// <summary>
    /// Returns the actual TComponent/TPersistent 
    /// </summary>
    function GetPersistent: TPersistent;
    /// <summary>
    /// Returns the TComponent if this interface is a TComponent else nil 
    /// </summary>
    function GetComponent: TComponent;
  end;
  {$IFDEF LINUX}
  {$NODEFINE INTAComponent}
  {$ENDIF}

  /// <summary>
  /// The IOTAComponent is the base interface for a component living
  /// on a form/data module.  Never hold this interface for very long, since
  /// the component may be deleted at any time. 
  /// </summary>
  IOTAComponent = interface(IUnknown)
    ['{AC139ADF-329A-D411-87C6-9B2730412200}']
    // Old GUID ['{34B2E2D0-E36F-11D1-AB0E-00C04FB16FB3}']
    /// <summary>
    /// Returns a string representing the type of the component. 
    /// </summary>
    function GetComponentType: string;
    /// <summary>
    /// Returns a unique Handle to the TComponent/TPersistent 
    /// </summary>
    function GetComponentHandle: TOTAHandle;
    /// <summary>
    /// Returns the interface corresponding to the parent control if a TControl,
    /// otherwise returns the owner of the control.  If a TPersistent or the
    /// root object then it returns nil. 
    /// </summary>
    function GetParent: IOTAComponent;
    /// <summary>
    /// Returns True if component is a TControl descendant 
    /// </summary>
    function IsTControl: Boolean;
    /// <summary>
    /// Returns the number of published properties on this component. 
    /// </summary>
    function GetPropCount: Integer;
    /// <summary>
    /// Given the index, returns the property name. 
    /// </summary>
    function GetPropName(Index: Integer): string;
    /// <summary>
    /// Given the index, returns the property type. 
    /// </summary>
    function GetPropType(Index: Integer): TTypeKind;
    /// <summary>
    /// Given the name, returns the property type. 
    /// </summary>
    function GetPropTypeByName(const Name: string): TTypeKind;
    /// <summary>
    /// Given the index or name, returns the property value. The untyped var
    /// must be large enough to hold the returned value.  For string types,
    /// the untyped var must match the actual string type (as indicated by GetPropType
    /// or GetPropTypeByName):
    ///   -- tkString:  untyped param should be of type ShortString
    ///   -- tkLString: untyped param should be of type AnsiString
    ///   -- tkWString: untyped param should be of type WideString
    ///   -- tkUString: untyped param should be of type UnicodeString
    /// If the property is a descendant of TPersistent, the return value is a
    /// IOTAComponent. For properties of any other objecttype, the return value is nil. 
    /// </summary>
    function GetPropValue(Index: Integer; var Value): Boolean;
    function GetPropValueByName(const Name: string; var Value): Boolean;
    /// <summary>
    /// Given the index or name, sets the property value. 
    /// </summary>
    function SetProp(Index: Integer; const Value): Boolean;
    function SetPropByName(const Name: string; const Value): Boolean;
    /// <summary>
    /// Enumerate the child controls just like TComponent.GetChildren 
    /// </summary>
    function GetChildren(Param: Pointer; Proc: TOTAGetChildCallback): Boolean;
    /// <summary>
    /// Returns the number of child controls (if a TWinControl/TWidgetControl descendant,
    /// else returns 0). 
    /// </summary>
    function GetControlCount: Integer;
    /// <summary>
    /// Given the index, returns an interface to the child control. 
    /// </summary>
    function GetControl(Index: Integer): IOTAComponent;
    /// <summary>
    /// Returns the number of child components (if a TComponent descendant,
    /// else returns 0). 
    /// </summary>
    function GetComponentCount: Integer;
    /// <summary>
    /// Given the index, returns an interface to the child component. 
    /// </summary>
    function GetComponent(Index: Integer): IOTAComponent;
    /// <summary>
    /// Selects the component and updates the Object Inspector. If AddToSelection
    /// if true, then the current selection is not cleared, and the components are
    /// multi-selected 
    /// </summary>
    function Select(AddToSelection: Boolean): Boolean;
    /// <summary>
    /// Same as Select except it brings the form to front with the component
    /// selected.  If this interface is a Form/Data Module, then Focus only
    /// brings the form to front. See Select for description of AddToSelection
    /// </summary>
    function Focus(AddToSelection: Boolean): Boolean;
    /// <summary>
    /// Deletes the component from the form.  Following this call, this interface
    /// will now be invalid and must be release. 
    /// </summary>
    function Delete: Boolean;
    /// <summary>
    /// Returns the IPersistent interface 
    /// </summary>
    //function GetIPersistent: IPersistent;
    /// <summary>
    /// Returns the IComponent interface if instance is a TComponent else nil 
    /// </summary>
    //function GetIComponent: IComponent;
  end;

  /// <summary>
  /// IOTAFormEditor implements INTAFormEditor 
  /// </summary>
  INTAFormEditor = interface(IUnknown)
    ['{56931EB9-329A-D411-87C6-9B2730412200}']
    // Old GUID ['{34B2E2CF-E36F-11D1-AB0E-00C04FB16FB3}']
    /// <summary>
    /// Return the instance of the TFormDesigner on this editor 
    /// </summary>
    function GetFormDesigner: DesignIntf.IDesigner;
    procedure GetFormResource(Stream: TStream);

    property FormDesigner: DesignIntf.IDesigner read GetFormDesigner;
  end;
  {$IFDEF LINUX}
  {$NODEFINE INTAFormEditor}
  {$ENDIF}

  IOTAFormEditor = interface(IOTAEditor)
    ['{F17A7BD2-E07D-11D1-AB0B-00C04FB16FB3}']
    /// <summary>
    /// Return the form editor root component 
    /// </summary>
    function GetRootComponent: IOTAComponent;
    function FindComponent(const Name: string): IOTAComponent;
    function GetComponentFromHandle(ComponentHandle: TOTAHandle): IOTAComponent;
    function GetSelCount: Integer;
    function GetSelComponent(Index: Integer): IOTAComponent;
    function GetCreateParent: IOTAComponent;
    function CreateComponent(const Container: IOTAComponent;
      const TypeName: string; X, Y, W, H: Integer): IOTAComponent;
    procedure GetFormResource(const Stream: IStream);
  end;

  IOTATypeLibrary = interface
    ['{7A2F5910-58D2-448E-B457-2DC01E853D46}']
  end;

  IOTATypeLibEditor = interface(IOTAEditor)
    ['{F17A7BD3-E07D-11D1-AB0B-00C04FB16FB3}']
    function GetTypeLibrary: IOTATypeLibrary;

    property TypeLibrary: IOTATypeLibrary read GetTypeLibrary;
  end;

  /// <summary>
  /// Interface implemented by a client to receive notifications
  /// on a specific module 
  /// </summary>
  IOTAModuleNotifier = interface(IOTANotifier)
    ['{F17A7BCE-E07D-11D1-AB0B-00C04FB16FB3}']
    /// <summary>
    /// CheckOverwrite is called during a SaveAs operation to determine if any
    /// files associated with this module will overwrite any other files.
    /// Return True to allow the overwrite or no overwrite will occur 
    /// </summary>
    function CheckOverwrite: Boolean;
    /// <summary>
    /// User has renamed the module 
    /// </summary>
    procedure ModuleRenamed(const NewName: string);
  end;

  IOTAModuleNotifier80 = interface(IOTAModuleNotifier)
    ['{6C4714BB-223A-4CDF-A710-429FE8FA0B91}']
    /// <summary>
    /// AllowSave is called immediately prior to doing any type of save operation
    /// in order to allow any add-ins to enable/disable the saving of any specific
    /// module.  This is useful when one module is to be kept in sync with another
    /// module such as keeping the name of a module the same base name as the
    /// project. 
    /// </summary>
    function AllowSave: Boolean;
    /// <summary>
    /// GetOverwriteFileNameCount returns the number of filenames to check for an
    /// overwrite during a save as operation.  This is simply a list of files that
    /// the IDE will check if they exist.  If any of these files exist, then the
    /// IDE will prompt for an overwrite and display the filename in the overwrite
    /// prompt dialog. 
    /// </summary>
    function GetOverwriteFileNameCount: Integer;
    /// <summary>
    /// GetOverwriteFileName returns the index'd filename for the IDE to check for
    /// existence during a save as operation. 
    /// </summary>
    function GetOverwriteFileName(Index: Integer): string;
    /// <summary>
    /// SetSaveFileName will be called with the fully qualified filename that the
    /// user entered in the Save As dialog.  This name can then be used to
    /// determine all the resulting names 
    /// </summary>
    procedure SetSaveFileName(const FileName: string);

    property OverwriteFileNameCount: Integer read GetOverwriteFileNameCount;
    property OverwriteFileNames[Index: Integer]: string read GetOverwriteFileName;
  end;

  IOTAModuleNotifier90 = interface(IOTAModuleNotifier80)
    ['{53B90D0D-0E70-472A-885E-0566B2711C15}']
    /// <summary>
    /// BeforeRename is call just before the new file is save/renamed on disk.
    /// </summary>
    procedure BeforeRename(const OldFileName, NewFileName: string);
    /// <summary>
    /// AfterRename is call just after the new file is save/renamed on disk.
    /// </summary>
    procedure AfterRename(const OldFileName, NewFileName: string);
  end;

  IOTAModuleInfo50 = interface(IUnknown)
    ['{F17A7BD6-E07D-11D1-AB0B-00C04FB16FB3}']
    /// <summary>
    /// Returns the type of this module 
    /// </summary>
    function GetModuleType: TOTAModuleType;
    /// <summary>
    /// Returns the Module Name 
    /// </summary>
    function GetName: string;
    /// <summary>
    /// Returns the Module File name 
    /// </summary>
    function GetFileName: string;
    /// <summary>
    /// Returns the Form Name 
    /// </summary>
    function GetFormName: string;
    /// <summary>
    /// Returns the Design class 
    /// </summary>
    function GetDesignClass: string;
    /// <summary>
    /// Fills the TStrings class with the CoClasses 
    /// </summary>
    procedure GetCoClasses(CoClasses: TStrings);
    /// <summary>
    /// Opens and returns the IOTAModule associated with this IOTAModuleInfo 
    /// </summary>
    function OpenModule: IOTAModule;

    property ModuleType: TOTAModuleType read GetModuleType;
    property Name: string read GetName;
    property FileName: string read GetFileName;
    property FormName: string read GetFormName;
    property DesignClass: string read GetDesignClass;
  end;

  IOTAModuleInfo160 = interface(IOTAModuleInfo50)
    ['{B3EEB4D2-ECDD-4CDC-B96E-B5C8F6D050A8}']
    /// <summary>
    /// Returns the Custom module type identifier 
    /// </summary>
    function GetCustomId: string;
    /// <summary>
    /// Fills the TStrings class with the Additional files 
    /// </summary>
    procedure GetAdditionalFiles(Files: TStrings);

    property CustomId: string read GetCustomId;
  end;

  IOTAModuleInfo = interface(IOTAModuleInfo160)
    ['{006DD7BE-55FD-4707-8C7E-3602C9721810}']
    procedure SetBuildAction(const Value: string);
    function GetBuildAction: string;

    property BuildAction: string read GetBuildAction write SetBuildAction;
  end;

  IOTAModule40 = interface(IUnknown)
    ['{F17A7BCC-E07D-11D1-AB0B-00C04FB16FB3}']
    /// <summary>
    /// Call this to register an IOTANotifier. The result is the index to be
    /// used when calling RemoveNotifier. If &lt;0 then an error occurred. 
    /// </summary>
    function AddNotifier(const ANotifier: IOTAModuleNotifier): Integer;
    /// <summary>
    /// This invokes the Add To Interface dialog in Delphi 
    /// </summary>
    procedure AddToInterface;
    /// <summary>
    /// Attempt to close this module. True was successful and all references to
    /// this module must be released. False if this module was not closed. 
    /// </summary>
    function Close: Boolean;
    /// <summary>
    /// Return the filename associated with this module.  This is only the base
    /// name used by the IDE.  Header source and forms are obtained other ways.
    /// </summary>
    function GetFileName: string;
    /// <summary>
    /// Return the currently assigned file system 
    /// </summary>
    function GetFileSystem: string;
    /// <summary>
    /// Returns the number of associated files (eg. Unit1.Pas and Unit1.dfm) 
    /// </summary>
    function GetModuleFileCount: Integer;
    /// <summary>
    /// Returns the associated file editor.  Use QueryInterface to determine if
    /// this is an IOTASourceEditor or IOTAFormEditor 
    /// </summary>
    function GetModuleFileEditor(Index: Integer): IOTAEditor;
    /// <summary>
    /// Return the number of open projects that own this module 
    /// </summary>
    function GetOwnerCount: Integer; deprecated;
    /// <summary>
    /// Return the Indexed Project that owns this module 
    /// </summary>
    function GetOwner(Index: Integer): IOTAProject; deprecated;
    /// <summary>
    /// Returns True if this modules has CoClasses.  Can be used to determine if
    /// AddToInterface can be called 
    /// </summary>
    function HasCoClasses: Boolean;
    /// <summary>
    /// Call with the index obtained from AddNotifier 
    /// </summary>
    procedure RemoveNotifier(Index: Integer);
    /// <summary>
    /// Save the module. ChangeName invokes the SaveAs logic.  ForceSave will not
    /// ask to save if the module is modified. Returns False if canceled
    /// or an error 
    /// </summary>
    function Save(ChangeName, ForceSave: Boolean): Boolean;
    /// <summary>
    /// Sets the module filename.  Header source and forms will use the base
    /// filename. 
    /// </summary>
    procedure SetFileName(const AFileName: string);
    /// <summary>
    /// Sets the associated file system 
    /// </summary>
    procedure SetFileSystem(const AFileSystem: string);

    property OwnerCount: Integer read GetOwnerCount;
    property Owners[Index: Integer]: IOTAProject read GetOwner;
    property FileName: string read GetFileName write SetFileName;
    property FileSystem: string read GetFileSystem write SetFileSystem;
  end;

  IOTAModule50 = interface(IOTAModule40)
    ['{15D3FB81-EF27-488E-B2B4-26B59CA89D9D}']
    /// <summary>
    /// CloseModule allows an add-in to force a module closed regardless of
    /// whether or not it is modified.  If ForceClosed is False, then calling
    /// this method has the same behavior as Close as implemented in
    /// IOTAModule40 
    /// </summary>
    function CloseModule(ForceClosed: Boolean): Boolean;

    // access to the IOTAEditors contained by a Module
    property ModuleFileCount: Integer read GetModuleFileCount;
    property ModuleFileEditors[Index: Integer]: IOTAEditor read GetModuleFileEditor;
  end;

  IOTAModule70 = interface(IOTAModule50)
    ['{2438BFB8-C742-48CD-8F50-DE6C7F764A55}']
    /// <summary>
    /// GetCurrentEditor returns the topmost editor associated with this module.
    /// If the form editor was the last editor focused, then that is returned,
    /// likewise, if one of the code editor was the last focused then that one
    /// is returned. 
    /// </summary>
    function GetCurrentEditor: IOTAEditor;
    /// <summary>
    /// Return the number of open modules that own this module 
    /// </summary>
    function GetOwnerModuleCount: Integer;
    /// <summary>
    /// Return the Indexed module that owns this module. If this is an IOTAProject
    /// then these two methods may not return and owner in the case where this is
    /// a package project and it is not a member of the currently open project group. 
    /// </summary>
    function GetOwnerModule(Index: Integer): IOTAModule;
    /// <summary>
    /// MarkModifed will mark this module as &quot;modified&quot; without actually indicating
    /// *why* is it modified (which will cause internal file dates to remain constant).
    /// This *will* force the IDE to ask to save this module when the user attempts
    /// to close it.  It will also clear the &quot;discardability&quot; of a new unnamed
    /// module such as when File|New|Application is selected. 
    /// </summary>
    procedure MarkModified;

    property CurrentEditor: IOTAEditor read GetCurrentEditor;
    property OwnerModuleCount: Integer read GetOwnerModuleCount;
    property OwnerModules[Index: Integer]: IOTAModule read GetOwnerModule;
  end;

  IOTAModule140 = interface(IOTAModule70)
    ['{7FF96161-E610-4414-B8B1-D1ECA76FEAFB}']
    /// <summary>
    /// Call show to show the default editor for the module. 
    /// </summary>
    procedure Show;
    /// <summary>
    /// Call ShowFilename to show the editor for the given filename associated
    /// with the module. 
    /// </summary>
    procedure ShowFilename(const FileName: string);
  end;

  IOTAModule = interface(IOTAModule140)
    ['{C0D4CBA8-54A3-48EA-BE63-98CE3D9F0F43}']
    /// <summary>
    /// Reloads the file/project from disk.  If ForceRefresh is set to false then
    /// the time date will be checked to see if the file needs to be reloaded. 
    /// </summary>
    procedure Refresh(ForceRefresh: Boolean);
    /// <summary>
    /// The results in FileList will be fully qualified names.
    /// For example c:\foo.pas could return c:\foo.dfm, or c:\foo.cpp could return
    /// c:\foo.dfm and c:\foo.h 
    /// </summary>
    procedure GetAssociatedFilesFromModule(FileList: TStrings);
 end;

  TOTARegionKind = Integer;

  TOTARegion = packed record
    /// <summary>
    /// RegionKind describes the type of region this is 
    /// </summary>
    RegionKind: TOTARegionKind;
    /// <summary>
    /// Start is the first location of the region 
    /// </summary>
    Start: TOTACharPos;
    /// <summary>
    /// Stop is the end of the regions 
    /// </summary>
    Stop: TOTACharPos;
    /// <summary>
    /// Name describes the region (this is typically info gleaned from a
    /// syntactic element.  It may be blank. 
    /// </summary>
    Name: string;
    /// <summary>
    /// Active will be true if this region will be considered by the compiler or
    /// whatever translator is used for the file.  This value will be True most of
    /// the time. 
    /// </summary>
    Active: Boolean;
  end;

  TOTARegions = array of TOTARegion;

  IOTAModuleRegions = interface(IInterface)
    ['{A7E7D74C-D123-4FAF-BE36-C4FE126B07FC}']
    /// <summary>
    /// Query an IOTAModule for this interface in order to obtain source code
    /// region information.  This info is applied to the editor buffer to describe
    /// those regions in the editor that can be collapsed/expanded 
    /// </summary>
    function GetRegions(const AFileName: string = ''): TOTARegions;
  end;

  TOTAError = packed record
    /// <summary>
    /// Text of the error message 
    /// </summary>
    Text: string;
    /// <summary>
    /// Start is the start of the error region 
    /// </summary>
    Start: TOTACharPos;
    /// <summary>
    /// Stop is the end of the error region. If Start = Stop then there is only
    /// a single character for the error 
    /// </summary>
    Stop: TOTACharPos;
    /// <summary>
    /// 1 = error, 2 = warning, 3 = hint 
    /// </summary>
    Severity: Integer;
  end;

  TOTAErrors = array of TOTAError;

  IOTAModuleErrors = interface(IInterface)
    ['{8626BF14-1526-4B88-826E-0935DB0DBB25}']
    /// <summary>
    /// Query an IOTAModule for this interface in order to obtain the source
    /// code error information. This information is then used by the editor to
    /// show error hints and red underlines where the errors are located in the
    /// source 
    /// </summary>
    function GetErrors(const AFileName: string = ''): TOTAErrors;
  end;

  IOTAAdditionalModuleFiles = interface
    ['{2D73A12F-6FB3-11D4-A4B8-00C04F6BB853}']
    function GetAdditionalModuleFileCount: Integer;
    /// <summary>
    /// Returns the associated IOTASourceEditor. 
    /// </summary>
    function GetAdditionalModuleFileEditor(Index: Integer): IOTAEditor;
    property AdditionalModuleFileCount: Integer read GetAdditionalModuleFileCount;
    property AdditionalModuleFileEditors[Index: Integer]: IOTAEditor read GetAdditionalModuleFileEditor;
  end;

  IOTAModuleData = interface
    ['{FFD0A5AF-49CB-4EC2-A658-957146030CEC}']
    function HasObjects: Boolean;
  end;

  IOTAModuleCleanup = interface
    ['{682E85BB-AF62-4868-BEFF-0C1515F006A8}']
    /// <summary>
    /// When implemented on a module, this method will delete generated files like .dcu, .exe, etc 
    /// </summary>
    procedure CleanupFiles;
  end;

  IOTATypeLibModule = interface(IOTAModule)
    ['{0BBAEEA0-EF74-11D1-AB1C-00C04FB16FB3}']
    function GetTypeLibEditor: IOTATypeLibEditor;
    function GetFileName: string;
    function GetModified: Boolean;

    property TypeLibEditor: IOTATypeLibEditor read GetTypeLibEditor;
    property FileName: string read GetFileName;
    property Modified: Boolean read GetModified;
  end;

  IOTAOptions = interface(IUnknown)
    ['{9C0E91FC-FA5A-11D1-AB28-00C04FB16FB3}']
    /// <summary>
    /// Opens the options dialog 
    /// </summary>
    procedure EditOptions;
    /// <summary>
    /// Get the value of the named option. 
    /// </summary>
    function GetOptionValue(const ValueName: string): Variant;
    /// <summary>
    /// Set the value of the named option. 
    /// </summary>
    procedure SetOptionValue(const ValueName: string; const Value: Variant);
    /// <summary>
    /// Get the list of available options for this option structure 
    /// </summary>
    function GetOptionNames: TOTAOptionNameArray;

    property Values[const ValueName: string]: Variant read GetOptionValue write SetOptionValue;
  end;

  IOTAProjectOptions40 = interface(IOTAOptions)
    ['{F17A7BD4-E07D-11D1-AB0B-00C04FB16FB3}']
  end;

  /// <summary>
  /// One special note about IOTAProjectOptions.
  /// Under Windows, there is one option called &quot;Keys&quot; and this options is of
  /// type tkClass.  This is a TStrings object and corresponds to the list of
  /// key/value pairs in the project's version info.  When GetOptionValue is
  /// called for the &quot;Keys&quot; Option it will be returned as a Variant varType of
  /// vtInteger.  You should cast the Variant result to Integer then to TStrings.
  /// NOTE: Do NOT free the TStrings object that is returned as this is owned by
  /// the internal object.  Calling SetOptionValue with a TStrings object (not
  /// the one read with GetOptionValue), will cause the typical &quot;SetKeys&quot; method
  /// to be called and the internal Keys object is &quot;Assigned&quot; the values from
  /// the given TStrings object (ie. FKeys.Assign(Value);) 
  /// </summary>

  IOTAProjectOptions70 = interface(IOTAProjectOptions40)
    ['{F899EBC6-E6E2-11D2-AA90-00C04FA370E9}']
    /// <summary>
    /// Set the modified state of the project options
    /// </summary>
    procedure SetModifiedState(State: Boolean);
    /// <summary>
    /// Get the modified state of the project options
    /// </summary>
    function GetModifiedState: Boolean;

    property ModifiedState: Boolean read GetModifiedState write SetModifiedState;
  end;

  IOTAProjectOptions = interface(IOTAProjectOptions70)
    ['{2888E741-E7FB-4BBC-A093-4B0903D9D990}']
    /// <summary>
    /// Returns what the final output target filename and path will be for this
    /// project 
    /// </summary>
    function GetTargetName: string;

    property TargetName: string read GetTargetName;
  end;

  /// <summary>
  /// 
  /// Provides access to a Build Configuration.  For methods that take a &quot;PropName&quot;
  /// parameter, the list of valid PropNames can be found in the following source
  /// files:
  ///   DCCStrs.pas:   names for Delphi compiler options
  ///   BCCStrs.pas:   names for the C++ compiler options
  ///   ILinkStrs.pas: names for the C++ linker options
  ///   TLibStrs.pas:  names for the TLib tool options
  ///   TasmStrs.pas:  names for the turbo assembler options
  ///   BRCCStrs.pas:  names for the resource compiler options
  ///   CommonOptionStrs.pas: names for general project options shared between Delphi and C++
  ///   CppCommonOptionStrs.pas: names for general C++ project options
  ///   
  /// </summary>
  IOTABuildConfiguration140 = interface(IUnknown)
    ['{92A52A72-B0D2-4898-8A20-298132F74C16}']
    /// <summary>
    /// The following methods provide information about this Build Configuration 
    /// </summary>
    /// <summary>
    /// Get the name of the configuration.  This may be translated 
    /// </summary>
    function GetName: string;
    /// <summary>
    /// Set the name of this configuration 
    /// </summary>
    procedure SetName(const Value: string);
    /// <summary>
    /// Return the configuration's unique key -- this is non-translatable 
    /// </summary>
    function GetKey: string;
    /// <summary>
    /// Return the parent of this IOTABuildConfiguration. Only the &quot;Base&quot; configuration
    /// should return nil 
    /// </summary>
    function GetParent: IOTABuildConfiguration;
    /// <summary>
    /// Return the number of configurations based directly on this build configuration,
    /// including local overrides 
    /// </summary>
    function GetChildCount: Integer;
    /// <summary>
    /// Return the index'd configuration based directly on this build configuration,
    /// including local overrides 
    /// </summary>
    function GetChild(Index: Integer): IOTABuildConfiguration;
    /// <summary>
    /// Return the number of properties specified at this configuration 
    /// </summary>
    function GetPropertyCount: Integer;
    /// <summary>
    /// Return the index'd property specified at this configuration 
    /// </summary>
    function GetPropertyName(Index: Integer): string;
    /// <summary>
    /// Returns whether or not the configuration has any properties at all 
    /// </summary>
    function IsEmpty: Boolean;
    /// <summary>
    /// Returns whether or not the configuration has been modified since last save 
    /// </summary>
    function IsModified: Boolean;
    /// <summary>
    /// Remove all properties with name &quot;PropName&quot; from the configuration 
    /// </summary>
    procedure Remove(const PropName: string);
    /// <summary>
    /// Remove all properties 
    /// </summary>
    procedure Clear;
    /// <summary>
    /// Returns true if the property &quot;PropName&quot; has any value, including a null
    /// or empty value, false if no property of that name exists in the configuration 
    /// </summary>
    function PropertyExists(const PropName: string): Boolean;

    /// <summary>
    /// The following methods are getters and setters for individual properties.  Any
    /// property can be set/get as a string using GetValue/SetValue 
    /// </summary>
    /// <summary>
    /// Retrieve the value of property &quot;PropName&quot; recursing through parent configurations.
    /// Returns empty string if the property doesn't exist. Can't tell empty properties
    /// from non-existent ones, use PropertyExists() to determine if a property actually is
    /// specified. 
    /// </summary>
    function GetValue(const PropName: string): string; overload;
    /// <summary>
    /// Perform an evaluation the value of property &quot;PropName&quot; as a string,
    /// optionally recursing through parent configurations. If IncludeInheritedValues=false,
    /// the value is determined at this configuration only. 
    /// </summary>
    function GetValue(const PropName: string; IncludeInheritedValues: Boolean): string; overload;
    /// <summary>
    /// Set the value of property &quot;PropName&quot; 
    /// </summary>
    procedure SetValue(const PropName, Value: string);
    /// <summary>
    /// Perform a full evaluation the value of property &quot;PropName&quot; as a boolean,
    /// recursing through parent configurations to determine the value if
    /// none is specified on this configuration.
    /// Assumes empty value to be 'false' if no default value for the property is
    /// specified. Raises an exception if the property value cannot be
    /// converted to a boolean. 
    /// </summary>
    function GetBoolean(const PropName: string): Boolean; overload;
    /// <summary>
    /// Perform an evaluation the value of property &quot;PropName&quot; as a boolean,
    /// optionally recursing through parent configurations. If IncludeInheritedValues=false,
    /// the value is determined at this configuration only.
    /// Assumes empty value to be 'false' if no default value for the property is
    /// specified. Raises an exception if the property value cannot be
    /// converted to a boolean. 
    /// </summary>
    function GetBoolean(const PropName: string; IncludeInheritedValues: Boolean): Boolean; overload;
    /// <summary>
    /// Sets value of &quot;PropName&quot; as a boolean on this configuration 
    /// </summary>
    procedure SetBoolean(const PropName: string; const Value: Boolean);
    /// <summary>
    /// Perform a full evaluation the value of property &quot;PropName&quot; as an integer,
    /// recursing through parent configurations to determine the value if
    /// none is specified on this configuration.
    /// Raises an exception if the property value cannot be converted to an integer. 
    /// </summary>
    function GetInteger(const PropName: string): Integer; overload;
    /// <summary>
    /// Perform an evaluation the value of property &quot;PropName&quot; as an integer,
    /// optionally recursing through parent configurations. If IncludeInheritedValues=false,
    /// the value is determined at this configuration only.
    /// Assumes empty value to be 'false' if no default value for the property is
    /// specified. Raises an exception if the property value cannot be
    /// converted to an integer. 
    /// </summary>
    function GetInteger(const PropName: string; IncludeInheritedValues: Boolean): Integer; overload;
    /// <summary>
    /// Sets value of &quot;PropName&quot; as an integer on this configuration 
    /// </summary>
    procedure SetInteger(const PropName: string; const Value: Integer);
    /// <summary>
    /// Evaluates the value of &quot;PropName&quot; up to, but not including, this build
    /// configuration as a string 
    /// </summary>
    function InheritedValue(const PropName: string): string;

    /// <summary>
    /// The following methods operate on properties that are lists of items, i.e
    /// a list of paths 
    /// </summary>
    /// <summary>
    /// Perform an evaluation the value of property &quot;PropName&quot; as a string list,
    /// optionally recursing through parent configurations. If IncludeInheritedValues=false,
    /// the value is determined at this configuration only 
    /// </summary>
    procedure GetValues(const PropName: string; Values: TStrings;
      IncludeInheritedValues: Boolean = True);
    /// <summary>
    /// For properties that are a list type, return whether or not the property
    /// &quot;PropName&quot; contains &quot;Value&quot; as one of its elements 
    /// </summary>
    function ContainsValue(const PropName, Value: string): Boolean;
    /// <summary>
    /// Insert one or more values into a list-type property, at index 'Location' 
    /// </summary>
    procedure InsertValues(const PropName: string; const Values: array of string; Location: Integer = -1);
    /// <summary>
    /// Replaces all values of list-type property &quot;PropName&quot; with &quot;Values&quot; 
    /// </summary>
    procedure SetValues(const PropName: string; const Values: TStrings);
    /// <summary>
    /// Removes 'Values' from list-type properties if they exist 
    /// </summary>
    procedure RemoveValues(const PropName: string; const Values: array of string);
    /// <summary>
    /// Evaluates the value of &quot;PropName&quot; up to, but not including, this build
    /// configuration as a string list. Only valid for list-type properties 
    /// </summary>
    procedure InheritedValues(const PropName: string; Values: TStrings; IgnoreMerged: Boolean = False);
    /// <summary>
    /// Return whether or not the property inherits values from its parent
    /// configuration.  Merging only makes sense for list-type properties.
    /// To illustrate:
    /// If a parent configuration defines a property as:
    ///   ListItem1;ListItem2
    /// and a child configuration defines the same property as:
    ///   ListItem3;ListItem4
    /// then if the property is merged, the fully-merged value in the child
    /// configuration would be:
    ///   ListItem3;ListItem4;ListItem1;ListItem2
    /// If the property is not merged, the value in the child configuration
    /// would be just:
    ///   ListItem3;ListItem4
    /// In the project file, merged properties contain a reference to their own
    /// name as one of their values:
    ///   &lt;PropertyName&gt;ListItem3;Listitem4;$(PropertyName)&lt;/PropertyName&gt; 
    /// </summary>
    function GetMerged(const PropName: string): Boolean;
    /// <summary>
    /// Controls whether or not the property &quot;PropName&quot; has it's value
    /// merged with inherited values from parent configurations. 
    /// </summary>
    procedure SetMerged(const PropName: string; Value: Boolean);

    property Name: string read GetName write SetName;
    property Key: string read GetKey;
    property Parent: IOTABuildConfiguration read GetParent;
    property ChildCount: Integer read GetChildCount;
    property Children[Index: Integer]: IOTABuildConfiguration read GetChild;
    property PropertyCount: Integer read GetPropertyCount;
    property Properties[Index: Integer]: string read GetPropertyName;
    property Value[const PropName: string]: string read GetValue write SetValue; default;
    property AsBoolean[const PropName: string]: Boolean read GetBoolean write SetBoolean;
    property AsInteger[const PropName: string]: Integer read GetInteger write SetInteger;
    property Merged[const PropName: string]: Boolean read GetMerged write SetMerged;
  end;

  IOTABuildConfiguration150 = interface(IOTABuildConfiguration140)
    ['{803E66A4-0B49-4A9D-B236-55BFF2610B9A}']
    function GetPlatformConfiguration(const PlatformName: string): IOTABuildConfiguration;
    function GetPlatform: string;
    function GetPlatforms: TArray<string>;

    property Platform: string read GetPlatform;
    property Platforms: TArray<string> read GetPlatforms;
    property PlatformConfiguration[const PlatformName: string]: IOTABuildConfiguration
      read GetPlatformConfiguration;
  end;

  IOTABuildConfiguration = interface(IOTABuildConfiguration150)
    ['{986E6AB2-3C11-43E2-9341-AC0AEF6A99D1}']
    function GetLocalOverride(const Filename: string): IOTABuildConfiguration;
    property LocalOverride[const Filename: string]: IOTABuildConfiguration
      read GetLocalOverride;
  end;

  /// <summary>
  /// Provides access to a project's Build Configurations.  You can query the IOTAProjectOptions
  /// instance for this interface 
  /// </summary>
  IOTAProjectOptionsConfigurations140 = interface(IUnknown)
    ['{E158B38A-90BF-425E-A634-0358B794870E}']
    /// <summary>
    /// Return the number of configurations in this project 
    /// </summary>
    function GetConfigurationCount: Integer;
    /// <summary>
    /// Return the index'd configuration in this project 
    /// </summary>
    function GetConfiguration(Index: Integer): IOTABuildConfiguration;
    /// <summary>
    /// Return the active configuration for this project 
    /// </summary>
    function GetActiveConfiguration: IOTABuildConfiguration;
    /// <summary>
    /// Set the active configuration for this project 
    /// </summary>
    procedure SetActiveConfiguration(const Value: IOTABuildConfiguration);
    /// <summary>
    /// Return the Base configuration in this project 
    /// </summary>
    function GetBaseConfiguration: IOTABuildConfiguration;
    /// <summary>
    /// Add a new configuration with the specified name, descending from the specified
    /// Parent configuration.  Returns the added configuration 
    /// </summary>
    function AddConfiguration(const Name: string; Parent: IOTABuildConfiguration): IOTABuildConfiguration;
    /// <summary>
    /// Remove the configuration with the specified Name or Key 
    /// </summary>
    procedure RemoveConfiguration(const Name: string);

    property ConfigurationCount: Integer read GetConfigurationCount;
    property Configurations[Index: Integer]: IOTABuildConfiguration read GetConfiguration;
    property ActiveConfiguration: IOTABuildConfiguration read GetActiveConfiguration write SetActiveConfiguration;
    property BaseConfiguration: IOTABuildConfiguration read GetBaseConfiguration;
  end;

  IOTAProjectOptionsConfigurations230 = interface(IOTAProjectOptionsConfigurations140)
    ['{BDC06BC9-A56C-41D2-BF41-DDA76570809A}']
    /// <summary>
    /// Return currently active configuration's name 
    /// </summary>
    function GetCurrentConfigurationName: string;
    function GetCurrentPlatformName: string;

    property ActiveConfigurationName: string read GetCurrentConfigurationName;
    property ActivePlatformName: string read GetCurrentPlatformName;
  end;

  IOTAProjectOptionsConfigurations = interface(IOTAProjectOptionsConfigurations230)
    ['{55A4A36F-210E-4B0B-BD2D-A15354992A5C}']
    /// <summary>
    /// Returns the active mobile device Id 
    /// </summary>
    function GetActiveMobileDevice(const PlatformName: string): string;
    property ActiveMobileDevice[const PlatformName: string]: string read GetActiveMobileDevice;
  end;

  IOTAProjectBuilder40 = interface(IUnknown)
    ['{F17A7BD5-E07D-11D1-AB0B-00C04FB16FB3}']
    /// <summary>
    /// True if the project is out of date and needs to be built 
    /// </summary>
    function GetShouldBuild: Boolean;
    /// <summary>
    /// True if successfully built.  If Wait then the compile progress dialog
    /// aits for the user press OK.  If False, it does not wait if successful. 
    /// </summary>
    function BuildProject(CompileMode: TOTACompileMode; Wait: Boolean): Boolean;

    property ShouldBuild: Boolean read GetShouldBuild;
  end;

  TOTAProjectCompileInfo = record
    Mode: TOTACompileMode;
    Configuration: string;
    Platform: string;
    Result: Boolean;
  end;

  IOTAProjectCompileNotifier = interface
    ['{D78E04B9-80D8-4214-920F-CB15B571654F}']
    /// <summary>
    /// This notifier is called after a compile 
    /// </summary>
    procedure AfterCompile(var CompileInfo: TOTAProjectCompileInfo);
    /// <summary>
    /// This notifier is called before a compile 
    /// </summary>
    procedure BeforeCompile(var CompileInfo: TOTAProjectCompileInfo);
    /// <summary>
    /// The associated project builder is being destroyed so all references
    /// should be dropped 
    /// </summary>
    procedure Destroyed;
  end;

  IOTAProjectBuilder140 = interface(IOTAProjectBuilder40)
    ['{08A5B1F5-FCDA-11D2-AC82-00C04FB173DC}']
    /// <summary>
    /// True if successfully built.  If Wait then the compile progress dialog
    /// waits for the user press OK.  If False, it does not wait if successful. 
    /// </summary>
    function BuildProject(CompileMode: TOTACompileMode; Wait, ClearMessages: Boolean): Boolean; overload;
  end;

  IOTAProjectBuilder = interface(IOTAProjectBuilder140)
    ['{76AD8696-B58C-44B4-B4AE-C54702237279}']
    /// <summary>
    /// Call this to register an IOTAProjectCompileNotifier. The result is the
    /// index to be used when calling RemoveNotifier. If &lt;0 then an error occurred. 
    /// </summary>
    function AddCompileNotifier(const Notifier: IOTAProjectCompileNotifier): Integer;
    /// <summary>
    /// Removes the specified notifier (NotifierIndex should be an index reteurned
    /// by a previous call to RemoveCompileNotifier 
    /// </summary>
    procedure RemoveCompileNotifier(NotifierIndex: Integer);
  end;

  IOTAProject40 = interface(IOTAModule)
    ['{F17A7BCA-E07D-11D1-AB0B-00C04FB16FB3}']
    /// <summary>
    /// Return the number of owned modules 
    /// </summary>
    function GetModuleCount: Integer;
    /// <summary>
    /// Return the Indexed owned Module Info 
    /// </summary>
    function GetModule(Index: Integer): IOTAModuleInfo;
    /// <summary>
    /// Return the Project options 
    /// </summary>
    function GetProjectOptions: IOTAProjectOptions;
    /// <summary>
    /// Return the Project Builder 
    /// </summary>
    function GetProjectBuilder: IOTAProjectBuilder;

    property ProjectOptions: IOTAProjectOptions read GetProjectOptions;
    property ProjectBuilder: IOTAProjectBuilder read GetProjectBuilder;
  end;

  IOTAProject70 = interface(IOTAProject40)
    ['{06C88136-F367-4D47-B8B4-CCACB3D7439A}']
    /// <summary>
    /// Call this function to add an arbitrary file to the project.  NOTE: some
    /// files have special meaning to different projects.  For example: adding
    /// VCL60.DCP will cause a new entry in a package project's &quot;requires&quot; list
    /// while it will be a raw file to any other project type.  Set IsUnitOrForm
    /// to true for files that are considered items that the project would
    /// process directly or indirectly (ie. .pas, .cpp, .rc, etc..) or can be
    /// opened in the code editor. For all others, including binary files
    /// (.res, .bpi, .dcp, etc..) set this to False. 
    /// </summary>
    procedure AddFile(const AFileName: string; IsUnitOrForm: Boolean);
    /// <summary>
    /// Call this function to remove an arbitrary file from the project.  This
    /// must be a fully qualified filename.  See GetModule() above for info on
    /// obtaining this information from a Form name or unit name 
    /// </summary>
    procedure RemoveFile(const AFileName: string);
  end;

  IOTAProject90 = interface(IOTAProject70)
    ['{BBBE4CC6-36DE-4986-BD9E-9DF0F06FC8F1}']
    /// <summary>
    /// This is the same as AddFile but allows you to specify a parent.  A Parent
    /// is a project Ident, most commonly a filename.  If your file has a parent
    /// then it will appear under the file in the project manager. If both the
    /// parent and child has the same file name with different extentions then a
    /// rename or 'save as' of the parent will also save the child with the same
    /// base name. 
    /// </summary>
    procedure AddFileWithParent(const AFileName: string; IsUnitOrForm: Boolean;
      const Parent: string);
    /// <summary>
    /// Each project is assigned a unique GUID.  This method returns this GUID. 
    /// </summary>
    function GetProjectGUID: TGUID;
    /// <summary>
    /// Each project has a specific personality 
    /// </summary>
    function GetPersonality: string;
    /// <summary>
    /// Find the ModuleInfo for a given filename, if it exists in the project.
    /// Otherwise, it returns null 
    /// </summary>
    function FindModuleInfo(const FileName: string): IOTAModuleInfo;

    property ProjectGUID: TGUID read GetProjectGUID;
    property Personality: string read GetPersonality;
  end;

  IOTAProject100 = interface(IOTAProject90)
    ['{D0090018-D879-41FC-8F83-AA4F40098ACF}']
    /// <summary>
    /// Renames file using the same logic as an inplace rename in
    /// the project manager. 
    /// </summary>
    function Rename(const OldFileName, NewFileName: string): Boolean;
  end;

  IOTAProject120 = interface(IOTAProject100)
    ['{3D7E07CB-392D-4EFB-841D-A6C6E338CF13}']
    function GetProjectType: string;

    property ProjectType: string read GetProjectType;
  end;

  IOTAProject140 = interface(IOTAProject120)
    ['{6B1A57F9-34A3-4824-96F0-750A63328C4E}']
    /// <summary>
    /// Returns a list of fully qualified file names.  This will contain files
    /// that do not show up in the project manager, for example, the project's
    /// .res file 
    /// </summary>
    procedure GetCompleteFileList(FileList: TStrings);
    /// <summary>
    /// Returns the files associated with FileName.  FileName should be a fully
    /// qualified name.  The results in FileList will be fully qualified names.
    /// For example c:\foo.pas could return c:\foo.dfm, or c:\foo.cpp could return
    /// c:\foo.dfm and c:\foo.h 
    /// </summary>
    procedure GetAssociatedFiles(const FileName: string; FileList: TStrings);
    /// <summary>
    /// Returns the transaction for a given file.  FileName should be a fully
    /// qualified name. If, for the example, c:\foo.pas gets renamed to c:\goo.pas,
    /// and c:\goo.pas subsequently gets renamed to c:\doo.pas, calling this
    /// function with FileName='c:\goo.pas' will set InitialName='c:\foo.pas' and
    /// CurrentName='c:\doo.pas'. If CurrentName is an empty string, this indicates
    /// that the file was deleted.  The function returns True if the file is found
    /// in the transaction list and False if it is not found 
    /// </summary>
    function GetFileTransaction(const FileName: string; var InitialName,
      CurrentName: string): Boolean;
  end;

  TOTATransactionType = (ttAdd, ttDelete, ttRename);

  /// <summary>
  /// IOTATransactionItem describes a project transaction 
  /// </summary>
  IOTATransactionItem = interface
    ['{F947EF3D-13C7-465F-AD78-621AFF0A7E8C}']
    /// <summary>
    /// Returns the name of the file being added or deleted or the new name of a
    /// file being renamed 
    /// </summary>
    function GetFileName: string;
    /// <summary>
    /// Returns the old name for a file being renemed 
    /// </summary>
    function GetOldFileName: string;
    /// <summary>
    /// Returns the date and time of the transaction (add, delete or rename) 
    /// </summary>
    function GetTime: TDateTime;
    /// <summary>
    /// Returns the transaction type 
    /// </summary>
    function GetTransactionType: TOTATransactionType;

    property FileName: string read GetFileName;
    property OldFileName: string read GetOldFileName;
    property Time: TDateTime read GetTime;
    property TransactionType: TOTATransactionType read GetTransactionType;
  end;

  IOTAProject150 = interface(IOTAProject140)
    ['{A6287B50-DA09-44EF-AA80-9D1CAFDE7857}']
    /// <summary>
    /// Call BeginFileTransactionUpdate before accessing the transaction list 
    /// </summary>
    procedure BeginFileTransactionUpdate;
    /// <summary>
    /// Call EndFileTransactionUpdate before accessing the transaction list. If
    /// CommitUpdate is true, the transaction list will be cleared 
    /// </summary>
    procedure EndFileTransactionUpdate(CommitUpdate: Boolean);
    /// <summary>
    /// Fills the &quot;FileList&quot; parameter with IOTATransactionItem instances that
    /// represent the project transactions that have occurred 
    /// </summary>
    procedure GetAddedDeletedFiles(const FileList: IInterfaceList);
    /// <summary>
    /// Fills the &quot;FileList&quot; parameter with IOTATransactionItem instances that
    /// represent the project transactions that have occurred for the specified
    /// FileName 
    /// </summary>
    function GetFileTransactionList(const FileName: string; FileList: IInterfaceList): Boolean;
  end;

  IOTAProject160 = interface(IOTAProject150)
    ['{F5EA2A72-485D-49E8-B60A-B0E7C7B80A27}']
    function GetConfiguration: string;
    function GetFrameworkType: string;
    function GetPlatform: string;
    procedure SetConfiguration(const Value: string);
    procedure SetPlatform(const Value: string);
    function GetSupportedPlatforms: TArray<string>;

    property CurrentConfiguration: string read GetConfiguration write SetConfiguration;
    property CurrentPlatform: string read GetPlatform write SetPlatform;
    property FrameworkType: string read GetFrameworkType;
    property SupportedPlatforms: TArray<string> read GetSupportedPlatforms;
  end;

  IOTAProject = interface(IOTAProject160)
    ['{0E4BFB1D-2F3B-4CD6-A9A2-4903713B59E0}']
    /// <summary>
    /// Gets the string that names the type of project in a generic way, independently
    /// of the personality 
    /// </summary>
    function GetApplicationType: string;

    property ApplicationType: string read GetApplicationType;
  end;

  IOTAProjectNotifier = interface(IOTAModuleNotifier)
    ['{75A09281-AD20-427B-A506-4712D0A64164}']
    /// <summary>
    /// This notifier will be called when a file/module is added to the project 
    /// </summary>
    procedure ModuleAdded(const AFileName: string);
    /// <summary>
    /// This notifier will be called when a file/module is removed from the project 
    /// </summary>
    procedure ModuleRemoved(const AFileName: string);
    /// <summary>
    /// This notifier will be called when a file/module is renamed in the project 
    /// </summary>
    procedure ModuleRenamed(const AOldFileName, ANewFileName: string);
  end;

  /// <summary>
  /// An IOTAProject can be queried for IOTAProjectCurrentFolder (not all projects
  /// will support this interface) 
  /// </summary>
  IOTAProjectCurrentFolder = interface
    ['{D86ED6B5-974A-4657-B94A-D34F0597FEDD}']
    /// <summary>
    /// Return the current directory for this project 
    /// </summary>
    function GetCurrentFolderPath: string;

    property CurrentFolderPath: string read GetCurrentFolderPath;
  end;

  IOTAProjectGroup160 = interface(IOTAModule)
    ['{F17A7BCB-E07D-11D1-AB0B-00C04FB16FB3}']
    /// <summary>
    /// Invoke the Add New Project Dialog 
    /// </summary>
    procedure AddNewProject;
    /// <summary>
    /// Invoke the Open New Project Dialog 
    /// </summary>
    procedure AddExistingProject;
    /// <summary>
    /// Return the currently active project 
    /// </summary>
    function GetActiveProject: IOTAProject;
    /// <summary>
    /// Number of Projects in this project group 
    /// </summary>
    function GetProjectCount: Integer;
    /// <summary>
    /// Return the Project interface 
    /// </summary>
    function GetProject(Index: Integer): IOTAProject;
    /// <summary>
    /// Remove the given project from the project group 
    /// </summary>
    procedure RemoveProject(const AProject: IOTAProject);
    /// <summary>
    /// Set the active project 
    /// </summary>
    procedure SetActiveProject(const AProject: IOTAProject);

    property ActiveProject: IOTAProject read GetActiveProject write SetActiveProject;
    property ProjectCount: Integer read GetProjectCount;
    property Projects[Index: Integer]: IOTAProject read GetProject;
  end;

  IOTAProjectGroup = interface(IOTAProjectGroup160)
    ['{B9EAE73C-8A03-4729-A232-EEE626801A0B}']
   /// <summary>
   /// Look for the project that the file belongs to. First check in the active
   /// project. If the file isn't in the active project then check the other
   /// open projects. 
   /// </summary>
    function FindProject(const FileName: string): IOTAProject;
  end;

  IOTAProjectDependenciesList = interface(IInterface)
    ['{4D87F08B-A6A6-4C0F-AC33-D6CE792EC522}']
    /// <summary>
    /// Add a project to the list 
    /// </summary>
    procedure AddProject(const AProject: IOTAProject);
    /// <summary>
    /// Returns the number of projects in the list 
    /// </summary>
    function GetProjectCount: Integer;
    /// <summary>
    /// Returns the index'd project in the list 
    /// </summary>
    function GetProject(Index: Integer): IOTAProject;
    /// <summary>
    /// Remove a project from the list 
    /// </summary>
    procedure RemoveProject(const AProject: IOTAProject);

    property ProjectCount: Integer read GetProjectCount;
    property Projects[Index: Integer]: IOTAProject read GetProject;
  end;

  IOTAProjectGroupProjectDependencies = interface(IInterface)
    ['{9B6203FF-7019-49D5-B3DF-6FBDFC61BACE}']
    /// <summary>
    /// Returns an empty IOTAProjectDependenciesList 
    /// </summary>
    function GetEmptyProjectDependenciesList: IOTAProjectDependenciesList;
    /// <summary>
    /// Return current dependencies AProject depends upon 
    /// </summary>
    function GetProjectDependencies(const AProject: IOTAProject): IOTAProjectDependenciesList;
    /// <summary>
    /// Return the projects that AProject can validly depend on.  This function will not return
    /// any circular references. 
    /// </summary>
    function GetValidProjectDependencies(const AProject: IOTAProject): IOTAProjectDependenciesList;
    /// <summary>
    /// Set the dependencies on AProject 
    /// </summary>
    procedure SetProjectDependencies(const AProject: IOTAProject; const ADependencies: IOTAProjectDependenciesList);
  end;

  IOTAActionServices = interface(IUnknown)
    ['{F17A7BC9-E07D-11D1-AB0B-00C04FB16FB3}']
    /// <summary>
    /// Action interfaces 
    /// </summary>
    function CloseFile(const FileName: string): Boolean;
    function OpenFile(const FileName: string): Boolean;
    function OpenProject(const ProjName: string; NewProjGroup: Boolean): Boolean;
    function ReloadFile(const FileName: string): Boolean;
    function SaveFile(const FileName: string): Boolean;
  end;

  IOTAFileFilter = interface(IInterface)
    ['{14DBB1D5-9802-458E-A8C3-606237708939}']
    function GetStream(const AFileName: string; const AStream: IStream): IStream;
    function HandlesStream(const AFileName: string; const AStream: IStream): Boolean;
    function GetIDString: string;
    function GetDisplayName: string;
    property DisplayName: string read GetDisplayName;
    property IDString: string read GetIDString;
  end;

  IOTAFileFilterByName = interface(IOTAFileFilter)
    ['{0624E15E-A4E1-45D6-8D24-FDF67133E483}']
  end;

  IOTAFileFilterWithCheckEncode = interface(IOTAFileFilter)
    ['{17E89149-6F65-416f-88EA-B949449BA9A0}']
    function GetInvalidCharacterException: Boolean;
    procedure SetInvalidCharacterException(const Value: Boolean);
    function GetIgnoreException: Boolean;
    procedure SetIgnoreException(const Value: Boolean);
    property InvalidCharacterException: Boolean read GetInvalidCharacterException write SetInvalidCharacterException;
    property IgnoreException: Boolean read GetIgnoreException write SetIgnoreException;
  end;

  IOTAFileFilterServices = interface(IInterface)
    ['{84302AE6-646C-4547-85F1-4FB0839038E2}']
    function GetDefaultFilter: IOTAFileFilter;
    procedure SetDefaultFilter(const Value: IOTAFileFilter);
    function GetFilterHandler(const FileName: string; const AStream: IStream): IOTAFileFilter;
    function GetFileFilterCount: Integer;
    function GetFileFilter(Index: Integer): IOTAFileFilter;
    function AddFileFilter(const AFileFilter: IOTAFileFilter): Integer;
    function GetMessageGroupName: string;
    procedure RemoveFileFilter(Index: Integer);
    property DefaultFilter: IOTAFileFilter read GetDefaultFilter write SetDefaultFilter;
    property FileFilter[Index: Integer]: IOTAFileFilter read GetFileFilter;
    property FileFilterCount: Integer read GetFileFilterCount;
    property MessageGroupName: string read GetMessageGroupName;
  end;

  /// <summary>
  /// IOTAStreamModifyTime - this interface should be implemented on an IStream if
  /// the IStream reflects a file-system file.  This allows the IDE to get and set
  /// the file age.  This is in DOS date-time format. 
  /// </summary>

  IOTAStreamModifyTime = interface(IInterface)
    ['{49F2F63F-60CB-4FD4-B12F-8167FC79B293}']
    function GetModifyTime: Longint; stdcall;
    procedure SetModifyTime(Time: Longint); stdcall;
  end;

  IOTAFileSystem = interface(IInterface)
    ['{A9D1389D-F4B0-11D1-AB22-00C04FB16FB3}']
    function GetFileStream(const FileName: string; Mode: Integer): IStream;
    function FileAge(const FileName: string): Longint;
    function RenameFile(const OldName, NewName: string): Boolean;
    function IsReadonly(const FileName: string): Boolean;
    function IsFileBased: Boolean;
    function DeleteFile(const FileName: string): Boolean;
    function FileExists(const FileName: string): Boolean;
    function GetTempFileName(const FileName: string): string;
    function GetBackupFileName(const FileName: string): string;
    function GetIDString: string;
  end;

  IOTAFileSystem80 = interface(IOTAFileSystem)
    ['{A9C2BD51-0372-47B6-8831-AA774CD5AC37}']
    function GetFilter: IOTAFileFilter;
  end;

  IOTAFile = interface(IUnknown)
    ['{6E2AD9B0-F7F0-11D1-AB26-00C04FB16FB3}']
    /// <summary>
    /// Return the actual source code 
    /// </summary>
    function GetSource: string;
    /// <summary>
    /// Return the age of the file. -1 if new 
    /// </summary>
    function GetAge: TDateTime;

    property Source: string read GetSource;
    property Age: TDateTime read GetAge;
  end;

  IOTACreator = interface(IUnknown)
    ['{6EDB9B9E-F57A-11D1-AB23-00C04FB16FB3}']
    /// <summary>
    /// Return a string representing the default creator type in which to augment.
    /// See the definitions of sApplication, sConsole, sLibrary and
    /// sPackage, etc.. above.  Return an empty string indicating that this
    /// creator will provide *all* information 
    /// </summary>
    function GetCreatorType: string;
    /// <summary>
    /// Return False if this is a new module 
    /// </summary>
    function GetExisting: Boolean;
    /// <summary>
    /// Return the File system IDString that this module uses for reading/writing 
    /// </summary>
    function GetFileSystem: string;
    /// <summary>
    /// Return the Owning module, if one exists (for a project module, this would
    /// be a project; for a project this is a project group) 
    /// </summary>
    function GetOwner: IOTAModule;
    /// <summary>
    /// Return true, if this item is to be marked as un-named.  This will force the
    /// save as dialog to appear the first time the user saves. 
    /// </summary>
    function GetUnnamed: Boolean;

    property CreatorType: string read GetCreatorType;
    property Existing: Boolean read GetExisting;
    property FileSystem: string read GetFileSystem;
    property Owner: IOTAModule read GetOwner;
    property Unnamed: Boolean read GetUnnamed;
  end;

  IOTAModuleCreator = interface(IOTACreator)
    ['{6EDB9B9A-F57A-11D1-AB23-00C04FB16FB3}']
    /// <summary>
    /// Return the Ancestor form name 
    /// </summary>
    function GetAncestorName: string;
    /// <summary>
    /// Return the implementation filename, or blank to have the IDE create a new
    /// unique one. (C++ .cpp file or Delphi unit) NOTE: If a value is returned then it *must* be a
    /// fully qualified filename.  This also applies to GetIntfFileName and
    /// GetAdditionalFileName on the IOTAAdditionalFilesModuleCreator interface. 
    /// </summary>
    function GetImplFileName: string;
    /// <summary>
    /// Return the interface filename, or blank to have the IDE create a new
    /// unique one.  (C++ header) 
    /// </summary>
    function GetIntfFileName: string;
    /// <summary>
    /// Return the form name 
    /// </summary>
    function GetFormName: string;
    /// <summary>
    /// Return True to Make this module the main form of the given Owner/Project 
    /// </summary>
    function GetMainForm: Boolean;
    /// <summary>
    /// Return True to show the form 
    /// </summary>
    function GetShowForm: Boolean;
    /// <summary>
    /// Return True to show the source 
    /// </summary>
    function GetShowSource: Boolean;
    /// <summary>
    /// Create and return the Form resource for this new module if applicable 
    /// </summary>
    function NewFormFile(const FormIdent, AncestorIdent: string): IOTAFile;
    /// <summary>
    /// Create and return the Implementation source for this module. (C++ .cpp
    /// file or Delphi unit) 
    /// </summary>
    function NewImplSource(const ModuleIdent, FormIdent, AncestorIdent: string): IOTAFile;
    /// <summary>
    /// Create and return the Interface (C++ header) source for this module 
    /// </summary>
    function NewIntfSource(const ModuleIdent, FormIdent, AncestorIdent: string): IOTAFile;
    /// <summary>
    /// Called when the new form/datamodule/custom module is created 
    /// </summary>
    procedure FormCreated(const FormEditor: IOTAFormEditor);

    property AncestorName: string read GetAncestorName;
    property FormName: string read GetFormName;
    property ImplFileName: string read GetImplFileName;
    property IntfFileName: string read GetIntfFileName;
    property MainForm: Boolean read GetMainForm;
    property ShowForm: Boolean read GetShowForm;
    property ShowSource: Boolean read GetShowSource;
  end;

  IOTAAdditionalFilesModuleCreator = interface(IOTAModuleCreator)
    ['{BACD1450-1AC5-11D4-A455-00C04F6BB853}']
    function GetAdditionalFilesCount: Integer;
    /// <summary>
    /// Create and return the source for this additional file 
    /// </summary>
    function NewAdditionalFileSource(I: Integer; const ModuleIdent, FormIdent, AncestorIdent: string): IOTAFile;
    /// <summary>
    /// Return the additional filename, or blank to have the IDE create a new
    /// unique one. 
    /// </summary>
    function GetAdditionalFileName(I: Integer): string;
    /// <summary>
    /// Get the file extent used to create a new file name 
    /// </summary>
    function GetAdditionalFileExt(I: Integer): string;
  end;

  /// <summary>
  /// In order to work properly in the current IDE, each IOTAProjectCreator should
  /// also implement IOTAProjectCreator80.  Failing to do so will cause your
  /// creator to either 1) take on the active personality in the IDE or 2) fail if
  /// there is no active personality at the time your creator is called. 
  /// </summary>

  IOTAProjectCreator = interface(IOTACreator)
    ['{6EDB9B9D-F57A-11D1-AB23-00C04FB16FB3}']
    /// <summary>
    /// Return the project filename. NOTE: This *must* be a fully qualified file name. 
    /// </summary>
    function GetFileName: string;
    /// <summary>
    /// Deprecated!! Return the option file name (C++ .bpr, .bpk, etc...) 
    /// </summary>
    function GetOptionFileName: string; deprecated;
    /// <summary>
    /// Return True to show the source 
    /// </summary>
    function GetShowSource: Boolean;
    /// <summary>
    /// Deprecated!! Called to create a new default module for this project.
    /// Please implement and use the method on IOTAProjectCreator50. 
    /// </summary>
    procedure NewDefaultModule; deprecated;
    /// <summary>
    /// Deprecated!! Create and return the project option source. (C++) 
    /// </summary>
    function NewOptionSource(const ProjectName: string): IOTAFile; deprecated;
    /// <summary>
    /// Called to indicate when to create/modify the project resource file 
    /// </summary>
    procedure NewProjectResource(const Project: IOTAProject);
    /// <summary>
    /// Create and return the Project source file 
    /// </summary>
    function NewProjectSource(const ProjectName: string): IOTAFile;

    property FileName: string read GetFileName;
    property OptionFileName: string read GetOptionFileName;
    property ShowSource: Boolean read GetShowSource;
  end;

  IOTAProjectCreator50 = interface(IOTAProjectCreator)
    ['{64312F82-62F3-48E9-BAF6-B03DF450312A}']
    /// <summary>
    /// Called to create a new default module(s) for the given project.  This
    /// interface method is the preferred mechanism. 
    /// </summary>
    procedure NewDefaultProjectModule(const Project: IOTAProject);
  end;

  IOTAProjectCreator80 = interface(IOTAProjectCreator50)
    ['{9A1D6AF5-84FA-481C-A446-746D9A50F53E}']
    /// <summary>
    /// Implement this interface and return the correct personality of the project
    /// to create.  The CreatorType function should return any sub-types that this
    /// personality can create.  For instance, in the Delphi.Personality, returning
    /// 'Package' from CreatorType will create a proper package project. 
    /// </summary>
    function GetProjectPersonality: string;

    property ProjectPersonality: string read GetProjectPersonality;
  end;

  IOTAProjectCreator160 = interface(IOTAProjectCreator80)
    ['{4334DF37-C1B6-4135-A665-762DC2DA4086}']
    /// <summary>
    /// Return the framework type string for the framework this application supports 
    /// </summary>
    function GetFrameworkType: string;
    /// <summary>
    /// Return the platform keys for the platforms this wizard selects 
    /// </summary>
    function GetPlatforms: TArray<string>;
    /// <summary>
    /// Return the project's &quot;preferred&quot; platform - the one that will be explicitly supported
    /// when the project is created 
    /// </summary>
    function GetPreferredPlatform: string;
    /// <summary>
    /// Set up any initial options 
    /// </summary>
    procedure SetInitialOptions(const NewProject: IOTAProject);
  end;

  IOTAProjectCreator190 = interface(IOTAProjectCreator160)
    ['{2E0ABEEB-F885-4BA5-BF6C-3A11F963F93E}']
    /// <summary>
    /// Return the platform keys for the platforms this wizard supports 
    /// </summary>
    function GetSupportedPlatforms: TArray<string>;
  end;

  IOTAProjectGroupCreator = interface(IOTACreator)
    ['{6EDB9B9F-F57A-11D1-AB23-00C04FB16FB3}']
    /// <summary>
    /// Return the project group file name 
    /// </summary>
    function GetFileName: string;
    /// <summary>
    /// Return True to show the source 
    /// </summary>
    function GetShowSource: Boolean;
    /// <summary>
    /// Deprecated/never called.  Create and return the project group source 
    /// </summary>
    function NewProjectGroupSource(const ProjectGroupName: string): IOTAFile; deprecated;

    property FileName: string read GetFileName;
    property ShowSource: Boolean read GetShowSource;
  end;

  IOTAModuleServices70 = interface(IUnknown)
    ['{F17A7BCD-E07D-11D1-AB0B-00C04FB16FB3}']
    /// <summary>
    /// Registers a new file system 
    /// </summary>
    function AddFileSystem(FileSystem: IOTAFileSystem): Integer;
    /// <summary>
    /// Close all open modules including the Project Group 
    /// </summary>
    function CloseAll: Boolean;
    /// <summary>
    /// Given the Creator, create a new module of the implied type 
    /// </summary>
    function CreateModule(const Creator: IOTACreator): IOTAModule;
    /// <summary>
    /// Return the currently active module 
    /// </summary>
    function CurrentModule: IOTAModule;
    /// <summary>
    /// Lookup the given file system 
    /// </summary>
    function FindFileSystem(const Name: string): IOTAFileSystem;
    /// <summary>
    /// Lookup the given module by form name 
    /// </summary>
    function FindFormModule(const FormName: string): IOTAModule;
    /// <summary>
    /// Lookup the given module by file name 
    /// </summary>
    function FindModule(const FileName: string): IOTAModule;
    /// <summary>
    /// Return the number of currently open modules 
    /// </summary>
    function GetModuleCount: Integer;
    /// <summary>
    /// Return an interface on the module at index 
    /// </summary>
    function GetModule(Index: Integer): IOTAModule;
    /// <summary>
    /// Given the Prefix, create a new unique Module name and class name 
    /// </summary>
    procedure GetNewModuleAndClassName(const Prefix: string; var UnitIdent,
      ClassName, FileName: string);
    /// <summary>
    /// Open the File|New dialog 
    /// </summary>
    function NewModule: Boolean;
    /// <summary>
    /// Removes the index'd file system from the installed file system list 
    /// </summary>
    procedure RemoveFileSystem(Index: Integer);
    /// <summary>
    /// Save all modules. Same as File|Save All 
    /// </summary>
    function SaveAll: Boolean;

    property ModuleCount: Integer read GetModuleCount;
    property Modules[Index: Integer]: IOTAModule read GetModule;
  end;

  IOTAModuleServices = interface(IOTAModuleServices70)
    ['{55A5E848-27FB-4880-8E7C-7F05A9802482}']
    /// <summary>
    /// Returns the currently open ProjectGroup 
    /// </summary>
    function GetMainProjectGroup: IOTAProjectGroup;
    /// <summary>
    /// Opens and returns IOTAModule representing the given file.  If the file is
    /// already open, then that module is returned. If you want to show the module
    /// you must call IOTAModule.Show, call IOTAModule.ShowFilename, or iterate
    /// through the module's editors and show one specifically.  If you never show
    /// the module, it will remain open and participate in any File|Close all, or
    /// File|Save all operations, which means the IDE may ask you to save the module
    /// if it is modified. 
    /// </summary>
    function OpenModule(const FileName: string): IOTAModule;
    /// <summary>
    /// Returns the currently active project.  This will return an &quot;unbound&quot;
    /// package project if one is open without a project group. 
    /// </summary>
    function GetActiveProject: IOTAProject;

    property MainProjectGroup: IOTAProjectGroup read GetMainProjectGroup;
  end;

  IOTAProcess = interface;
  IOTAThread = interface;

  TOTATriggerResult = (trStop, trContinue, trDefault);
  TOTAAccessType = (atRead, atWrite, atExecute);
  TOTARunMode = (ormRun,               //run the process
                 ormRunToEntry,        //run to the first source statement executed -- used for a process being started
                 ormRunToMain,         //run to the main entry-point (main, WinMain, etc.) -- used for a process being started
                 ormRunToCursor,       //run to the cursor location in the editor
                 ormStmtStepInto,      //step into source statement
                 ormStmtStepOver,      //step over source statement
                 ormInstStepInto,      //step into machine instruction
                 ormInstStepOver,      //step over machine instruction
                 ormStmtStepToSource,  //step to next source statement
                 ormRunToTerminate,    //run to termination -- identical to ormRun
                 ormRunUntilReturn,    //run until the current function returns
                 ormUnused);           //unused

  IOTABreakpointNotifier = interface(IOTANotifier)
    ['{34B2E2D5-E36F-11D1-AB0E-00C04FB16FB3}']
    /// <summary>
    /// Called when IDE attempts to edit this breakpoint. Return False to allow
    /// the default edit dialogs to function. AllowKeyChanges is True if all
    /// Breakpoint parameters are allowed to be changed, False if only certain
    /// items should be allowed to change. For example; when the user selects
    /// &quot;Breakpoint properties...&quot; from the right-click menu in the editor, the
    /// filename and line number fields are read-only.  AllowKeyChanges will be
    /// False in this case. 
    /// </summary>
    function Edit(AllowKeyChanges: Boolean): Boolean;
    /// <summary>
    /// Called when this breakpoint is triggered. Return trStop to stop,
    /// trContinue to continue or trDefault to do the default processing. 
    /// </summary>
    function Trigger: TOTATriggerResult;
    /// <summary>
    /// Called when the breakpoint is verified 
    /// </summary>
    procedure Verified(Enabled, Valid: Boolean);
  end;

  IOTABreakpoint40 = interface(IUnknown)
    ['{34B2E2D4-E36F-11D1-AB0E-00C04FB16FB3}']
    /// <summary>
    /// Add a callback notifier.  Returns the index of this notifier in the
    /// breakpoint's list of notifiers.  Retain this value to be used when
    /// calling RemoveNotifier 
    /// </summary>
    function AddNotifier(const Notifier: IOTABreakpointNotifier): Integer;
    /// <summary>
    /// Call this to destroy the object.  This is deprecated.  Use
    /// IOTADebuggerServices.RemoveBreakpoint to remove a breakpoint. 
    /// </summary>
    procedure Destruct; deprecated 'Use IOTADebuggerServices.RemoveBreakpoint';
    /// <summary>
    /// Processes default Trigger actions. Returns True to indicate stop.
    /// This should only be called within the IOTABreakpointNotifier.Trigger
    /// callback. 
    /// </summary>
    function DefaultTrigger: Boolean;
    /// <summary>
    /// Decrement the CurPassCount if &gt; 0.  Return True if it goes to 0 or is 0 
    /// </summary>
    function DecPassCount: Boolean;
    /// <summary>
    /// Invokes the normal edit processing.  Calling Edit on Address breakpoints
    /// with an AllowKeyChanges parameter of True can cause the Breakpoint object
    /// to be deleted and recreated.  To properly handle this, you should install
    /// a breakpoint notifier and listen for the Deleted notification 
    /// </summary>
    procedure Edit(AllowKeyChanges: Boolean);
    /// <summary>
    /// Evaluates the expression associated with this breakpoint 
    /// </summary>
    function EvaluateExpression: Boolean;
    /// <summary>
    /// Returns the Enabled status of this BP. 
    /// </summary>
    function GetEnabled: Boolean;
    /// <summary>
    /// Retrieves the Expression associated 
    /// </summary>
    function GetExpression: string;
    /// <summary>
    /// Return the Source file name in-which this Breakpoint is set 
    /// </summary>
    function GetFileName: string;
    /// <summary>
    /// Return the line number on which this breakpoint is set 
    /// </summary>
    function GetLineNumber: Integer;
    /// <summary>
    /// Retrieves the current Pass Count if PassCount is set 
    /// </summary>
    function GetCurPassCount: Integer;
    /// <summary>
    /// Retrieves the associated Pass count 
    /// </summary>
    function GetPassCount: Integer;
    /// <summary>
    /// Removes the index'th notifier from the breakpoint's list 
    /// </summary>
    procedure RemoveNotifier(Index: Integer);
    /// <summary>
    /// Resets the CurPassCount back to PassCount 
    /// </summary>
    procedure ResetPassCount;
    /// <summary>
    /// Sets the filename 
    /// </summary>
    procedure SetFileName(const Value: string);
    /// <summary>
    /// Sets the Line Number 
    /// </summary>
    procedure SetLineNumber(Value: Integer);
    /// <summary>
    /// Sets the Enabled status of this breakpoint 
    /// </summary>
    procedure SetEnabled(Value: Boolean);
    /// <summary>
    /// Sets the Expression associated with this breakpoint 
    /// </summary>
    procedure SetExpression(const Value: string);
    /// <summary>
    /// Sets the Pass count associated with this breakpoint. Calling this will
    /// clear the CurPassCount. 
    /// </summary>
    procedure SetPassCount(Value: Integer);
    /// <summary>
    /// Returns whether this Breakpoint is valid in the currently selected
    /// process 
    /// </summary>
    function ValidInCurrentProcess: Boolean;
    /// <summary>
    /// Returns whether this breakpoint is valid in the given process 
    /// </summary>
    function ValidInProcess(const Process: IOTAProcess): Boolean;

    property CurPassCount: Integer read GetCurPassCount;
    property Enabled: Boolean read GetEnabled write SetEnabled;
    property Expression: string read GetExpression write SetExpression;
    property FileName: string read GetFileName write SetFileName;
    property LineNumber: Integer read GetLineNumber write SetLineNumber;
    property PassCount: Integer read GetPassCount write SetPassCount;
  end;

  IOTABreakpoint50 = interface(IOTABreakpoint40)
    ['{569EFCFB-C69B-11D2-AC67-00C04FB173DC}']
    /// <summary>
    /// Retrieves the Group Name 
    /// </summary>
    function GetGroupName: string;
    /// <summary>
    /// Retrieves the Actions 
    /// </summary>
    function GetDoBreak: Boolean;
    /// <summary>
    /// Retrieves the Message to Log 
    /// </summary>
    function GetLogMessage: string;
    /// <summary>
    /// Retrieves the Expression to Evaluate 
    /// </summary>
    function GetEvalExpression: string;
    /// <summary>
    /// Retrieves the LogResult flag 
    /// </summary>
    function GetLogResult: Boolean;
    /// <summary>
    /// Retrieves the Group to Enable 
    /// </summary>
    function GetEnableGroup: string;
    /// <summary>
    /// Retrieves the Group to Disable 
    /// </summary>
    function GetDisableGroup: string;
    /// <summary>
    /// Sets the Group Name 
    /// </summary>
    procedure SetGroupName(const Value: string);
    /// <summary>
    /// Sets the Actions 
    /// </summary>
    procedure SetDoBreak(const Value: Boolean);
    /// <summary>
    /// Sets the Message to Log 
    /// </summary>
    procedure SetLogMessage(const Value: string);
    /// <summary>
    /// Sets the Expression to Evaluate 
    /// </summary>
    procedure SetEvalExpression(const Value: string);
    /// <summary>
    /// Sets the LogResult flag 
    /// </summary>
    procedure SetLogResult(const Value: Boolean);
    /// <summary>
    /// Sets the Group to Enable 
    /// </summary>
    procedure SetEnableGroup(const Value: string);
    /// <summary>
    /// Sets the Group to Disable 
    /// </summary>
    procedure SetDisableGroup(const Value: string);
    property GroupName: string read GetGroupName write SetGroupName;
    property DoBreak: Boolean read GetDoBreak write SetDoBreak;
    property LogMessage: string read GetLogMessage write SetLogMessage;
    property EvalExpression: string read GetEvalExpression write SetEvalExpression;
    property LogResult: Boolean read GetLogResult write SetLogResult;
    property EnableGroup: string read GetEnableGroup write SetEnableGroup;
    property DisableGroup: string read GetDisableGroup write SetDisableGroup;
  end;

  IOTABreakpoint80 = interface(IOTABreakpoint50)
    ['{446F637B-3EBD-4E33-B011-714CE9647BB9}']
    /// <summary>
    /// Retrieves the &quot;Handle Subsequent Exceptions&quot; flag 
    /// </summary>
    function GetDoHandleExceptions: Boolean;
    /// <summary>
    /// Retrieves the &quot;Ignore Subsequent Exceptions&quot; flag 
    /// </summary>
    function GetDoIgnoreExceptions: Boolean;
    /// <summary>
    /// Sets the &quot;Handle Subsequent Exceptions&quot; flag 
    /// </summary>
    procedure SetDoHandleExceptions(const Value: Boolean);
    /// <summary>
    /// Sets the &quot;Ignore Subsequent Exceptions&quot; flag 
    /// </summary>
    procedure SetDoIgnoreExceptions(const Value: Boolean);
    property DoHandleExceptions: Boolean read GetDoHandleExceptions write SetDoHandleExceptions;
    property DoIgnoreExceptions: Boolean read GetDoIgnoreExceptions write SetDoIgnoreExceptions;
  end;

  IOTABreakpoint120 = interface(IOTABreakpoint80)
    ['{614D8D87-F3E2-46B7-8033-4E8B37E697BB}']
    /// <summary>
    /// Retrieves the number of Stack Frames to Log 
    /// </summary>
    function GetStackFramesToLog: Integer;
    /// <summary>
    /// Sets the number of Stack Frames to Log
    /// </summary>
    procedure SetStackFramesToLog(const Value: Integer);
    property StackFramesToLog: Integer read GetStackFramesToLog write SetStackFramesToLog;
  end;

  IOTABreakpoint = interface(IOTABreakpoint120)
    ['{8950E1C9-C32F-4132-87DD-62786A3F9904}']
    /// <summary>
    /// Retrieves the thread on which this breakpoint should trigger.  It will be
    /// a string representing either the OS Thread ID or the Thread Name 
    /// </summary>
    function GetThreadCondition: string;
    /// <summary>
    /// Sets the thread on which this breakpoint should trigger 
    /// </summary>
    procedure SetThreadCondition(const Value: string);
    property ThreadCondition: string read GetThreadCondition write SetThreadCondition;
  end;

  IOTASourceBreakpoint = interface(IOTABreakpoint)
    ['{09063877-E43A-11D1-AB0F-00C04FB16FB3}']
  end;

  IOTAAddressBreakpoint = interface(IOTABreakpoint)
    ['{09063878-E43A-11D1-AB0F-00C04FB16FB3}']
    /// <summary>
    /// Returns the start address of this breakpoint in the current process,
    /// 0 if not valid in the current process 
    /// </summary>
    function Address: TOTAAddress;
    /// <summary>
    /// Returns the start address of this breakpoint in the given process,
    /// 0 if not valid in the given process 
    /// </summary>
    function AddressInProcess(const Process: IOTAProcess): TOTAAddress;
    /// <summary>
    /// Returns the Access type Write or Execute 
    /// </summary>
    function GetAccessType: TOTAAccessType;
    /// <summary>
    /// Returns the Data Expression if this is a DW Breakpoint, empty string if
    /// not 
    /// </summary>
    function GetDataExpr: string;
    /// <summary>
    /// Returns the Size of the line if this address breakpoint was mapped to
    /// a source line 
    /// </summary>
    function GetLineSize: Integer;
    /// <summary>
    /// Returns the Offset in the line if this address breakpoint was mapped to
    /// a source line 
    /// </summary>
    function GetLineOffset: Integer;
    /// <summary>
    /// Returns the Process Module this BP will stop on the entry of if a Module
    /// LoadBP.  If this is a Data Watch BP, this is the Exe module name that
    /// this breakpoint is valid for. 
    /// </summary>
    function GetModuleName: string;

    property AccessType: TOTAAccessType read GetAccessType;
    property DataExpr: string read GetDataExpr;
    property ModuleName: string read GetModuleName;
    property LineSize: Integer read GetLineSize;
    property LineOffset: Integer read GetLineOffset;
  end;

  TOTANotifyReason = (nrOther, nrRunning, nrStopped, nrException, nrFault);

  IOTAThreadNotifier = interface(IOTANotifier)
    ['{34B2E2D7-E36F-11D1-AB0E-00C04FB16FB3}']
    /// <summary>
    /// This is called when the process state changes for this thread 
    /// </summary>
    procedure ThreadNotify(Reason: TOTANotifyReason);
    /// <summary>
    /// This is called when an evaluate that returned erDeferred completes.
    /// ReturnCode &lt;&gt; 0 if error 
    /// </summary>
    procedure EvaluateComplete(const ExprStr, ResultStr: string; CanModify: Boolean;
      ResultAddress, ResultSize: LongWord; ReturnCode: Integer);
    /// <summary>
    /// This is called when a modify that returned erDeferred completes.
    /// ReturnCode &lt;&gt; 0 if error 
    /// </summary>
    procedure ModifyComplete(const ExprStr, ResultStr: string; ReturnCode: Integer);
  end;

  IOTAThreadNotifier160 = interface(IOTAThreadNotifier)
    ['{46F94C52-E225-4054-A5F0-F5E67E29B2C2}']
    /// <summary>
    /// This is called when an evaluate that returned erDeferred completes.
    /// ReturnCode &lt;&gt; 0 if error 
    /// </summary>
    procedure EvaluateComplete(const ExprStr, ResultStr: string; CanModify: Boolean;
      ResultAddress: TOTAAddress; ResultSize: LongWord; ReturnCode: Integer); overload;
  end;

  /// <summary>
  /// erOK       - indicates evaluate operation was successful
  /// erError    - indicates evaluate operation was unsuccessful
  /// erDeferred - indicates evaluate operation is deferred
  /// erBusy     - indicates evaluate operation was not attempted due to the
  ///              evaluator already processing another evaluate operation 
  /// </summary>
  TOTAEvaluateResult = (erOK, erError, erDeferred, erBusy);

  TOTAThreadState = (tsStopped, tsRunnable, tsBlocked, tsNone, tsOther);

  IOTAThread50 = interface(IUnknown)
    ['{34B2E2D3-E36F-11D1-AB0E-00C04FB16FB3}']
    /// <summary>
    /// Add an IOTAThreadNotifier 
    /// </summary>
    function AddNotifier(const Notifier: IOTAThreadNotifier): Integer;
    /// <summary>
    /// Evaluate the given expression.
    /// CanModify -        will be set to true if the expression can be modified.
    /// AllowSideEffects - indicates whether the evaluator is allowed to perform
    ///                    any function calls in the running process in order to
    ///                    complete the evaluation. This includes property access
    ///                    methods.
    /// FormatSpecifiers - String indicating format overrides. See IDE help for
    ///                    definition
    /// ResultAddr       - Will be set if the expression evaluates to an address
    ///                    within the process
    /// ResultSize       - Size of the expression. (ie. SizeOf(&lt;sometype&gt;))
    /// 
    /// Function result will be erDeferred if the evaluator had to make a
    /// function call in the running process in order to finish the evaluation.
    /// The results are undefined in this case.  See the EvaluateComplete method
    /// on the IOTAThreadNotifier.  If the result is erError, the ResultStr may
    /// contain an error message. 
    /// </summary>
    function Evaluate(const ExprStr: string; ResultStr: PChar; ResultStrSize: LongWord;
      out CanModify: Boolean; AllowSideEffects: Boolean; FormatSpecifiers: PAnsiChar;
      out ResultAddr: LongWord; out ResultSize, ResultVal: LongWord): TOTAEvaluateResult;
    /// <summary>
    /// Modify the last evaluated expression.
    /// ResultStr and ResultVal will be set the to the evaluated ValueStr values.
    /// Like Evaluate, the result could be erDeferred. See the ModifyComplete
    /// method on the IOTAThreadNotifier.  If the result is erError then ResultStr
    /// may contain an error message. 
    /// </summary>
    function Modify(const ValueStr: string; ResultStr: PChar; ResultSize: LongWord;
      out ResultVal: Integer): TOTAEvaluateResult;
    /// <summary>
    /// Return the number of Items on the call stack 
    /// </summary>
    function GetCallCount: Integer;
    /// <summary>
    /// Return the evaluator generated string for the given stack index.  GetCallCount
    /// must be called before GetCallHeader. CallHeaders are one-based (not zero-based)
    /// so the first item in the list is at index 1 
    /// </summary>
    function GetCallHeader(Index: Integer): string;
    /// <summary>
    /// Return the source file name and line number of the given stack index.  If the
    /// frame at the given index does not correspond to a source location, FileName will
    /// be an empty string and LineNum will be zero 
    /// </summary>
    procedure GetCallPos(Index: Integer; out FileName: string; out LineNum: Integer);
    /// <summary>
    /// If the process is stopped, return which file the process is stopped on in
    /// this thread.  The return string will be blank if no debug info is found at
    /// this location 
    /// </summary>
    function GetCurrentFile: string;
    /// <summary>
    /// If the process is stopped, return the line number in the above file at
    /// which this process is stopped 
    /// </summary>
    function GetCurrentLine: LongWord;
{$IFDEF MSWINDOWS}
    /// <summary>
    /// Return the Current Thread context 
    /// </summary>
    function GetContext: TContext; deprecated;
{$ENDIF}
    /// <summary>
    /// Return the OS Thread Handle 
    /// </summary>
    function GetHandle: THandle;
    /// <summary>
    /// Return the OS Thread ID 
    /// </summary>
    function GetOSThreadID: LongWord;
    /// <summary>
    /// Return the current thread State 
    /// </summary>
    function GetState: TOTAThreadState;
    /// <summary>
    /// Remove the Index'd notifier 
    /// </summary>
    procedure RemoveNotifier(Index: Integer);

    property CallCount: Integer read GetCallCount;
    property CallHeaders[Index: Integer]: string read GetCallHeader;
    property CurrentFile: string read GetCurrentFile;
    property CurrentLine: LongWord read GetCurrentLine;
{$IFDEF MSWINDOWS}
    property Context: TContext read GetContext;
{$ENDIF}
    property Handle: THandle read GetHandle;
    property State: TOTAThreadState read GetState;
  end;

  IOTAThread60 = interface(IOTAThread50)
    ['{2646D502-95F8-4E6F-A1EC-976E9663C9B6}']
    /// <summary>
    /// Return the current Thread Context 
    /// </summary>
    function GetOTAThreadContext: TOTAThreadContext; deprecated;
    property OTAThreadContext: TOTAThreadContext read GetOTAThreadContext;
  end;

  IOTAThread70 = interface(IOTAThread60)
    ['{24064FD3-5D3C-D611-88BC-00C04FA06AFC}']
    /// <summary>
    /// Gets the current state of the XMM (SSE) registers.  Returns
    /// True if the registers are valid.  Returns False if the
    /// registers are invalid. 
    /// </summary>
    function GetOTAXMMRegisters(var OTAXMMRegs: TOTAXMMRegs): Boolean;
    /// <summary>
    /// Sets the XMM (SSE) registers to new values. 
    /// </summary>
    procedure SetOTAXMMRegisters(NewOTAXMMRegs: TOTAXMMRegs);
  end;

  TOTACallStackState = (csAccessible, csInaccessible, csWait);

  TOTAEvalSideEffects = (eseNone, eseAll, esePropertiesOnly);

  IOTAThread90 = interface(IOTAThread70)
    ['{175F985B-4F54-41B2-A0A1-54F3B66ECD07}']
    /// <summary>
    /// Tells the thread that you are about to access the call stack.
    /// Returns the current state of the call stack for this thread. Check the state
    /// before using the GetCallCount, GetCallHeader, or GetCallPos methods.
    /// csAccessible -- stack can be queried
    /// csInaccessible -- stack can not be queried
    /// csWait -- stack is temporarily unavailable -- try again after letting the
    ///           message loop spin for a bit (i.e post yourself a message to try again) 
    /// </summary>
    function StartCallStackAccess: TOTACallStackState;
    /// <summary>
    /// Tells the thread that you are done accessing the call stack 
    /// </summary>
    procedure EndCallStackAccess;

    /// <summary>
    /// Evaluate the given expression.
    /// This overloaded version adds a FileName and LineNumber parameter which tells
    /// the evaluator to uses that source location as the scope in which to evaluate
    /// the expression 
    /// </summary>
    function Evaluate(const ExprStr: string; ResultStr: PChar; ResultStrSize: LongWord;
      out CanModify: Boolean; SideEffects: TOTAEvalSideEffects; FormatSpecifiers: PAnsiChar;
      out ResultAddr: LongWord; out ResultSize, ResultVal: LongWord;
      FileName: string; LineNumber: Integer): TOTAEvaluateResult; overload;
    /// <summary>
    /// Gets the string displayed in the &quot;Thread Id&quot; column of the thread view
    /// for this thread.  If an empty string is returned, the value returned by
    /// GetOSThreadID will be displayed 
    /// </summary>
    function GetDisplayString: string;
    /// <summary>
    /// Gets the string to be displayed in the &quot;Location&quot; column of the thread
    /// view for this thread. This string is only used if CurrentFile is an
    /// empty string 
    /// </summary>
    function GetLocationString: string;
    /// <summary>
    /// Gets the process which owns this thread 
    /// </summary>
    function GetOwningProcess: IOTAProcess;
    /// <summary>
    /// Gets the string to be displayed in the &quot;State&quot; column of the thread view
    /// for this thread.  This string is only used if GetState returns tsOther 
    /// </summary>
    function GetStateString: string;
    /// <summary>
    /// Gets the string to be displayed in the &quot;Status&quot; column of the thread view
    /// for this thread. 
    /// </summary>
    function GetStatusString: string;

    property DisplayString: string read GetDisplayString;
    property Location: string read GetLocationString;
    property OSThreadID: LongWord read GetOSThreadID;
    property OwningProcess: IOTAProcess read GetOwningProcess;
    property StateString: string read GetStateString;
    property Status: string read GetStatusString;
  end;

  IOTAThread110 = interface(IOTAThread90)
    ['{3A96CD8F-A5CD-4AFE-8A73-DAE1265095D9}']
    /// <summary>
    /// Return the evaluator generated string for the given stack index.  GetCallCount
    /// must be called before GetSimpleCallHeader. CallHeaders are one-based (not zero-based)
    /// so the first item in the list is at index 1.
    /// This differs from GetCallHeader in that it returns stack frame names that
    /// are not fully qualified (method names only, no namespace, class, etc. names 
    /// </summary>
    function GetSimpleCallHeader(Index: Integer): string;

    property SimpleCallHeaders[Index: Integer]: string read GetSimpleCallHeader;
  end;

  TThreadWaitChainInfo = record
    CycleDetected: Boolean;
    IsBlocked: Boolean;
    BlockedString: string;
  end;

  IOTAThread120 = interface(IOTAThread110)
    ['{DF4C57A6-8674-4D7E-B75E-6704BB5F1A54}']
    /// <summary>
    /// Retrieves info regarding the thread's wait chain.  Wait chains are only
    /// available on Vista (or later).  The return value indicates whether a wait
    /// chain is available for this thread. 
    /// </summary>
    function WaitChainInfo(var ThreadWaitChainInfo: TThreadWaitChainInfo): Boolean;
  end;

  IOTAThread140 = interface(IOTAThread120)
    ['{BC146984-1E20-4695-879A-25E6A82F52F7}']
    /// <summary>
    /// Indicates if this thread supports being frozen 
    /// </summary>
    function GetCanFreeze: Boolean;
    /// <summary>
    /// Indicates if this thread is currently frozen 
    /// </summary>
    function GetFrozen: Boolean;
    /// <summary>
    /// Freezes the thread 
    /// </summary>
    procedure Freeze;
    /// <summary>
    /// Thaws the thread 
    /// </summary>
    procedure Thaw;
    /// <summary>
    /// Asks the thread's evaluator if a given type is a descendant of another
    /// type. Returns True if ChildType is a descendant of ParentType.  Returns
    /// False otherwise 
    /// </summary>
    function IsDescendantOf(const ChildType, ParentType: string): Boolean;
    /// <summary>
    /// Returns the name of the Thread, if the thread is named for debugging.
    /// Returns an empty string. if the thread is not named. 
    /// </summary>
    function GetThreadName: string;
    /// <summary>
    /// Sets the name of the thread for debugging 
    /// </summary>
    procedure SetThreadName(const Name: string);

    property CanFreeze: Boolean read GetCanFreeze;
    property Frozen: Boolean read GetFrozen;
    property ThreadName: string read GetThreadName write SetThreadName;
  end;

  IOTAThread150 = interface(IOTAThread140)
    ['{7030D03B-EB04-47EC-9E3B-6DB50D3B8968}']
    /// <summary>
    /// Sets the Thread Context to new values 
    /// </summary>
    procedure SetOTAThreadContext(const Value: TOTAThreadContext);  deprecated;
    property OTAThreadContext: TOTAThreadContext read GetOTAThreadContext write SetOTAThreadContext;
  end;

  IOTAThread = interface(IOTAThread150)
    ['{2CBF37C1-8845-4C06-8658-79E11F6D76EA}']
    /// <summary>
    /// Evaluate the given expression.
    /// This overloaded version updates ResultAddr type from LongWord to TOTAAddress to support
    /// 64-bit debugging 
    /// </summary>
    function Evaluate(const ExprStr: string; ResultStr: PChar; ResultStrSize: LongWord;
      out CanModify: Boolean; AllowSideEffects: Boolean; FormatSpecifiers: PAnsiChar;
      out ResultAddr: TOTAAddress; out ResultSize, ResultVal: LongWord): TOTAEvaluateResult; overload;
    /// <summary>
    /// Evaluate the given expression.
    /// This overloaded version updates ResultAddr type from LongWord to TOTAAddress to support
    /// 64-bit debugging 
    /// </summary>
    function Evaluate(const ExprStr: string; ResultStr: PChar; ResultStrSize: LongWord;
      out CanModify: Boolean; SideEffects: TOTAEvalSideEffects; FormatSpecifiers: PAnsiChar;
      out ResultAddr: TOTAAddress; out ResultSize, ResultVal: LongWord;
      FileName: string; LineNumber: Integer): TOTAEvaluateResult; overload;
    /// <summary>
    /// Return the current Thread Context 
    /// </summary>
    function GetOTAThreadContextEx: TOTAThreadContextEx;
    /// <summary>
    /// Sets the Thread Context to new values 
    /// </summary>
    procedure SetOTAThreadContextEx(const Value: TOTAThreadContextEx);

    property OTAThreadContextEx: TOTAThreadContextEx read GetOTAThreadContextEx write SetOTAThreadContextEx;
  end;

  INTAThread = interface
    ['{381708B8-A0FA-44DC-B173-3328AEFA0432}']
    /// <summary>
    /// This tells the thread to show a non-source location. FrameNumber is one-
    /// based (top frame is one).  If FrameNumber is 0 or 1, the top frame is used
    /// Otherwise, the thread should show the location of the frame indicated.  Use
    /// GetCallCount to get the number of available frames for a thread. The
    /// BehindWindow, if not nil, should stay on top after the location is shown 
    /// </summary>
    procedure ShowNonSourceLocation(FrameNumber: Integer; BehindWindow: TCustomForm);
  end;

  IOTAProcessModNotifier = interface(IOTANotifier)
    ['{0906387A-E43A-11D1-AB0F-00C04FB16FB3}']
    /// <summary>
    /// Modified is called as evaluator symbols for this module are loaded 
    /// </summary>
  end;

  IOTAProcessModule80 = interface(IUnknown)
    ['{09063879-E43A-11D1-AB0F-00C04FB16FB3}']
    /// <summary>
    /// Adds an IOTAProcessModNotifier 
    /// </summary>
    function AddNotifier(const Notifier: IOTAProcessModNotifier): Integer;
    /// <summary>
    /// Returns the number of Compilation Units that comprise this Process Module 
    /// </summary>
    function GetCompUnitCount: Integer;
    /// <summary>
    /// Returns the index'd Compilation Unit Name 
    /// </summary>
    function GetCompUnit(Index: Integer): string;
    /// <summary>
    /// Returns the number of files used to create the index'd compilation unit 
    /// </summary>
    function GetCompUnitFileCount(Index: Integer): Integer;
    /// <summary>
    /// Returns the index'd filename of the index'd compilation unit 
    /// </summary>
    function GetCompUnitFileName(CompIndex, FileIndex: Integer): string;
    /// <summary>
    /// Returns the address of the first code instruction for this module 
    /// </summary>
    function GetEntryPoint: TOTAAddress;
    /// <summary>
    /// Returns the Base Load address of the module 
    /// </summary>
    function GetBaseAddress: TOTAAddress;
    /// <summary>
    /// Returns the number of associated source files in this process module 
    /// </summary>
    function GetFileCount: Integer;
    /// <summary>
    /// Return the index'd file 
    /// </summary>
    function GetFileName(Index: Integer): string;
    /// <summary>
    /// Returns the number of entry points (procedure/functions/exports) in this
    /// Process Module 
    /// </summary>
    function GetModuleEntryPointCount: Integer;
    /// <summary>
    /// Returns the index'd module entry point name 
    /// </summary>
    function GetModuleEntryPoint(Index: Integer): string;
    /// <summary>
    /// Returns the index'd module entry point address 
    /// </summary>
    function GetModuleEntryPointAddress(Index: Integer): TOTAAddress;
    /// <summary>
    /// FileName of the Exe/Dll/Bpl, etc.. 
    /// </summary>
    function GetModuleFileName: string;
    /// <summary>
    /// ModuleName of the Exe/Dll/Bpl, etc 
    /// </summary>
    function GetModuleName: string;
    /// <summary>
    /// Removes the index'd IOTAProcessModNotifier 
    /// </summary>
    procedure RemoveNotifier(Index: Integer);

    property CompUnitCount: Integer read GetCompUnitCount;
    property CompUnit[Index: Integer]: string read GetCompUnit;
    property CompUnitFileCount[Index: Integer]: Integer read GetCompUnitFileCount;
    property CompUnitFileName[CompIndex, FileIndex: Integer]: string read GetCompUnitFileName;
    property FileCount: Integer read GetFileCount;
    property FileNames[Index: Integer]: string read GetFileName;
    property ModuleEntryPointCount: Integer read GetModuleEntryPointCount;
    property ModuleEntryPoint[Index: Integer]: string read GetModuleEntryPoint;
    property ModuleEntryPointAddress[Index: Integer]: TOTAAddress read GetModuleEntryPointAddress;
  end;

  TOTAEntryPointSortType = (epsByName, epsByAddress);
  TOTAEntryPointSortDirection = (epsAscending, epsDescending);

  IOTAProcessModule90 = interface(IOTAProcessModule80)
    ['{9B4A6BC8-CC15-42A9-A41D-816A72CA0AF1}']
    /// <summary>
    /// Indicates whether or not this ProcessModule's symbol table can be reloaded 
    /// </summary>
    function CanReloadSymbolTable: Boolean;
    /// <summary>
    /// Ask the ProcessModule to reload its symbol table 
    /// </summary>
    procedure ReloadSymbolTable(const NewPath: string);
    /// <summary>
    /// Gets the fully qualified file name associated with the file index.  This will
    /// search along the search path and prompt the user for the location if it can't
    /// be found 
    /// </summary>
    function SearchFileNameFromIndex(Index: Integer): string;
    /// <summary>
    /// Ask the ProcessModule to sort its entry points.  HowToSort indicates which part of the
    /// entry point to sort on.  epsByName indicates that the the entry points should be sorted
    /// alphabetically by entry point name.  epsByAddress indicates that the entry points should
    /// be sorted numerically by entry point address. Direction indicates whether the sort should
    /// be done in ascending (epsAscending) or descending (epsDescending) order 
    /// </summary>
    procedure SortEntryPoints(HowToSort: TOTAEntryPointSortType; Direction: TOTAEntryPointSortDirection);
    /// <summary>
    /// Tells the process module to navigate to a particular entry point 
    /// </summary>
    procedure ShowEntryPoint(Index: Integer);
  end;

  IOTAProcessModule110 = interface(IOTAProcessModule90)
    ['{EA1D9277-C318-4E5C-8BDC-03529E81DF8E}']
    /// <summary>
    /// Indicates whether or not this module has debug symbol information available 
    /// </summary>
    function GetHasSymbols: Boolean;
    /// <summary>
    /// Returns the fully qualified name of the symbol table file used for this module 
    /// </summary>
    function GetSymbolFileName: string;

    property HasSymbols: Boolean read GetHasSymbols;
    property SymbolFileName: string read GetSymbolFileName;
  end;

  IOTAProcessModule = interface(IOTAProcessModule110)
    ['{41171E69-E830-40B4-A8C6-1A115307C8A1}']
    /// <summary>
    /// Indicates whether or not this module contains debug information for
    /// the specified source file.  This method can be used as more efficient
    /// alternative to IOTAProcess.GetSourceIsDebuggable, as this method will
    /// only look in a given process module, while IOTAProcess.GetSourceIsDebuggable
    /// will search all process modules in a given process. 
    /// </summary>
    function ContainsSourceFile(const FileName: string): Boolean;
  end;

  IOTAProcessNotifier = interface(IOTANotifier)
    ['{34B2E2D6-E36F-11D1-AB0E-00C04FB16FB3}']
    /// <summary>
    /// Called when a Thread is created 
    /// </summary>
    procedure ThreadCreated(const Thread: IOTAThread);
    /// <summary>
    /// Called when a Thread is Destroyed 
    /// </summary>
    procedure ThreadDestroyed(const Thread: IOTAThread);
    /// <summary>
    /// Called when a Process module is added 
    /// </summary>
    procedure ProcessModuleCreated(const ProcessModule: IOTAProcessModule);
    /// <summary>
    /// Called when a Process module is deleted 
    /// </summary>
    procedure ProcessModuleDestroyed(const ProcessModule: IOTAProcessModule);
  end;

  IOTAProcessNotifier90 = interface(IOTAProcessNotifier)
    ['{E2725B23-E67C-4CF1-B928-FA0F5B9C2C29}']
    /// <summary>
    /// Called after a process' current thread is changed 
    /// </summary>
    procedure CurrentThreadChanged(const Thread: IOTAThread);
    /// <summary>
    /// Called when a process' thread list changes.  This notification is purposely
    /// vague.  Things like thread creation, thread destruction, thread attribute
    /// changes (for now just thread name) are reported via this notification 
    /// </summary>
    procedure ThreadListChanged(const Process: IOTAProcess);
  end;

  IOTAProcess60 = interface(IUnknown)
    ['{34B2E2D2-E36F-11D1-AB0E-00C04FB16FB3}']
    /// <summary>
    /// Adds an IOTAProcessNotifier 
    /// </summary>
    function AddNotifier(const Notifier: IOTAProcessNotifier): Integer;
    /// <summary>
    /// Return the currently active thread 
    /// </summary>
    function GetCurrentThread: IOTAThread;
    /// <summary>
    /// Return the number of Thread in this process 
    /// </summary>
    function GetThreadCount: Integer;
    /// <summary>
    /// Return the index'd Thread 
    /// </summary>
    function GetThread(Index: Integer): IOTAThread;
    /// <summary>
    /// Get the debugger's internal process ID 
    /// </summary>
    function GetProcessId: LongWord;
    /// <summary>
    /// Stop/Pause the process 
    /// </summary>
    procedure Pause;
    /// <summary>
    /// Read the process memory at the given address 
    /// </summary>
    function ReadProcessMemory(Address: LongWord; Count: Integer; var Buffer): Integer;
    /// <summary>
    /// Removes the index'd IOTAProcessNotifier 
    /// </summary>
    procedure RemoveNotifier(Index: Integer);
    /// <summary>
    /// Run the process with the specified run mode 
    /// </summary>
    procedure Run(RunMode: TOTARunMode);
    /// <summary>
    /// Set a new current thread 
    /// </summary>
    procedure SetCurrentThread(Value: IOTAThread);
    /// <summary>
    /// Reset/Terminate the process 
    /// </summary>
    procedure Terminate;
    /// <summary>
    /// Write to the process memory at the given address 
    /// </summary>
    function WriteProcessMemory(Address: LongWord; Count: Integer; var Buffer): Integer;

    property CurrentThread: IOTAThread read GetCurrentThread write SetCurrentThread;
    property ProcessId: LongWord read GetProcessId;
    property ThreadCount: Integer read GetThreadCount;
    property Threads[Index: Integer]: IOTAThread read GetThread;
  end;

  IOTAProcess70 = interface(IOTAProcess60)
    ['{64FC3321-BEC8-4E88-B17A-3E78EA15F10E}']
    /// <summary>
    /// Get the OS process ID 
    /// </summary>
    function GetOSProcessId: LongWord;

    property OSProcessId: LongWord read GetOSProcessId;
  end;

  TOTAProcessState = (psNothing, psRunning, psStopping, psStopped,
    psFault, psResFault, psTerminated, psException, psNoProcess);

  TGetSrcLinesFunc = function (LineNum: Integer; ClientArg: Pointer): Integer {$IFDEF LINUX} cdecl; {$ENDIF} {$IFDEF MSWINDOWS} pascal; {$ENDIF}

  IOTAProcess90 = interface(IOTAProcess70)
    ['{BEBD67CA-F6FC-44A7-ACBF-E314DB085827}']
    /// <summary>
    /// Indicates if process properties can be set on this process (via the thread view) 
    /// </summary>
    function CanSetProperties: Boolean;
    /// <summary>
    /// Called when the user asks to set properties for this process (via the thread view) 
    /// </summary>
    procedure SetProperties;
    /// <summary>
    /// Get the string displayed in the &quot;Thread Id&quot; column of the thread view for
    /// this process.  If an empty string is returned, the thread view will display the
    /// ExeName and the OSProcessId. 
    /// </summary>
    function GetDisplayString: string;
    /// <summary>
    /// Get the name of the executable being debugged 
    /// </summary>
    function GetExeName: string;
    /// <summary>
    /// Get the string displayed in the &quot;Location&quot; column of the thread view for
    /// this process.
    /// </summary>
    function GetLocationString: string;
    /// <summary>
    /// Get the string displayed in the &quot;State&quot; column in the thread view for
    /// this process 
    /// </summary>
    function GetStateString: string;
    /// <summary>
    /// Get the string displayed in the &quot;Status&quot; column in the thread view for
    /// this process 
    /// </summary>
    function GetStatusString: string;
    /// <summary>
    /// Get the current process state 
    /// </summary>
    function GetProcessState: TOTAProcessState;
    /// <summary>
    /// Set the current process state 
    /// </summary>
    procedure SetProcessState(const NewState: TOTAProcessState);
    /// <summary>
    /// Indicates whether this process has debug info for the specified source file.
    /// GetSourceLines should only be called on a file if SourceIsDebuggable returns True.
    /// See also IOTAProcessModule.ContainsSourceFile, which can be a more efficient
    /// alternative to this method. 
    /// </summary>
    function GetSourceIsDebuggable(const FileName: string): Boolean;
    /// <summary>
    /// Iterates through the breakpointable source lines in the specified file,
    /// starting at the specified line.  The PostFunc is called for each line
    /// on which a breakpoint can be set.  ClientArg will be passed as a parameter
    /// to the PostFunc 
    /// </summary>
    procedure GetSourceLines(const FileName: string; StartLine: Integer; PostFunc: TGetSrcLinesFunc; ClientArg: Pointer);

    /// <summary>
    /// Indicates whether the specified breakpoint is valid in this process 
    /// </summary>
    function BreakpointIsValid(const Breakpoint: IOTASourceBreakpoint): Boolean;

    /// <summary>
    /// Returns the number of IOTAProcessModules loaded by this process 
    /// </summary>
    function GetProcessModuleCount: Integer;
    /// <summary>
    /// Returns the index'd ProcessModule loaded by this process 
    /// </summary>
    function GetProcessModule(ModuleIndex: Integer): IOTAProcessModule;

    property DisplayString: string read GetDisplayString;
    property ExeName: string read GetExeName;
    property Location: string read GetLocationString;
    property ProcessModuleCount: Integer read GetProcessModuleCount;
    property ProcessModules[ModuleIndex: Integer]: IOTAProcessModule read GetProcessModule;
    property ProcessState: TOTAProcessState read GetProcessState write SetProcessState;
    property SourceIsDebuggable[const FileName: string]: Boolean read GetSourceIsDebuggable;
    property State: string read GetStateString;
    property Status: string read GetStatusString;
  end;

  IOTAProcess150 = interface(IOTAProcess90)
    ['{1C540740-E350-4DD1-B026-C233D1C380D4}']
    /// <summary>
    /// Detaches the debugger from the process 
    /// </summary>
    procedure Detach;
    /// <summary>
    /// Returns the index of the specified ProcessModule (in the &quot;ProcessModules&quot; property) 
    /// </summary>
    function IndexOfProcessModule(const ProcessModule: IOTAProcessModule): Integer;
    /// <summary>
    /// Returns the source file name and line number associated with the given address. If
    /// a source location can not be found, FileName will come back as an empty string 
    /// </summary>
    procedure SourceLocationFromAddress(const Address: LongWord;
      out FileName: string; out LineNum: Integer);
  end;

  TOTAProcessType = (optWin32, optOSX32, optWin64, optiOS32, optAndroid, optiOS64, optLinux64, optOSX64, optAndroid64, optOSXArm64);

  IOTAProcess = interface(IOTAProcess150)
    ['{FBECB2A2-80BF-400D-B4A6-0BCEABC2FF7D}']
    /// <summary>
    /// Read the process memory at the given address 
    /// </summary>
    function ReadProcessMemory(Address: TOTAAddress; Count: Integer; var Buffer): Integer; overload;
    /// <summary>
    /// Write to the process memory at the given address 
    /// </summary>
    function WriteProcessMemory(Address: TOTAAddress; Count: Integer; var Buffer): Integer; overload;
    /// <summary>
    /// Returns the source file name and line number associated with the given address. If
    /// a source location can not be found, FileName will come back as an empty string 
    /// </summary>
    procedure SourceLocationFromAddress(const Address: TOTAAddress;
      out FileName: string; out LineNum: Integer); overload;
    /// <summary>
    /// Get the process type 
    /// </summary>
    function GetProcessType: TOTAProcessType;
  end;

  INTAProcess150 = interface
    ['{D65533D2-52B1-460F-ABF1-48CA415524F5}']
    /// <summary>
    /// Asks the debugger to show the code location that corresponds to the specified address
    /// within this process.  The BehindWindow, if not nil, should stay on top after the
    /// location is shown. 
    /// </summary>
    procedure ShowNonSourceLocation(const Address: LongWord; BehindWindow: TCustomForm);
    /// <summary>
    /// Asks the debugger to show the memory location that corresponds to the specified
    /// address within this process.  The BehindWindow, if not nil, should stay on top after the
    /// location is shown 
    /// </summary>
    procedure ShowMemoryLocation(const Address: LongWord; BehindWindow: TCustomForm);
  end;

  INTAProcess = interface(INTAProcess150)
    ['{089CAD6D-F1C4-4D33-A388-A0F99043F4DE}']
    /// <summary>
    /// Asks the debugger to show the code location that corresponds to the specified address
    /// within this process.  The BehindWindow, if not nil, should stay on top after the
    /// location is shown. 
    /// </summary>
    procedure ShowNonSourceLocation(const Address: TOTAAddress; BehindWindow: TCustomForm); overload;
    /// <summary>
    /// Asks the debugger to show the memory location that corresponds to the specified
    /// address within this process.  The BehindWindow, if not nil, should stay on top after the
    /// location is shown 
    /// </summary>
    procedure ShowMemoryLocation(const Address: TOTAAddress; BehindWindow: TCustomForm); overload;
  end;

  IOTADebuggerNotifier = interface(IOTANotifier)
    ['{34B2E2D8-E36F-11D1-AB0E-00C04FB16FB3}']
    /// <summary>
    /// Called when a process is created 
    /// </summary>
    procedure ProcessCreated(const Process: IOTAProcess);
    /// <summary>
    /// Called when a process is Destroyed 
    /// </summary>
    procedure ProcessDestroyed(const Process: IOTAProcess);
    /// <summary>
    /// Called when a Breakpoint is Added 
    /// </summary>
    procedure BreakpointAdded(const Breakpoint: IOTABreakpoint);
    /// <summary>
    /// Called when a breakpoint is Deleted 
    /// </summary>
    procedure BreakpointDeleted(const Breakpoint: IOTABreakpoint);
  end;

  IOTADebuggerNotifier90 = interface(IOTADebuggerNotifier)
    ['{68558E84-A7EC-499F-AD08-CB00876AC5BE}']
    /// <summary>
    /// Called after an existing breakpoint is changed 
    /// </summary>
    procedure BreakpointChanged(const Breakpoint: IOTABreakpoint);
    /// <summary>
    /// Called after the current process is changed 
    /// </summary>
    procedure CurrentProcessChanged(const Process: IOTAProcess);
    /// <summary>
    /// Called after a process' state is changed 
    /// </summary>
    procedure ProcessStateChanged(const Process: IOTAProcess);
    /// <summary>
    /// Called before a debugger launches a project's process.  This gets called
    /// whether or not IntegratedDebugging is enabled.  Result is whether the
    /// program should actually be launched.  In all normal circumstances, you
    /// should return True from here 
    /// </summary>
    function BeforeProgramLaunch(const Project: IOTAProject): Boolean;
    /// <summary>
    /// Called when memory within a process has changed in response to a user
    /// action. Events that trigger this notifier include:
    ///   1. the user changing a variable value in the evaluator/inspector/etc.
    ///   2. the user changes raw data in the CPU view's dump pane, register pane
    ///      or flags pane 
    /// </summary>
    procedure ProcessMemoryChanged;
  end;

  IOTADebuggerNotifier100 = interface(IOTADebuggerNotifier90)
    ['{FE684C77-220C-4999-ACFA-C4C0C7FB6A42}']
    /// <summary>
    /// called when the global (global in the sense that they are not process-specific) 
    /// debugger-specific options have been changed 
    /// </summary>
    procedure DebuggerOptionsChanged;
  end;

  IOTADebuggerNotifier110 = interface(IOTADebuggerNotifier100)
    ['{20E36B81-E987-4947-AAFA-AC0E2F0E72EF}']
    procedure ProcessMemoryChanged(EIPChanged: Boolean);
  end;

  TEnumerateProcessesCallback = procedure (Pid: LongWord; const ProcessName: string; Param: Pointer);

  IOTADebuggerServices60 = interface(IUnknown)
    ['{0E3B9D7A-E119-11D1-AB0C-00C04FB16FB3}']
    /// <summary>
    /// Adds an IOTADebuggerNotifier 
    /// </summary>
    function AddNotifier(const Notifier: IOTADebuggerNotifier): Integer;
    /// <summary>
    /// Attaches to an existing process 
    /// </summary>
    procedure AttachProcess(Pid: Integer; const RemoteHost: string = '');
    /// <summary>
    /// Creates a new process 
    /// </summary>
    procedure CreateProcess(const ExeName, Args: string; const RemoteHost: string = '');
    /// <summary>
    /// Enumerates all the current running processes on the local machine or remote
    /// machine 
    /// </summary>
    procedure EnumerateRunningProcesses(Callback: TEnumerateProcessesCallback;
      Param: Pointer; const HostName: string = '');
    /// <summary>
    /// Returns the count of address breakpoints 
    /// </summary>
    function GetAddressBkptCount: Integer;
    /// <summary>
    /// Returns the index'd Address Breakpoint 
    /// </summary>
    function GetAddressBkpt(Index: Integer): IOTAAddressBreakpoint;
    /// <summary>
    /// Returns the currently active process. This is set whenever a debug
    /// event occurs 
    /// </summary>
    function GetCurrentProcess: IOTAProcess;
    /// <summary>
    /// Returns the number of active processes 
    /// </summary>
    function GetProcessCount: Integer;
    /// <summary>
    /// Returns the Index'd process 
    /// </summary>
    function GetProcess(Index: Integer): IOTAProcess;
    /// <summary>
    /// Returns the count of source breakpoints 
    /// </summary>
    function GetSourceBkptCount: Integer;
    /// <summary>
    /// Returns the index'd source Breakpoint 
    /// </summary>
    function GetSourceBkpt(Index: Integer): IOTASourceBreakpoint;
    /// <summary>
    /// Log event string to Event log window if present. 
    /// </summary>
    procedure LogString(const LogStr: string);
    /// <summary>
    /// Creates a new Address breakpoint, will create a source BP if the
    /// address given is on a line boundary 
    /// </summary>
    function NewAddressBreakpoint(Address, Length: LongWord; AccessType: TOTAAccessType;
      const AProcess: IOTAProcess = nil): IOTABreakpoint;
    /// <summary>
    /// Creates a new Module load Breakpoint. This is deprecated.  Use new overloaded
    /// version that takes only a ModuleName 
    /// </summary>
    function NewModuleBreakpoint(const ModuleName: string;
      const AProcess: IOTAProcess): IOTABreakpoint; deprecated 'Use overloaded NewModuleBreakpoint(const ModuleName: string)';
    /// <summary>
    /// Creates a new Source Breakpoint 
    /// </summary>
    function NewSourceBreakpoint(const FileName: string; LineNumber: Integer;
      const AProcess: IOTAProcess): IOTABreakpoint;
    /// <summary>
    /// Removes the index'd IOTADebuggerNotifier 
    /// </summary>
    procedure RemoveNotifier(Index: Integer);
    /// <summary>
    /// Sets the current process 
    /// </summary>
    procedure SetCurrentProcess(const Process: IOTAProcess);

    property AddressBkptCount: Integer read GetAddressBkptCount;
    property AddressBkpts[Index: Integer]: IOTAAddressBreakpoint read GetAddressBkpt;
    property CurrentProcess: IOTAProcess read GetCurrentProcess write SetCurrentProcess;
    property ProcessCount: Integer read GetProcessCount;
    property Processes[Index: Integer]: IOTAProcess read GetProcess;
    property SourceBkptCount: Integer read GetSourceBkptCount;
    property SourceBkpts[Index: Integer]: IOTASourceBreakpoint read GetSourceBkpt;
  end;

  /// <summary>
  /// TLogItemType is used for drawing event log messages in different colors.
  /// litSourceBreakpoint should be used for any breakpoint type
  /// </summary>
  TLogItemType = (litDefault,
    {$IFDEF MSWINDOWS}
    litODS, litWMSent, litWMPosted, litOleClientStart, litOleServerStart,
    litOleClientEnd, 
    {$ENDIF}
    litSourceBreakpoint, litLogBreakEval, litBreakpointMessage, litProcStart,
    litProcExit, litThreadStart, litThreadExit, litModLoad, litModUnload,
    litExceptFirstTry);

  IOTADebuggerServices90 = interface(IOTADebuggerServices60)
    ['{A797823A-6BD7-41A4-B36B-3A831A737B2D}']
    /// <summary>
    /// Log event string to Event log window associated with the TLogItemType.
    /// TLogItemType's are colored differently in the event log. 
    /// </summary>
    procedure LogString(const LogStr: string; LogItemType: TLogItemType);
  end;

  IOTADebuggerServices120 = interface(IOTADebuggerServices90)
    ['{29AE42CE-006A-4A96-A0BB-0D63D9E83A5C}']
    /// <summary>
    /// Attaches to an existing process.  Same as IOTADebuggerServices60 version,
    /// adding two parameters. PauseAfterAttach indicates if the process should
    /// be paused after it is attached to.  DetachOnReset indicates if the
    /// debugger should detach from the process rather than terminate it when
    /// the user performs a Program Reset 
    /// </summary>
    procedure AttachProcess(Pid: Integer; PauseAfterAttach: Boolean;
      DetachOnReset: Boolean; const RemoteHost: string = '');
  end;

  /// <summary>
  /// This is the base for debugger visualizers.  This interface allows you to
  /// specify a name, a unique identifier, and a description for your visualizer.
  /// It also allows you to specify which types the visualizer will handle 
  /// </summary>
  IOTADebuggerVisualizer = interface
    ['{744B7632-9F86-49B6-AED5-7A48DA25E376}']
    /// <summary>
    /// Return the number of types supported by this visualizer 
    /// </summary>
    function GetSupportedTypeCount: Integer;
    /// <summary>
    /// Return the Index'd Type.  TypeName is the type.  AllDescendants indicates
    /// whether or not types descending from this type should use this visualizer
    /// as well. 
    /// </summary>
    procedure GetSupportedType(Index: Integer; var TypeName: string;
      var AllDescendants: Boolean); overload;
    /// <summary>
    /// Return a unique identifier for this visualizer.  This identifier is used
    /// as the keyname when storing data for this visualizer in the registry.  It
    /// should not be translated 
    /// </summary>
    function GetVisualizerIdentifier: string;
    /// <summary>
    /// Return the name of the visualizer to be shown in the Tools | Options dialog 
    /// </summary>
    function GetVisualizerName: string;
    /// <summary>
    /// Return a description of the visualizer to be shown in the Tools | Options dialog 
    /// </summary>
    function GetVisualizerDescription: string;

    property VisualizerIdentifier: string read GetVisualizerIdentifier;
    property VisualizerName: string read GetVisualizerName;
    property VisualizerDescription: string read GetVisualizerDescription;
  end;

  IOTADebuggerVisualizer250 = interface(IOTADebuggerVisualizer)
    ['{DC0C8D82-B783-4205-B3F4-D325BA8B3EEB}']
    /// <summary>
    /// Return the Index'd Type.  TypeName is the type.  AllDescendants indicates
    /// whether or not types descending from this type should use this visualizer
    /// as well. IsGeneric indicates whether this type is a generic type. 
    /// </summary>
    procedure GetSupportedType(Index: Integer; var TypeName: string;
      var AllDescendants: Boolean; var IsGeneric: Boolean); overload;
  end;

  /// <summary>
  /// This is the simplest form of a debug visualizer.  With it, you can replace
  /// the value returned by the evaluator with a more meaningful value.  The
  /// replacement value will appear in the normal debugger UI (i.e. Evaluator
  /// Tooltips, Watch View, Locals View, Evaluate/Modify dialog,
  /// Debug Inspector View).
  /// There can be only one active IOTADebuggerVisualizerValueReplacer per type 
  /// </summary>
  IOTADebuggerVisualizerValueReplacer = interface(IOTADebuggerVisualizer)
    ['{6BBFB765-E76F-449D-B059-A794FA06F917}']
    function GetReplacementValue(const Expression, TypeName, EvalResult: string): string;
  end;

  TOTAVisualizerClosedProcedure = procedure of object;

  TOTAVisualizerUnavailableReason = (ovurProcessRunning, ovurOutOfScope);

  /// <summary>
  /// This interface provides communication between the debugger and an
  /// external debugger visualizer 
  /// </summary>
  IOTADebuggerVisualizerExternalViewerUpdater = interface
    ['{4FA77EAB-4BA4-4203-B451-3B3C5B428D39}']
    /// <summary>
    /// Called when the visualizer should be closed (because the thread that
    /// created it has gone away) 
    /// </summary>
    procedure CloseVisualizer;
    /// <summary>
    /// Called when the process is running or otherwise in a state where it is
    /// unable to show data.  The recommended action is to show &quot;Process not
    /// accessible&quot;, &quot;Out of scope&quot;, or something similar (like is shown in the
    /// Watch window) 
    /// </summary>
    procedure MarkUnavailable(Reason: TOTAVisualizerUnavailableReason);
    /// <summary>
    /// Called when the data for the visualizer needs to be refreshed 
    /// </summary>
    procedure RefreshVisualizer(const Expression, TypeName, EvalResult: string);
    /// <summary>
    /// Called to set a callback that should be called to let the debugger know
    /// that the external viewer has been closed.  The CloseProc is a debugger-
    /// provided procedure that the visualizer UI should call when the user closes
    /// it.  This tells the debugger (among other things) to stop refreshing this
    /// visualizer 
    /// </summary>
    procedure SetClosedCallback(ClosedProc: TOTAVisualizerClosedProcedure);
  end;

  /// <summary>
  /// This visualizer type allows you to create/show separate UI for the specified
  /// data types.
  /// There can be many active IOTADebuggerVisualizerExternalViewers per type 
  /// </summary>
  IOTADebuggerVisualizerExternalViewer = interface(IOTADebuggerVisualizer)
    ['{A0D5CAF5-83A3-446E-B040-B3E40A926A72}']
    /// <summary>
    /// Returns the text to be used in the menu caption for this visualizer 
    /// </summary>
    function GetMenuText: string;
    /// <summary>
    /// Show is called when the user selects this visualizer type from the list
    /// of the installed visualizers for a given type.  You should create and
    /// show the UI of your visualizer and return an interface that is used
    /// by the debugger to communicate with the visualizer. &quot;SuggestedLeft&quot; and
    /// &quot;SuggestedTop&quot; are the suggested screen coordinates for the visualizer 
    /// </summary>
    function Show(const Expression, TypeName, EvalResult: string;
      SuggestedLeft, SuggestedTop: Integer): IOTADebuggerVisualizerExternalViewerUpdater;
  end;

  IOTADebuggerServices150 = interface(IOTADebuggerServices120)
    ['{DC682429-BB92-4AF7-9E62-26557D68DE75}']
    /// <summary>
    /// Returns the number of Module Load breakpoints currently set 
    /// </summary>
    function GetModuleBkptCount: Integer;
    /// <summary>
    /// Returns the module name for the index'th Module Load breakpoint 
    /// </summary>
    function GetModuleBkpt(Index: Integer): string;
    /// <summary>
    /// Creates a new Module load breakpoint 
    /// </summary>
    procedure NewModuleBreakpoint(const ModuleName: string); overload;
    /// <summary>
    /// Removes a Module Load breakpoint 
    /// </summary>
    procedure RemoveModuleBreakpoint(const ModuleName: string);
    /// <summary>
    /// Removes a breakpoint 
    /// </summary>
    procedure RemoveBreakpoint(const Breakpoint: IOTABreakpoint);

    /// <summary>
    /// Registers a debug visualizer 
    /// </summary>
    procedure RegisterDebugVisualizer(const Visualizer: IOTADebuggerVisualizer);
    /// <summary>
    /// Unregisters a previously registered debug visualizer 
    /// </summary>
    procedure UnregisterDebugVisualizer(const Visualizer: IOTADebuggerVisualizer);

    /// <summary>
    /// Tells the debugger to process debug events.  This can be used form within
    /// a loop when waiting for a deferred evaluation to complete 
    /// </summary>
    procedure ProcessDebugEvents;

    property ModuleBkptCount: Integer read GetModuleBkptCount;
    property ModuleBkpts[Index: Integer]: string read GetModuleBkpt;
  end;

  IOTADebuggerServices = interface(IOTADebuggerServices150)
    ['{587EAFAE-B8B2-4007-A233-BE09052BB67A}']
    /// <summary>
    /// Creates a new Address breakpoint, will create a source BP if the
    /// address given is on a line boundary 
    /// </summary>
    function NewAddressBreakpoint(Address: TOTAAddress; Length: LongWord; AccessType: TOTAAccessType;
      const AProcess: IOTAProcess = nil): IOTABreakpoint; overload;
  end;

  TOTAFileNotification = (ofnFileOpening, ofnFileOpened, ofnFileClosing,
    ofnDefaultDesktopLoad, ofnDefaultDesktopSave, ofnProjectDesktopLoad,
    ofnProjectDesktopSave, ofnPackageInstalled, ofnPackageUninstalled,
    ofnActiveProjectChanged, ofnProjectOpenedFromTemplate,
    ofnBeginProjectGroupOpen, ofnEndProjectGroupOpen, ofnBeginProjectGroupClose,
    ofnEndProjectGroupClose);

  IOTAIDENotifier = interface(IOTANotifier)
    ['{E052204F-ECE9-11D1-AB19-00C04FB16FB3}']
    /// <summary>
    /// This procedure is called for many various file operations within the
    /// IDE 
    /// </summary>
    procedure FileNotification(NotifyCode: TOTAFileNotification;
      const FileName: string; var Cancel: Boolean);
    /// <summary>
    /// This function is called immediately before the compiler is invoked.
    /// Set Cancel to True to cancel the compile 
    /// </summary>
    procedure BeforeCompile(const Project: IOTAProject; var Cancel: Boolean); overload;
    /// <summary>
    /// This procedure is called immediately following a compile.  Succeeded
    /// will be true if the compile was successful 
    /// </summary>
    procedure AfterCompile(Succeeded: Boolean); overload;
  end;

  IOTAIDENotifier50 = interface(IOTAIDENotifier)
    ['{AC7D29F1-D9A9-11D2-A8C1-00C04FA32F53}']
    /// <summary>
    /// Same as BeforeCompile on IOTAIDENotifier except indicates if the compiler
    /// was invoked due to a CodeInsight compile 
    /// </summary>
    procedure BeforeCompile(const Project: IOTAProject; IsCodeInsight: Boolean;
      var Cancel: Boolean); overload;
    /// <summary>
    /// Same as AfterCompile on IOTAIDENotifier except indicates if the compiler
    /// was invoked due to a CodeInsight compile 
    /// </summary>
    procedure AfterCompile(Succeeded: Boolean; IsCodeInsight: Boolean); overload;
  end;

  IOTAIDENotifier80 = interface(IOTAIDENotifier50)
    ['{41679BBC-660E-4948-AD80-63C679CB973C}']
    /// <summary>
    /// Same as AfterCompile on IOTAIDENotifier except adds a project, like it
    /// should have done all along. 
    /// </summary>
    procedure AfterCompile(const Project: IOTAProject; Succeeded:
      Boolean; IsCodeInsight: Boolean); overload;
  end;

  IOTAGalleryCategory = interface
    ['{CCEA8A72-46BA-4CCF-863C-9718CC06DABF}']
    function GetDisplayName: string;
    function GetIDString: string;
    function GetParent: IOTAGalleryCategory;

    property DisplayName: string read GetDisplayName;
    property IDString: string read GetIDString;
    property Parent: IOTAGalleryCategory read GetParent;
  end;

  /// <summary>
  /// Query BorlandIDEServices for IOTAGalleryCategoryManager 
  /// </summary>
  IOTAGalleryCategoryManager = interface
    ['{5FAFFE12-E1A4-4286-94F9-A025B3C0BF41}']
    function FindCategory(const IDString: string): IOTAGalleryCategory;
    function AddCategory(const IDString, DisplayName: string;
      IconHandle: Integer = 0): IOTAGalleryCategory; overload;
    function AddCategory(const ParentCategory: IOTAGalleryCategory;
      const IDString, DisplayName: string;
      IconHandle: Integer = 0): IOTAGalleryCategory; overload;
    procedure DeleteCategory(const Category: IOTAGalleryCategory);
  end;

  TWizardState = set of (wsEnabled, wsChecked);

  IOTAWizard = interface(IOTANotifier)
    ['{B75C0CE0-EEA6-11D1-9504-00608CCBF153}']
    /// <summary>
    /// Expert UI strings 
    /// </summary>
    function GetIDString: string;
    function GetName: string;
    function GetState: TWizardState;

    /// <summary>
    /// Launch the AddIn 
    /// </summary>
    procedure Execute;
  end;

  /// <summary>
  /// Repository Wizards are the items in the File | New | Other dialog.
  /// They are used to create new projects, units/forms, etc.
  /// In order to work properly in the current IDE, each IOTARepositoryWizard
  /// should also implement IOTARepositoryWizard80 and IOTARepositoryWizard160 
  /// </summary>

  IOTARepositoryWizard = interface(IOTAWizard)
    ['{B75C0CE1-EEA6-11D1-9504-00608CCBF153}']
    function GetAuthor: string;
    function GetComment: string;
    function GetPage: string;
    /// <summary>
    /// Handle to an Icon 
    /// </summary>
    function GetGlyph: Cardinal;
  end;

  IOTARepositoryWizard60 = interface(IOTARepositoryWizard)
    ['{08FCCD88-3A21-4281-ADC9-62FC034CDD12}']
    /// <summary>
    /// This function should return the appropriate designer affinity for which
    /// this wizard is applicable.  This will help the File|New|Other... dialog
    /// filter the appropriate items based on the current project either CLX or
    /// VCL.  See the dVCL, dCLX, and dAny constants. 
    /// </summary>
    function GetDesigner: string;

    property Designer: string read GetDesigner;
  end;

  IOTARepositoryWizard80 = interface(IOTARepositoryWizard60)
    ['{D7714D41-BC4A-445E-B695-25A65C2F561E}']
    function GetGalleryCategory: IOTAGalleryCategory;
    function GetPersonality: string;

    /// <summary>
    /// GalleryCategory takes precedence over the result from GetPage.
    /// If a wizard doesn't implement IOTARepositoryWizard80, it is
    /// put under the Delphi personality's default section, and creates a
    /// sub area named by the result of &quot;GetPage&quot;. 
    /// </summary>
    property GalleryCategory: IOTAGalleryCategory read GetGalleryCategory;
    property Personality: string read GetPersonality;
  end;

  IOTARepositoryWizard160 = interface(IOTARepositoryWizard80)
    ['{034C3976-A0CB-4376-A296-F3C286891573}']
    /// <summary>
    /// Return the framework type strings for the frameworks this wizard selects 
    /// </summary>
    function GetFrameworkTypes: TArray<string>;
    /// <summary>
    /// Return the platform keys for the platforms this wizard supports 
    /// </summary>
    function GetPlatforms: TArray<string>;

    property FrameworkTypes: TArray<string> read GetFrameworkTypes;
    property Platforms: TArray<string> read GetPlatforms;
  end;

  IOTARepositoryWizard190 = interface(IOTARepositoryWizard160)
    ['{66141605-AA2A-4F82-84DE-DB825D52647C}']
    /// <summary>
    /// Return the platform keys for the platforms this wizard supports 
    /// </summary>
    function GetSupportedPlatforms: TArray<string>;
  end;
  
  IOTARepositoryWizard260 = interface(IOTARepositoryWizard190)
    ['{7063BAEB-7C97-4B22-9D8F-B3D5A09F2545}']
    function GetGalleryCategories: TArray<IOTAGalleryCategory>;

    /// <summary>
    /// GalleryCategories allow register a wizard under several caregories 
    /// </summary>
    property GalleryCategories: TArray<IOTAGalleryCategory> read GetGalleryCategories;
  end;

  IOTAFormWizard = interface(IOTARepositoryWizard)
    ['{36C8BF35-EFFE-11D1-AB1D-00C04FB16FB3}']
  end;

  IOTAFormWizard100 = interface(IOTAFormWizard)
    ['{56D61347-C74D-4BF7-89A9-F422F31CF259}']
    /// <summary>
    /// IsVisible allows the wizard to determine if it should show up in the
    /// gallery for a given project (if there is no project,
    /// nil is passed). The wizard must already be the same
    /// personality as the project.
    /// The only reason to add this interface is if you may want to return
    /// false. 
    /// </summary>
    function IsVisible(Project: IOTAProject): Boolean;
  end;

  IOTAProjectWizard = interface(IOTARepositoryWizard)
    ['{36C8BF36-EFFE-11D1-AB1D-00C04FB16FB3}']
  end;

  IOTAProjectWizard100 = interface(IOTAProjectWizard)
    ['{809D578B-AE79-4CC2-A6ED-D7A8CD24C74D}']
    /// <summary>
    /// IsVisible allows the wizard to determine if it should show up in the
    /// gallery for a given active project project. The only reason to add this
    /// interface is if you may want to return false. 
    /// </summary>
    function IsVisible(Project: IOTAProject): Boolean;
  end;

  IOTAMenuWizard = interface(IOTAWizard)
    ['{B75C0CE2-EEA6-11D1-9504-00608CCBF153}']
    function GetMenuText: string;
  end;

  TWizardRegisterProc = function(const Wizard: IOTAWizard): Boolean;
  TWizardTerminateProc = procedure;
  TWizardInitProc = function(const BorlandIDEServices: IBorlandIDEServices;
    RegisterProc: TWizardRegisterProc;
    var Terminate: TWizardTerminateProc): Boolean stdcall;

  IOTAWizardServices = interface(IUnknown)
    ['{B75C0CE3-EEA6-11D1-9504-00608CCBF153}']
    /// <summary>
    /// Call this to register an IOTAWizard interface 
    /// </summary>
    function AddWizard(const AWizard: IOTAWizard): Integer;
    /// <summary>
    /// Remove the index'd Wizard 
    /// </summary>
    procedure RemoveWizard(Index: Integer);
  end;

  IOTAPackageServices140 = interface(IUnknown)
    ['{26EB0E4D-F97B-11D1-AB27-00C04FB16FB3}']
    /// <summary>
    /// Returns the number of loaded packages 
    /// </summary>
    function GetPackageCount: Integer;
    /// <summary>
    /// Returns the name of the loaded package 
    /// </summary>
    function GetPackageName(Index: Integer): string;
    /// <summary>
    /// Returns the number of components registered by this package index 
    /// </summary>
    function GetComponentCount(PkgIndex: Integer): Integer;
    /// <summary>
    /// Returns the component name of the package index 
    /// </summary>
    function GetComponentName(PkgIndex, CompIndex: Integer): string;

    property PackageCount: Integer read GetPackageCount;
    property PackageNames[Index: Integer]: string read GetPackageName;
    property ComponentCount[PkgIndex: Integer]: Integer read GetComponentCount;
    property ComponentNames[PkgIndex, CompIndex: Integer]: string read GetComponentName;
  end;

  TOTAPackageProducer = (ppOTAUnknown, ppOTADelphi, ppOTABCB);
  TOTAPackageConsumer = (pcOTAUnknown, pcOTADelphi, pcOTABCB, pcOTABoth);

  IOTAPackageInfo = interface(IUnknown)
    ['{F41DB233-500B-4B0D-93A0-9072E10EE069}']
    /// <summary>
    /// Returns the package description 
    /// </summary>
    function GetDescription: string;
    /// <summary>
    /// Returns the fully qualified filename of the package 
    /// </summary>
    function GetFileName: string;
    /// <summary>
    /// Returns the filename of the package 
    /// </summary>
    function GetName: string;
    /// <summary>
    /// Returns the base name of the symbol file associated with the package.  For
    /// Delphi-built packages this is typically the .dcp file name. For C++-built
    /// packages, this is typically the .bpi file name.  This may differ from the
    /// package name if the package has a LIBPREFIX, LIBSUFFIX or LIBVERSION defined.
    /// </summary>
    function GetSymbolFileName: string;

    /// <summary>
    /// Fills &quot;List&quot; with the list of units contained by this package.  This list
    /// is only available if &quot;Loaded&quot; is true 
    /// </summary>
    procedure GetContainsList(List: TStrings);
    /// <summary>
    /// Fills &quot;List&quot; with the list of packages required by this package 
    /// </summary>
    procedure GetRequiresList(List: TStrings);
    /// <summary>
    /// Fills &quot;List&quot; with the list of units implicitly linked into this package.
    /// This list is only available if &quot;Loaded&quot; is true 
    /// </summary>
    procedure GetImplicitList(List: TStrings);
    /// <summary>
    /// Fills &quot;List&quot; with the list of loaded packages which require this package 
    /// </summary>
    procedure GetRequiredByList(List: TStrings);

    /// <summary>
    /// Indicates if this package is a runtime-only package 
    /// </summary>
    function GetRuntimeOnly: Boolean;
    /// <summary>
    /// Indicates if this package is a designtime-only package 
    /// </summary>
    function GetDesigntimeOnly: Boolean;
    /// <summary>
    /// Indicates if this package is an IDE package.  IDE packages are design-time
    /// packages that are loaded by the IDE and can not be unloaded by the user 
    /// </summary>
    function GetIDEPackage: Boolean;
    /// <summary>
    /// Indicates which compiler/linker produced this package (Delphi vs. C++) 
    /// </summary>
    function GetProducer: TOTAPackageProducer;
    /// <summary>
    /// Indicates which personality can use the components contained in this
    /// package.  C++-built packages can only be consumed by C++ projects.
    /// Delphi-built packages can always be consumed by Delphi.  They can also
    /// be consumed by C++ if they are built with C++ support (compiler switch -JL) 
    /// </summary>
    function GetConsumer: TOTAPackageConsumer;

    /// <summary>
    /// Indicates whether the package module is currently loaded in the IDE's
    /// address space.  Returns False for cached packages that have not been
    /// loaded yet. 
    /// </summary>
    function GetLoaded: Boolean;
    /// <summary>
    /// Sets the loaded state of a package.  Note, setting the loaded state to
    /// True only has an effect for a package that has been cached or one that has
    /// been previously unloaded via a call to SetLoaded(False).  Setting the
    /// loaded state to False will cause the package to be unloaded from memory
    /// but will not remove it from the package list (it will be loaded the next
    /// time the IDE loads).  To unload a package and remove it from the list, use
    /// IOTAPackageServices.UninstallPackage 
    /// </summary>
    procedure SetLoaded(Value: Boolean);

    property FileName: string read GetFileName;
    property Name: string read GetName;
    property RuntimeOnly: Boolean read GetRuntimeOnly;
    property DesigntimeOnly: Boolean read GetDesigntimeOnly;
    property IDEPackage: Boolean read GetIDEPackage;
    property Loaded: Boolean read GetLoaded write SetLoaded;
    property Description: string read GetDescription;
    property Producer: TOTAPackageProducer read GetProducer;
    property Consumer: TOTAPackageConsumer read GetConsumer;
    property SymbolFileName: string read GetSymbolFileName;
  end;

  IOTAPackageServices210 = interface(IOTAPackageServices140)
    ['{2C96711A-267A-4024-9C54-B11FCC596A6F}']
    /// <summary>
    /// Installs the specified design-time package into the IDE 
    /// </summary>
    function InstallPackage(const PackageName: string): Boolean;
    /// <summary>
    /// Uninstalls the specified design-time package from the IDE 
    /// </summary>
    function UninstallPackage(const PackageName: string): Boolean;
    /// <summary>
    /// Retrieves the IOTAPackageInfo for the specified package 
    /// </summary>
    function GetPackage(Index: Integer): IOTAPackageInfo;

    property Package[Index: Integer]: IOTAPackageInfo read GetPackage;
  end;

  TPackageOp = (poInstalled, poUninstalling, poUninstalled);
  TPackageNotifier = procedure (const PackageName: string; PackageOp: TPackageOp) of object;

  IOTAPackageServices = interface(IOTAPackageServices210)
    ['{1E8AB2DA-CC56-4FA5-851A-9CDC957D1D65}']
    /// <summary>
    /// Add a callback notifier for package notifications 
    /// </summary>
    procedure RegisterPackageNotifier(Proc: TPackageNotifier);
    /// <summary>
    /// Remove a callback notifier for package notifications 
    /// </summary>
    procedure UnregisterPackageNotifier(Proc: TPackageNotifier);
  end;

  IOTACustomMessage = interface(IUnknown)
    ['{589BBDA1-F995-11D1-AB27-00C04FB16FB3}']
    /// <summary>
    /// Returns the Column number of the file if the file is given 
    /// </summary>
    function GetColumnNumber: Integer;
    /// <summary>
    /// Returns a Fully qualified filename if this message line can navigate to a
    /// file line 
    /// </summary>
    function GetFileName: string;
    /// <summary>
    /// Returns the Line number of the above file if the above file is given 
    /// </summary>
    function GetLineNumber: Integer;
    /// <summary>
    /// Returns the Raw line text 
    /// </summary>
    function GetLineText: string;
    /// <summary>
    /// F1 pressed on this line 
    /// </summary>
    procedure ShowHelp;

    property ColumnNumber: Integer read GetColumnNumber;
    property FileName: string read GetFilename;
    property LineNumber: Integer read GetLineNumber;
    property LineText: string read GetLineText;
  end;

  IOTACustomMessage50 = interface(IOTACustomMessage)
    ['{B7523AB7-EB81-11D2-AC7B-00C04FB173DC}']
    /// <summary>
    /// Returns the number of child messages the current message has 
    /// </summary>
    function GetChildCount: Integer;
    /// <summary>
    /// Returns the child message referred to by the Index parameter 
    /// </summary>
    function GetChild(Index: Integer): IOTACustomMessage50;

    property ChildCount: Integer read GetChildCount;
    property Child[Index: Integer]: IOTACustomMessage50 read GetChild;
  end;

  IOTACustomMessage100 = interface(IOTACustomMessage50)
    ['{824153E3-6336-48BA-805E-1A35E429787E}']
    /// <summary>
    /// Indicates if the line can be navigated to 
    /// </summary>
    function CanGotoSource(var DefaultHandling: Boolean): Boolean;
    /// <summary>
    /// User selected View Source on this line 
    /// </summary>
    procedure TrackSource(var DefaultHandling: Boolean);
    /// <summary>
    /// User selected Edit Source on this line 
    /// </summary>
    procedure GotoSource(var DefaultHandling: Boolean);
  end;

  INTACustomDrawMessage = interface(IOTACustomMessage)
    ['{589BBDA2-F995-11D1-AB27-00C04FB16FB3}']
    procedure Draw(Canvas: TCanvas; const Rect: TRect; Wrap: Boolean);
    function CalcRect(Canvas: TCanvas; MaxWidth: Integer; Wrap: Boolean): TRect;
  end;
  {$IFDEF LINUX}
  {$NODEFINE INTACustomDrawMessage}
  {$ENDIF}

  IOTAMessageServices40 = interface(IUnknown)
    ['{26EB0E4E-F97B-11D1-AB27-00C04FB16FB3}']
    /// <summary>
    /// This method allows the external tool to handle all painting of the
    /// message in a fashion similar to the &quot;Find in files&quot; messages.  If the
    /// INTACustomDrawMessage is implemented then all painting is deferred to that
    /// interface, otherwise the painting is handled internally 
    /// </summary>
    procedure AddCustomMessage(const CustomMsg: IOTACustomMessage);
    /// <summary>
    /// This method adds a simple title message that simply displays in the
    /// message view with no other behavior 
    /// </summary>
    procedure AddTitleMessage(const MessageStr: string);
    /// <summary>
    /// This method adds a line to the message buffer that behaves similar to the
    /// compiler error message lines.  It allows all the painting and other
    /// processing to be handled by the IDE.
    /// PrefixStr is usually a short string that indicates from which tool this
    /// message originates, for ex. 'Grep tool', which would display as
    /// '[Grep tool]' 
    /// </summary>
    procedure AddToolMessage(const FileName, MessageStr, PrefixStr: string;
      LineNumber, ColumnNumber: Integer);
    /// <summary>
    /// Clears all messages from the message buffer 
    /// </summary>
    procedure ClearAllMessages;
    /// <summary>
    /// Clears all &quot;compiler/linker&quot; messages 
    /// </summary>
    procedure ClearCompilerMessages;
    /// <summary>
    /// Clears all &quot;Find in files&quot; messages 
    /// </summary>
    procedure ClearSearchMessages;
    /// <summary>
    /// Clears all the externally defined messages -- from all message groups 
    /// </summary>
    procedure ClearToolMessages;
  end;

  IOTAMessageServices50 = interface(IOTAMessageServices40)
    ['{3263774B-E959-11D2-AC7B-00C04FB173DC}']
    /// <summary>
    /// See IOTAMessageServices40 for base description.  This method adds an out
    /// parameter (LineRef) which returns an opaque pointer to the Line object
    /// created, as well as a Parent.  If Parent is not nil, this method creates a
    /// new message which is a child message to an existing message (referred to
    /// by Parent).  A previously returned LineRef pointer should be passed as the
    /// Parent parameter to create a child message of the Parent. 
    /// </summary>
    procedure AddToolMessage(const FileName, MessageStr, PrefixStr: string;
      LineNumber, ColumnNumber: Integer; Parent: Pointer; out LineRef: Pointer); overload;
  end;

  IOTAMessageGroup80 = interface(IUnknown)
    ['{233F4508-6022-4DDF-B6D3-D2108BAF80DB}']
    /// <summary>
    /// Returns the name for the group 
    /// </summary>
    function GetGroupName: string;
    property Name: string read GetGroupName;
  end;

  IOTAMessageGroup90 = interface(IOTAMessageGroup80)
    ['{CF2B68C9-9ED0-461E-A5F4-DFC3B0268A85}']
    /// <summary>
    /// Indicates whether this message group will automatically scroll to show any new
    /// messages added to it.  Defaults to False 
    /// </summary>
    function GetAutoScroll: Boolean;
    /// <summary>
    /// Set the AutoScroll state of this message group.  Setting it to True will cause
    /// the message view to automatically scroll any newly added message into view 
    /// </summary>
    procedure SetAutoScroll(Value: Boolean);
    property AutoScroll: Boolean read GetAutoScroll write SetAutoScroll;
  end;

  IOTAMessageGroup = interface(IOTAMessageGroup90)
    ['{52A6CDC6-2225-4D3C-AC02-A68C9B19A967}']
    /// <summary>
    /// Indicates whether this message group can be closed by choosing the local menu
    /// item &quot;Close Tab&quot; in the message view.  Defaults to True 
    /// </summary>
    function GetCanClose: Boolean;
    /// <summary>
    /// Set the CanClose flag of this message group.  Setting it to True will cause
    /// the local menu item &quot;Close Tab&quot; to be disabled when it is disaplyed for this
    /// message group 
    /// </summary>
    procedure SetCanClose(Value: Boolean);
    property CanClose: Boolean read GetCanClose write SetCanClose;
  end;

  /// <summary>
  /// Interface implemented by a client to receive notifications
  /// on message groups 
  /// </summary>
  IOTAMessageNotifier = interface(IOTANotifier)
    ['{FDCB2ED4-B89C-4D00-B0DB-19562951CDBB}']
    /// <summary>
    /// BeforeSave, AfterSave, Destroyed, and Modified are
    /// currently not called for this notifier, though they
    /// may be in future releases 
    /// </summary>
    /// <summary>
    /// Called when a new message group is added 
    /// </summary>
    procedure MessageGroupAdded(const Group: IOTAMessageGroup);
    /// <summary>
    /// Called when a message group is deleted 
    /// </summary>
    procedure MessageGroupDeleted(const Group: IOTAMessageGroup);
  end;

  INTAMessageNotifier = interface(IOTAMessageNotifier)
    ['{0AE796BE-B5D7-4830-9159-DEFF82AC076B}']
    /// <summary>
    /// Called when the local menu is brought up on the specified message group.
    /// Menu is the PopupMenu.  You can insert items into this menu.
    /// LineRef is an opaque pointer indicating the focused message
    /// when the menu is brought up.  This can be queried for an IOTACustomMessage
    /// if you have added such a line to the current message group 
    /// </summary>
    procedure MessageViewMenuShown(Menu: TPopupMenu; const MessageGroup: IOTAMessageGroup; LineRef: Pointer);
  end;
  {$IFDEF LINUX}
  {$NODEFINE INTAMessageNotifier}
  {$ENDIF}

  IOTAMessageServices60 = interface(IOTAMessageServices50)
    ['{58A40C76-7EC6-41DA-A2EF-4B3AF31D3977}']
    /// <summary>
    /// Call this to register an IOTAMessageNotifier. The result is the index
    /// to be used when calling RemoveNotifier. If &lt;0 then an error occurred. 
    /// </summary>
    function AddNotifier(const ANotifier: IOTAMessageNotifier): Integer;
    /// <summary>
    /// Call with the index obtained from AddNotifier 
    /// </summary>
    procedure RemoveNotifier(Index: Integer);
    /// <summary>
    /// This method allows you to add a new message group to the message view.
    /// A message group shows up as a distinct tab in the message view in the IDE.
    /// An interface to the newly added group is returned.  Use this interface
    /// when calling other methods in the IOTAMessageServices interface.  If you
    /// hold onto the IOTAMessageGroup reference which is returned, you should
    /// install an IOTAMessageNotifier and listen for the MessageGroupDeleted
    /// notification.  When you receive this notification, you should release your
    /// reference to the indicated IOTAMessageGroup. 
    /// </summary>
    function AddMessageGroup(const GroupName: string): IOTAMessageGroup;
    /// <summary>
    /// See IOTAMessageServices50 for base description of AddCustomMessage,
    /// AddTitleMessage and AddToolMessage.  These methods add one parameter:
    /// MessageGroupIntf indicates which MessageGroup this message belongs to.
    /// If MessageGroupIntf is nil, the message is added to the &quot;Build&quot; tab. 
    /// </summary>
    procedure AddCustomMessage(const CustomMsg: IOTACustomMessage;
      const MessageGroupIntf: IOTAMessageGroup); overload;
    procedure AddTitleMessage(const MessageStr: string; const MessageGroupIntf: IOTAMessageGroup); overload;
    procedure AddToolMessage(const FileName, MessageStr, PrefixStr: string;
      LineNumber, ColumnNumber: Integer; Parent: Pointer; out LineRef: Pointer;
      const MessageGroupIntf: IOTAMessageGroup); overload;
    /// <summary>
    /// Clears all messages in the specified group. If MessageGroupIntf is nil,
    /// all groups are cleared 
    /// </summary>
    procedure ClearMessageGroup(const MessageGroupIntf: IOTAMessageGroup);
    /// <summary>
    /// Clears all the externally defined messages from the specified group.
    /// If MessageGroupIntf is nil, all externally defined messages in all
    /// groups are cleared 
    /// </summary>
    procedure ClearToolMessages(const MessageGroupIntf: IOTAMessageGroup); overload;
    /// <summary>
    /// Returns the number of message groups currently defined 
    /// </summary>
    function GetMessageGroupCount: Integer;
    /// <summary>
    /// Returns an interface to the group specified by the index 
    /// </summary>
    function GetMessageGroup(Index: Integer): IOTAMessageGroup;
    /// <summary>
    /// Returns the specified group 
    /// </summary>
    function GetGroup(const GroupName: string): IOTAMessageGroup;
    /// <summary>
    /// Tells the IDE to open the message view. If MessageGroupIntf is nil the
    /// &quot;current&quot; tab is focused. 
    /// </summary>
    procedure ShowMessageView(const MessageGroupIntf: IOTAMessageGroup);
    /// <summary>
    /// Removes the specified message group.  If MessageGroupIntf is nil then
    /// this does nothing. 
    /// </summary>
    procedure RemoveMessageGroup(const MessageGroupIntf: IOTAMessageGroup);
    property MessageGroupCount: Integer read GetMessageGroupCount;
    property MessageGroup[Index: Integer]: IOTAMessageGroup read GetMessageGroup;
  end;

  TOTAMessageKind = (otamkHint, otamkWarn, otamkError, otamkFatal, otamkInfo);

  IOTAMessageServices70 = interface(IOTAMessageServices60)
    ['{B3F7D3A6-D1F7-48A0-8BB0-F49CF60FB815}']
    /// <summary>
    /// This method adds a message to the message window that comes from a
    /// compiler or other translator. This method allows the build filter to
    /// indicate to the IDE what kind of message this is, error, warning, etc. 
    /// </summary>
    procedure AddCompilerMessage(const FileName, MessageStr, ToolName: string;
      Kind: TOTAMessageKind; LineNumber, ColumnNumber: Integer;
      Parent: Pointer; out LineRef: Pointer); overload;
  end;

  IOTAMessageServices80 = interface(IOTAMessageServices70)
    ['{02DD618A-30A0-4DCE-9D04-6B736646FFCB}']
    /// <summary>
    /// This method tells the message window (current tab) to navigate to the next
    /// or previous message (depending on the GoForward parameter) 
    /// </summary>
    procedure NextMessage(GoForward: Boolean);
    /// <summary>
    /// This method tells the message window's Build tab to navigate to the next
    /// or previous message (depending on the GoForward parameter) .  If ErrorsOnly
    /// is True non-error messages are skipped 
    /// </summary>
    procedure NextErrorMessage(GoForward: Boolean; ErrorsOnly: Boolean);
    /// <summary>
    /// This message is the same as the method in IOTAMessageServices70.  It
    /// adds a HelpKeyword parameter.  If the user presses F1 on the message
    /// added, help will be shown for the specified keyword 
    /// </summary>
    procedure AddCompilerMessage(const FileName, MessageStr, ToolName: string;
      Kind: TOTAMessageKind; LineNumber, ColumnNumber: Integer; Parent: Pointer;
      out LineRef: Pointer; HelpKeyword: string); overload;
    /// <summary>
    /// This message is the same as the method in IOTAMessageServices70.  It
    /// adds a HelpContext parameter.  If the user presses F1 on the message
    /// added, help will be shown for the specified context 
    /// </summary>
    procedure AddCompilerMessage(const FileName, MessageStr, ToolName: string;
      Kind: TOTAMessageKind; LineNumber, ColumnNumber: Integer; Parent: Pointer;
      out LineRef: Pointer; HelpContext: Integer); overload;
  end;

  IOTAMessageServices = interface(IOTAMessageServices80)
    ['{29E893DB-DD9A-4CEA-B2EE-57532E01A9B9}']
    /// <summary>
    /// Allows a custom message to be added with a parent. Returns: a pointer
    /// to the current message that can then be used as a parent. 
    /// </summary>
    function AddCustomMessage(const CustomMsg: IOTACustomMessage;
      Parent: Pointer): Pointer; overload;
    /// <summary>
    /// Same as AddCustomMessage but returns a pointer that allows it to be
    /// used as a parent of another AddCustomMessage call 
    /// </summary>
    function AddCustomMessagePtr(const CustomMsg: IOTACustomMessage;
      const MessageGroupIntf: IOTAMessageGroup): Pointer; overload;
    /// <summary>
    /// WideString version AddCompilerMessage 
    /// </summary>
    procedure AddWideCompilerMessage(const FileName, MessageStr, ToolName: WideString;
      Kind: TOTAMessageKind; LineNumber, ColumnNumber: Integer;
      Parent: Pointer; out LineRef: Pointer); overload;
    procedure AddWideCompilerMessage(const FileName, MessageStr, ToolName: WideString;
      Kind: TOTAMessageKind; LineNumber, ColumnNumber: Integer; Parent: Pointer;
      out LineRef: Pointer; HelpKeyword: WideString); overload;
    procedure AddWideCompilerMessage(const FileName, MessageStr, ToolName: WideString;
      Kind: TOTAMessageKind; LineNumber, ColumnNumber: Integer; Parent: Pointer;
      out LineRef: Pointer; HelpContext: Integer); overload;
    /// <summary>
    /// WideString version AddMessageGroup 
    /// </summary>
    function AddWideMessageGroup(const GroupName: WideString): IOTAMessageGroup;
    /// <summary>
    /// WideString version AddTitleMessage 
    /// </summary>
    procedure AddWideTitleMessage(const MessageStr: WideString); overload;
    procedure AddWideTitleMessage(const MessageStr: WideString; const MessageGroupIntf: IOTAMessageGroup); overload;
    /// <summary>
    /// WideString version AddToolMessage 
    /// </summary>
    procedure AddWideToolMessage(const FileName, MessageStr, PrefixStr: WideString;
      LineNumber, ColumnNumber: Integer); overload;
    procedure AddWideToolMessage(const FileName, MessageStr, PrefixStr: WideString;
      LineNumber, ColumnNumber: Integer; Parent: Pointer; out LineRef: Pointer); overload;
    procedure AddWideToolMessage(const FileName, MessageStr, PrefixStr: WideString;
      LineNumber, ColumnNumber: Integer; Parent: Pointer; out LineRef: Pointer;
     const MessageGroupIntf: IOTAMessageGroup); overload;
    /// <summary>
    /// WideString version GetGroup 
    /// </summary>
    function GetWideGroup(const GroupName: WideString): IOTAMessageGroup;
  end;

  INTAAddInOptions = interface(IUnknown)
    ['{4B348F3E-6D01-4D88-A565-4C8C0EBF4335}']
    /// <summary>
    /// Indicates where this option page should appear in the treeview in the
    /// Tools | Options dialog.  If this function returns an empty string, this
    /// page will appear under the Third Party area.  It is strongly suggested
    /// that you return an empty string from this function. 
    /// </summary>
    function GetArea: string;
    /// <summary>
    /// Indicates the name of the node that should appear in the treeview in the
    /// Tools | Options dialog.  This node will appear under the node specified by
    /// &quot;GetArea&quot;.  To nest multiple levels below the Area, include a dot in the
    /// Caption.  For instance if you return a blank string from GetArea and you
    /// return &quot;MyAddin.MyOptions&quot; from GetCaption, your options page will
    /// appear as follows in the treeview:
    /// Third Party
    /// |--MyAddin
    ///    |--MyOptions
    ///     
    /// </summary>
    function GetCaption: string;
    /// <summary>
    /// Returns the class of the frame that you want embedded in this options page 
    /// </summary>
    function GetFrameClass: TCustomFrameClass;
    /// <summary>
    /// Called when the instance of the specified frame class is created 
    /// </summary>
    procedure FrameCreated(AFrame: TCustomFrame);
    /// <summary>
    /// Called when the user closes the Options dialog that contains this page.
    /// The &quot;Accepted&quot; parameter is True if the user clicked OK, or False if the
    /// user clicked Cancel 
    /// </summary>
    procedure DialogClosed(Accepted: Boolean);
    /// <summary>
    /// Called before the dialog is closed. Allows you to validate the input on
    /// your option page.  If there is invalid input, you should display an error
    /// message and return False.  Return True if there are no errors 
    /// </summary>
    function ValidateContents: Boolean;
    /// <summary>
    /// Return the Help Context for this options page 
    /// </summary>
    function GetHelpContext: Integer;
    /// <summary>
    /// Indicates whether or not this page will be automatically included in IDE
    /// Insight.  If True, it will be included in the &quot;Preferences&quot; node like all
    /// built-in pages from the Tools | Options dialog.  It is recommended that
    /// you return True. 
    /// </summary>
    function IncludeInIDEInsight: Boolean;

    property Area: string read GetArea;
    property Caption: string read GetCaption;
    property FrameClass: TCustomFrameClass read GetFrameClass;
    property HelpContext: Integer read GetHelpContext;
  end;
  {$IFDEF LINUX}
  {$NODEFINE INTAAddinOptions}
  {$ENDIF}

  /// <summary>
  /// Interface implemented by a client to getting information
  /// about changing options.
  /// </summary>
  IOTEnvironmentOptionsNotifier = interface(IOTANotifier)
    ['{DB3A817C-F116-44BA-8A9C-0D1B99082DF0}']
    /// <summary>
    /// Called after changing options of the desktop category.
    /// </summary>
    procedure EnvironmentDesktopChanging;
  end;

  IOTAEnvironmentOptions140 = interface(IOTAOptions)
    ['{9C0E91FB-FA5A-11D1-AB28-00C04FB16FB3}']
    /// <summary>
    /// Opens the Options dialog, focusing an Area and an optional Page.  If Area
    /// is an empty string, the &quot;Third Party&quot; area will be assumed.  If PageCaption
    /// is an empty string, then the top level node specified by &quot;Area&quot; will be
    /// focused 
    /// </summary>
    procedure EditOptions(const Area: string; const PageCaption: string = ''); overload;
  end;

  IOTAEnvironmentOptions280 = interface(IOTAEnvironmentOptions140)
    ['{6000D4A0-FBD5-4C34-9B7F-6D72A90795B6}']
    /// <summary>
    /// Add event for change any environment options. 
    /// </summary>
    function AddNotifier(const ANotifier: IOTEnvironmentOptionsNotifier): Integer;
    /// <summary>
    /// Remove event for change environment options. 
    /// </summary>
    procedure RemoveNotifier(Index: Integer);
  end;

  IOTAEnvironmentOptions = interface(IOTAEnvironmentOptions280)
    ['{8BE50634-54B0-4D9C-B53A-BB99509A33E9}']
  end;

  IOTACustomOptions = interface(IUnknown)
    ['{153495D4-7512-4203-BA67-4459AA201880}']
    /// <summary>
    /// Get the value of the named option. 
    /// </summary>
    function GetOptionValue(const ValueName: string): Variant;
    /// <summary>
    /// Set the value of the named option. 
    /// </summary>
    procedure SetOptionValue(const ValueName: string; const Value: Variant);
    /// <summary>
    /// Get the list of available options for this option structure 
    /// </summary>
    function GetOptionNames: TOTAOptionNameArray;

    property Values[const ValueName: string]: Variant read GetOptionValue write SetOptionValue;
  end;

  INTAEnvironmentOptionsServices = interface(IUnknown)
    ['{88EAA6AC-B8C0-42F7-9C00-E5D31B815998}']
    /// <summary>
    /// Registers a page to be included in the Tools | Options dialog.  If AddInOptions
    /// also implements IOTACustomOptions, then those options will become available to
    /// other addins via:
    ///   IOTAEnvironmentOptions.GetOptionNames
    ///   IOTAEnvironmentOptions.GetOptionValue
    ///   IOTAEnvironmentOptions.SetOptionValue
    ///     
    /// </summary>
    procedure RegisterAddInOptions(const AddInOptions: INTAAddInOptions);
    /// <summary>
    /// Unregisters a previously registered page 
    /// </summary>
    procedure UnregisterAddInOptions(const AddInOptions: INTAAddInOptions);
  end;
  {$IFDEF LINUX}
  {$NODEFINE INTAEnvironmentOptionsServices}
  {$ENDIF}

  /// <summary>
  /// Allows Help Insight to show documentation information
  /// from the current symbol in the code editor.
  /// Query for it from the IOTAModule. If it isn't present,
  /// then this feature is not present.
  /// </summary>
  IOTAHelpInsight = interface(IDispatch)
    ['{D05FBF46-8468-4934-BF70-7EAE1AB8FEAB}']
    function GetEditorDocInfo(var Line: Integer; var Col: Integer; var Width: Integer): WideString; safecall;
    function GetSymbolDocInfo(const SymbolName: WideString): WideString; safecall;
    function IsEnabled: Boolean; safecall;
  end;

  INTAServices40 = interface(IUnknown)
    ['{3C7F3267-F0BF-11D1-AB1E-00C04FB16FB3}']
    /// <summary>
    /// Adds an image to the IDE's main image list.  Use the return value as an
    /// image index for an action item added to the IDE's main action list. This
    /// method is deprecated in favor of the new AddMasked method on the
    /// INTAServices interface defined below 
    /// </summary>
    function AddMasked(Image: TBitmap; MaskColor: TColor): Integer; overload;
    /// <summary>
    /// Returns the IDE's Main ActionList component 
    /// </summary>
    function GetActionList: TCustomActionList;
    /// <summary>
    /// Returns the IDE's Main ImageList component 
    /// </summary>
    function GetImageList: TCustomImageList;
    /// <summary>
    /// Returns the IDE's Main Menu component 
    /// </summary>
    function GetMainMenu: TMainMenu;
    /// <summary>
    /// Returns the named Toolbar 
    /// </summary>
    function GetToolBar(const ToolBarName: string): TToolBar;

    property ActionList: TCustomActionList read GetActionList;
    property ImageList: TCustomImageList read GetImageList;
    property MainMenu: TMainMenu read GetMainMenu;
    property ToolBar[const ToolBarName: string]: TToolBar read GetToolBar;
  end;
  {$IFDEF LINUX}
  {$NODEFINE INTAServices40}
  {$ENDIF}

  INTAServices70 = interface(INTAServices40)
    ['{C17B3DF1-DFE5-11D2-A8C7-00C04FA32F53}']
    /// <summary>
    /// Adds an image to the IDE's main image list.  Use the return value as an
    /// image index for an action item added to the IDE's main action list.  Ident
    /// is used to identify dynamically added images that may already exist in the
    /// imagelist. Since images cannot be safely deleted without causing incorrect
    /// glyphs to be used for all subsequent images, this allows an add-in to be
    /// unloaded then reloaded in the same IDE session and still acquire the same
    /// image index 
    /// </summary>
    function AddMasked(Image: TBitmap; MaskColor: TColor; const Ident: string): Integer; overload;
  end;
  {$IFDEF LINUX}
  {$NODEFINE INTAServices70}
  {$ENDIF}

  /// <summary>
  /// INTACustomizeToolbarNotifier - When calling INTAServices.CustomizeToolbars,
  /// provide this interface in order to handle events from the customize dialog.
  /// These events are backed by default behaviors, so not all methods need to
  /// do anything except return.
  /// This interface can also be registered in order to get events for when
  /// *anyone* calls INTAServices.CustomizeToolbars.  In this case, this notifier
  /// will only be called *after* the caller of CustomizeToolbar's notifier is
  /// called.  Not all events will be called as noted below. 
  /// </summary>

  INTACustomizeToolbarNotifier = interface(IOTANotifier)
    ['{34F2C852-0B8C-4352-908D-94038E79CC0D}']
    /// <summary>
    /// Create a TToolButton or even some other control that will be placed on the
    /// toolbar when dropped.  This control should be created based on the given
    /// action.  The control doesn't have to be a button.  For instance it may
    /// be a Combobox.  The first notifier that returns with Button &lt;&gt; nil stops
    /// the calling of subsequent notifiers. 
    /// </summary>
    procedure CreateButton(AOwner: TComponent; var Button: TControl;
      Action: TBasicAction);
    /// <summary>
    /// This event is called in order to determine what the display name of the
    /// action should be and whether or not it should be displayed at all. 
    /// </summary>
    procedure FilterAction(Action: TBasicAction; ViewingAllCommands: Boolean;
      var DisplayName: string; var Display: Boolean; var Handled: Boolean);
    /// <summary>
    /// This event is called in order to determine the display name of a category or
    /// whether or not the category is even displayed at all 
    /// </summary>
    procedure FilterCategory(var Category: string; var Display: Boolean;
      var Handled: Boolean);
    /// <summary>
    /// This event is called in response to the user pressing reset in the
    /// customize dialog.  Note this event is *not* called for general listeners. 
    /// </summary>
    procedure ResetToolbar(var Toolbar: TWinControl);
    /// <summary>
    /// Called when the user checks or unchecks the check box next to the given
    /// toolbar in the list of editable toolbars.  Note this event is *not* called
    /// for general listeners. 
    /// </summary>
    procedure ShowToolbar(Toolbar: TWinControl; Show: Boolean);
    /// <summary>
    /// Called whenever any toolbar actually got modified during the customize
    /// operation.  Callers of CustomizeToolbars, will get this event called first,
    /// and should stream the state of the toolbar so that other listeners can
    /// reload their state.  General listeners should check the toolbar name and
    /// reload their toolbar if this is a like-named instance and this is not the
    /// instance they just customized. 
    /// </summary>
    procedure ToolbarModified(Toolbar: TWinControl);
  end;

  INTACustomizeToolbarNotifier190 = interface(INTACustomizeToolbarNotifier)
    ['{E288D5FE-CC41-4D2F-ADE6-1DDC2D5CCFFA}']
    /// <summary>
    /// Called when the IDE main form receives a WM_CAPTURECHANGED windows message.
    /// The toolbar handler should perform proper operations, e.g. closing popup
    /// forms. 
    /// </summary>
    procedure CancelMode;
  end;

  /// <summary>
  /// INTAToolbarStreamNotifier - Register this interface to receive events
  /// related reading and writing of a toolbar to a stream. 
  /// </summary>

  INTAToolbarStreamNotifier = interface(IOTANotifier)
    ['{A2D9F2F7-815E-4E5B-BD83-2BD4A57A45E1}']
    /// <summary>
    /// This method is called from WriteToolbar immediately after the toolbar
    /// was saved to the stream. 
    /// </summary>
    procedure AfterSave(Toolbar: TWinControl);
    /// <summary>
    /// This method is called from WriteToolbar just before the toolbar is saved
    /// to the stream. 
    /// </summary>
    procedure BeforeSave(Toolbar: TWinControl);
    /// <summary>
    /// ToolbarLoaded is called from within Readtoolbar immediately after the
    /// toolbar was loaded from the stream.  If the toolbar was not actually
    /// constructed from the stream, this method is *not* called. 
    /// </summary>
    procedure ToolbarLoaded(Toolbar: TWinControl);
  end;

  INTAToolbarStreamNotifier190 = interface(INTAToolbarStreamNotifier)
    ['{9170ADE2-7D04-4B6C-AF74-9F56FB1AA29B}']
    /// <summary>
    /// This method is called just before the toolbar is loaded from the stream. 
    /// </summary>
    procedure BeforeLoad(Toolbar: TWinControl);
  end;

  /// <summary>
  /// INTAReadToolbarNotifier - Register this interface to get certain VCL
  /// streaming events so that when toolbars are streamed in, events on the
  /// components can be re-attached to the proper instance. See information
  /// on TReader for the explanation of these events. 
  /// </summary>
  INTAReadToolbarNotifier = interface(IOTANotifier)
    ['{748F68BB-599C-4BE4-83A3-EEEBD920B6EE}']
    procedure FindMethodInstance(Reader: TReader; const MethodName: string;
      var Method: TMethod; var Error: Boolean);
    procedure SetName(Reader: TReader; Component: TComponent; var Name: string; var Handled: Boolean);
    procedure ReadError(Reader: TReader; const Message: string; var Handled: Boolean);
  end;

  /// <summary>
  /// INTAWriteToolberNotifier - Register this interface to get certain VCL
  /// streaming events so that when the toolbars are streamed out, events on the
  /// components can have names associated with other objects 
  /// </summary>
  INTAWriteToolbarNotifier = interface(IOTANotifier)
    ['{89B84491-A034-4097-AD64-4BAA5211BF2E}']
    procedure FindMethodName(Writer: TWriter; Method: TMethod; var MethodName: string);
  end;

  INTAServices90 = interface(INTAServices70)
    ['{89160C3A-8EF4-4D2E-8FD5-D8492F61DB3E}']
    /// <summary>
    ///  AddImages takes all the images from the given image list and adds them to the
    ///  main application imagelist.  It also creates an internal mapping array from the
    ///  original image indices to the new indices in the main imagelist.  This
    ///  mapping is used by AddActionMenu to remap the ImageIndex property of the
    ///  action object to the new ImageIndex.  This should be the first method
    ///  called when adding actions and menu items to the main application window.
    ///  The return value is the first index in the main application image list of
    ///  the first image in the source list. Call this function with an nil
    ///  image list to clear the internal mapping array. 
    /// </summary>
    function AddImages(AImages: TCustomImageList): Integer; overload;
    /// <summary>
    ///  AddActionMenu takes an action item, a menu item, and a menu item component name
    ///  and inserts the action in to the main action list and the menu item into the
    ///  menu either preceding or following the named menu component.  If the action
    ///  component has an ImageIndex &gt; -1, then the mapping table created by the
    ///  previous call to AddImages above is used to determine the new value for
    ///  ImageIndex.  NewAction can be nil, in which case only the menu item is
    ///  added. Likewise, NewMenu can be nil, in which case the Name param is
    ///  ignored and only the action is added to the main action list. If Name
    ///  cannot be found, an exception is raised.  If the ImageIndex of NewAction
    ///  is out of range, then it is set to -1.  When InsertAsChild is True the InsertAfter
    ///  parameter determines the child position.  If InsertAfter is False, then the new
    ///  menu item becomes the first child, when it's True it's made the last child. 
    /// </summary>
    procedure AddActionMenu(const Name: string; NewAction: TCustomAction;
      NewItem: TMenuItem; InsertAfter: Boolean = True; InsertAsChild: Boolean = False);
    /// <summary>
    ///  NewToolBar creates a new toolbar with the given name and caption.
    ///  If the ReferenceToolBar parameter is specified, it is used as a reference point
    ///  for insertion based on the InsertBefore parameter.  If InsertBefore is True, then
    ///  the new toolbar is inserted physically before the reference, else it is after.
    ///  if ReferenceToolBar is not specified, then the toolbar is inserted into a
    ///  position determined by the IDE. 
    /// </summary>
    function NewToolbar(const Name, Caption: string;
      const ReferenceToolBar: string = '';
      InsertBefore: Boolean = False): TToolbar;
    /// <summary>
    ///  AddToolButton creates a new toolbutton on the named toolbar using the given
    ///  Action component.  In order for the user to be able to add and remove this
    ///  toolbutton, an Action *must* be specified.  otherwise the user may remove
    ///  the button, never to return until the toolbar config entries in the registry
    ///  are deleted and the toolbars are reset to the original configuration. If
    ///  IsDivider is True, then Action is ignored since a divider toolbutton is
    ///  created. If you wish the toolbutton to have a dropdown menu, then owner-
    ///  ship of that menu *must* be transferred to the owner of the toolbutton. 
    /// </summary>
    function AddToolButton(const ToolBarName, ButtonName: string;
      AAction: TCustomAction; const IsDivider: Boolean = False;
      const ReferenceButton: string = ''; InsertBefore: Boolean = False): TControl;
    /// <summary>
    ///  UpdateMenuAccelerators causes the IDE to reset all the assigned accelerator
    ///  keys to the associated menu items.  This is the accelerators as defined in
    ///  the current keymap 
    /// </summary>
    procedure UpdateMenuAccelerators(Menu: TMenu);
    /// <summary>
    ///  ReadToolbar reads the configuration of the given toolbar from the
    ///  registry and recreates it if necessary. If SubKey is specified, it will
    ///  attempt to obtain a stream from that key first and if not found, then
    ///  will get the stream from the main toolbar key.  Use Subkey to read
    ///  view-specific version of a toolbar. You can also optionally pass in a
    ///  TStream object if you wish to control the actual storage of the stream
    ///  itself. Set DefaultToolbar to true in order to read one of the global
    ///  toolbars from the &quot;toolbar reset&quot; storage.  This is the default
    ///  configuration of the toolbar. 
    /// </summary>
    procedure ReadToolbar(AOwner: TComponent; AParent: TWinControl; const AName: string;
      var AToolBar: TWinControl; const ASubKey: string = ''; AStream: TStream = nil;
      DefaultToolbar: Boolean = False);
    /// <summary>
    ///  WriteToolbar will take the given toolbar and write it out to the registry
    ///  under the subkey name if specified.  Use SubKey to write view-specific
    ///  versions of a toolbar. 
    /// </summary>
    procedure WriteToolbar(AToolbar: TWinControl; const AName: string = '';
      const ASubkey: string = ''; AStream: TStream = nil);
    /// <summary>
    ///  CustomizeToolbars will open the toolbar customize dialog and set the given
    ///  toolbars into customize mode.  The INTACustomizeToolbarNotifier interface
    ///  is used to handler certain events during the customizing process.  If
    ///  ActionList is specified, then only the actions in that action list can
    ///  be used to customize the toolbar.  If not specified, =nil, then the IDE's
    ///  global action list is used.  The return value is the customize dialog
    ///  component.  You can add a FreeNotification in order to know when the user
    ///  closes the dialog and customization is complete. 
    /// </summary>
    function CustomizeToolbar(const AToolbars: array of TWinControl;
      const ANotifier: INTACustomizeToolbarNotifier; AButtonOwner: TComponent = nil;
      AActionList: TCustomActionList = nil; AButtonsOnly: Boolean = True): TComponent;
    /// <summary>
    ///  Call CloseCustomize when it is needed to forcibly terminate the customize
    ///  mode.  For instance if the view being customized is destroyed or hidden,
    ///  this procedure may be called to terminate customization. 
    /// </summary>
    procedure CloseCustomize;
    /// <summary>
    ///  Call ToolbarModified if you wish to notify all interested parties that
    ///  a toolbar was modified by means other than calling CustomizeToolbar.  For
    ///  instance, when the toolbar is on a TControlBar and the toolbar band was
    ///  repositioned.  This will cause all registered INTACustomizeToolbarNotifier.ToolbarModified
    ///  events to be called. 
    /// </summary>
    procedure ToolbarModified(AToolbar: TWinControl);
    /// <summary>
    ///  RegisterToolbarNotifier registers the given INTACustomizeToolbarNotifier
    ///  in order to receive certain events related to toolbars and customizing
    ///  them.  The most often used event will probably be the ToolbarModified
    ///  event since that is how other views can know when a particular named
    ///  toolbar is customized. 
    /// </summary>
    function RegisterToolbarNotifier(const ANotifier: IOTANotifier): Integer;
    procedure UnregisterToolbarNotifier(Index: Integer);
    /// <summary>
    ///  MenuBegin/EndUpdate allows the caller to control how often the main
    ///  menu will be updated.  If many changes to the main menu are made at
    ///  one time performance can be improved by using these methods. 
    /// </summary>
    procedure MenuBeginUpdate;
    procedure MenuEndUpdate;
  end;
  {$IFDEF LINUX}
  {$NODEFINE INTAServices90}
  {$ENDIF}

  INTAServices120 = interface(INTAServices90)
    ['{26B056B7-FB49-41BC-A8C2-151DE1EBF465}']
    /// <summary>
    ///  AddImages takes all the images from the given image list and adds them to the
    ///  main application imagelist.  It also creates an internal mapping array from the
    ///  original image indices to the new indices in the main imagelist.  This
    ///  mapping is used by AddActionMenu to remap the ImageIndex property of the
    ///  action object to the new ImageIndex.  This should be the first method
    ///  called when adding actions and menu items to the main application window.
    ///  The return value is the first index in the main application image list of
    ///  the first image in the source list. Call this function with an nil
    ///  image list to clear the internal mapping array. Unlike the AddImages function from
    ///  the ancestor interface, this version takes an Ident that allows the same base index
    ///  to be re-used.  This is useful when the IDE implements demand-loading of
    ///  personalities so that the images will only get registered once and the same image
    ///  indices can be used.
    /// </summary>
    function AddImages(AImages: TCustomImageList; const Ident: string): Integer; overload;
  end;
  {$IFDEF LINUX}
  {$NODEFINE INTAServices120}
  {$ENDIF}

  INTACustomDockableForm = interface(IUnknown)
    ['{F8EF756F-4E95-4F1F-B229-A3DEF7BCC350}']
    /// <summary>
    /// Returns the Caption for the Dockable Form 
    /// </summary>
    function GetCaption: string;
    /// <summary>
    /// Returns a unique identifier for this form.  This should not be translated.
    /// This identifier is used as the section name when saving information for
    /// this form in the desktop state file 
    /// </summary>
    function GetIdentifier: string;
    /// <summary>
    /// Returns the class of the frame that you want embedded in the dockable form 
    /// </summary>
    function GetFrameClass: TCustomFrameClass;
    /// <summary>
    /// Called when an instance of the specified frame class is created 
    /// </summary>
    procedure FrameCreated(AFrame: TCustomFrame);
    /// <summary>
    /// Returns an action list that is used to populate the form's context menu.
    /// By default the context menu will have 2 items that are common to all
    /// dockable forms in the IDE: &quot;Stay on top&quot; and &quot;Dockable&quot;.  If the form
    /// has a toolbar, there will also be a &quot;Toolbar&quot; menu item.  If this
    /// function returns a non-nil action list, the items in the action list will
    /// be added to the menu (above the default items).  To specify sub-menus, use
    /// categories for the actions contained in the Action List.  Any action that
    /// has a Category set, will appear on a sub-menu in the context menu.  The
    /// Caption of the Parent menu will be the Category name. 
    /// </summary>
    function GetMenuActionList: TCustomActionList;
    /// <summary>
    /// Returns an image list that contains the images associated with the action
    /// list returned by GetMenuActionList 
    /// </summary>
    function GetMenuImageList: TCustomImageList;
    /// <summary>
    /// Called when the popup menu is about to be shown.  This allows further
    /// customization beyond just adding items from an Action List 
    /// </summary>
    procedure CustomizePopupMenu(PopupMenu: TPopupMenu);
    /// <summary>
    /// Returns an action list that is used to populate a toolbar on the form.  If
    /// nil is returned, then the dockable form will not have a toolbar.  Items in
    /// the Action List that have '-' as the caption will be added to the toolbar
    /// as a separator 
    /// </summary>
    function GetToolBarActionList: TCustomActionList;
    /// <summary>
    /// Returns an image list that contains the images associated with the action
    /// list returned by GetToolbarActionList 
    /// </summary>
    function GetToolBarImageList: TCustomImageList;
    /// <summary>
    /// Called after the toolbar has been populated with the Action List returned
    /// from GetToolbarActionList.  This allows further customization beyond just
    /// adding items from an Action List 
    /// </summary>
    procedure CustomizeToolBar(ToolBar: TToolBar);
    /// <summary>
    /// Called when state for this form is saved to a desktop file.  The Section
    /// paramter is passed in for convenience, but it should match the string
    /// returned by GetIdentifier.  This is only called for INTACustomDockableForm
    /// instances that have been registered using INTAServices.RegisterDockableForm.
    /// IsProject indicates whether the desktop being saved is a project desktop
    /// (as opposed to a dekstop state) 
    /// </summary>
    procedure SaveWindowState(Desktop: TCustomIniFile; const Section: string; IsProject: Boolean);
    /// <summary>
    /// Called when state for this form is loaded from a desktop file.  The
    /// Section paramter is passed in for convenience, but it should match the
    /// string returned by GetIdentifier.  This is only called for
    /// INTACustomDockableForm instances that have been registered using
    /// INTAServices.RegisterDockableForm 
    /// </summary>
    procedure LoadWindowState(Desktop: TCustomIniFile; const Section: string);
    /// <summary>
    /// Allows the form to control the enabled state of the clipboard commands on
    /// the IDE's &quot;Edit&quot; menu when this view is active 
    /// </summary>
    function GetEditState: TEditState;
    /// <summary>
    /// Called when the user uses one of the clipboard commands on the IDE's &quot;Edit&quot;
    /// menu 
    /// </summary>
    function EditAction(Action: TEditAction): Boolean;

    property Caption: string read GetCaption;
    property Identifier: string read Getidentifier;
    property FrameClass: TCustomFrameClass read GetFrameClass;
    property MenuActionList: TCustomActionList read GetMenuActionList;
    property MenuImageList: TCustomImageList read GetMenuImageList;
    property ToolbarActionList: TCustomActionList read GetToolbarActionList;
    property ToolbarImageList: TCustomImageList read GetToolbarImageList;
  end;
  {$IFDEF LINUX}
  {$NODEFINE INTACustomDockableForm}
  {$ENDIF}

  INTAServices270 = interface(INTAServices120)
    ['{110613A9-58E6-44E7-B757-BBF3A5EF5EB8}']
    /// <summary>
    /// Registers an INTACustomDockableForm with the IDE.  Registration is not
    /// required, but doing so will allow the form to participate in saving to and
    /// loading from a desktop state.  To ensure proper handling of the desktop
    /// state that is loaded during IDE startup, be sure to call
    /// RegisterDockableForm from within a &quot;Register&quot; procedure in your package.
    /// If you do not want your form to participate in desktop saving, you can
    /// call CreateDockableForm directly without first registering your form 
    /// </summary>
    procedure RegisterDockableForm(const CustomDockableForm: INTACustomDockableForm);
    /// <summary>
    /// Unregisters a previously registered INTACustomDockableForm 
    /// </summary>
    procedure UnregisterDockableForm(const CustomDockableForm: INTACustomDockableForm);
    /// <summary>
    /// Creates and displays an INTACustomDockableForm.  Returns the form instance
    /// that was created. 
    /// </summary>
    function CreateDockableForm(const CustomDockableForm: INTACustomDockableForm): TCustomForm;
  end;
  {$IFDEF LINUX}
  {$NODEFINE INTAServicesXXX}
  {$ENDIF}

  INTAServices280 = interface(INTAServices270)
    ['{71CA6882-3585-4AB3-9341-5806333ED0C6}']
    /// <summary>
    /// Adding multi-resolution bitmap into IDE ImageList for support high DPI
    /// </summary>
    function AddImage(const AImageName: string; const AImage: TGraphicArray): Integer;
  end;
  {$IFDEF LINUX}
  {$NODEFINE INTAServices280}
  {$ENDIF}

  INTAServices = interface(INTAServices280)
    ['{8209041F-F37F-4570-88B8-6C310FFFF81A}']
  end;
  {$IFDEF LINUX}
  {$NODEFINE INTAServices}
  {$ENDIF}

  IOTAServices50 = interface(IUnknown)
    ['{7FD1CE91-E053-11D1-AB0B-00C04FB16FB3}']
    /// <summary>
    /// General IDE event notifications 
    /// </summary>
    function AddNotifier(const Notifier: IOTAIDENotifier): Integer;
    /// <summary>
    /// Remove the index'd notifier 
    /// </summary>
    procedure RemoveNotifier(Index: Integer);
    /// <summary>
    /// Configuration Access 
    /// </summary>
    function GetBaseRegistryKey: string;
    /// <summary>
    /// Returns the product Identifier, 'C++Builder' or 'Delphi' 
    /// </summary>
    function GetProductIdentifier: string;
{$IFDEF MSWINDOWS}
    /// <summary>
    /// Main application handle 
    /// </summary>
    function GetParentHandle: HWND;
{$ENDIF}
    /// <summary>
    /// Return an interface to the IDE environment options 
    /// </summary>
    function GetEnvironmentOptions: IOTAEnvironmentOptions;
  end;

  IOTAServices60 = interface(IOTAServices50)
    ['{577ECE00-59EE-4F21-8190-9FD8A45FE550}']
    /// <summary>
    /// Return 'xfm' for CLX designer, 'dfm' for VCL designer, 'fmx' for FMX designer 
    /// </summary>
    function GetActiveDesignerType: string;
  end;

  IOTAServices70 = interface(IOTAServices60)
    ['{0044BB24-425D-D611-9CF1-00C04FA06AFC}']
    /// <summary>
    /// Returns the location of the root installation directory of the IDE 
    /// </summary>
    function GetRootDirectory: string;
    /// <summary>
    /// Returns the location of the bin directory 
    /// </summary>
    function GetBinDirectory: string;
    /// <summary>
    /// Returns the location of the template/object-repository directory 
    /// </summary>
    function GetTemplateDirectory: string;
  end;

  IOTAServices100 = interface(IOTAServices70)
    ['{33B33186-3CEC-4624-970E-417A8FE14089}']
    /// <summary>
    /// Returns the location of the Application Data directory for the
    /// current user and product. 
    /// </summary>
    function GetApplicationDataDirectory: string;
  end;

  IOTAServices110 = interface(IOTAServices100)
    ['{17A48937-2C9C-4543-AB6D-2CF13BAE544B}']
    /// <summary>
    /// Returns the location of the Local Application Data directory for the
    /// current user and product. 
    /// </summary>
    function GetLocalApplicationDataDirectory: string;
  end;

  IOTAServices140 = interface(IOTAServices110)
    ['{80E56DFA-82B2-425A-921E-8E5ED6164A11}']
    /// <summary>
    /// Returns the IDE's preferred UI languages as comma separated string. 
    /// </summary>
    function GetIDEPreferredUILanguages: string;
  end;

  IOTAServices160 = interface(IOTAServices140)
    ['{86602DE0-50BF-4AE5-BAF4-D9438BD33218}']
    /// <summary>
    /// Returns the location of the default project directory 
    /// </summary>
    function GetStartupDirectory: string;
    /// <summary>
    /// Returns True if the FileName's extension matches a known project file
    /// extension for the currently installed personalities.  If you already
    /// have a module open use Supports(Module, IOTAProject) to check instead. 
    /// </summary>
    function IsProject(const FileName: string): Boolean;
    /// <summary>
    /// Returns True if the FileName's extension matches a known project group
    /// extension. 
    /// </summary>
    function IsProjectGroup(const FileName: string): Boolean;
    /// <summary>
    /// This function will create a temporary file in the temp/embarcadero
    /// directory and copy the contents of the stream to the file.  The file
    /// will be deleted when the IDE is shut down. 
    /// </summary>
    function SaveStream(const Stream: IStream): string;
  end;

  IOTAServices = interface(IOTAServices160)
    ['{D1358CFB-9B5C-4E6C-BC4B-C6D06C6689C1}']
    /// <summary>
    /// ExpandRootMacro will change a string that contains $(BDS) or any $(name)
    /// and expands that environment variable. So for example $(BDS)\bin will be
    /// expanded to C:\Program Files\Embarcadero\10.0\bin assuming that
    /// BDS=C:\Program Files\Embarcadero\10.0 
    /// </summary>
    function ExpandRootMacro(const S: string): string;
  end;

  IOTABufferOptions60 = interface(IUnknown)
    ['{8C748540-C6C1-11D2-8139-00609792F134}']
    function GetAutoIndent: Boolean;
    function GetBackspaceUnindents: Boolean;
    function GetCreateBackupFile: Boolean;
    function GetCursorThroughTabs: Boolean;
    function GetInsertMode: Boolean;
    function GetGroupUndo: Boolean;
    function GetKeepTrailingBlanks: Boolean;
    function GetLeftGutterWidth: Integer;
    function GetRightMargin: Integer;
    function GetOverwriteBlocks: Boolean;
    function GetPersistentBlocks: Boolean;
    function GetPreserveLineEnds: Boolean;
    function GetSmartTab: Boolean;
    function GetSyntaxHighlight: Boolean;
    function GetTabStops: string;
    function GetUndoAfterSave: Boolean;
    function GetUndoLimit: Integer;
    function GetUseTabCharacter: Boolean;
    procedure SetAutoIndent(Value: Boolean);
    procedure SetBackspaceUnindents(Value: Boolean);
    procedure SetCreateBackupFile(Value: Boolean);
    procedure SetCursorThroughTabs(Value: Boolean);
    procedure SetInsertMode(Value: Boolean);
    procedure SetGroupUndo(Value: Boolean);
    procedure SetKeepTrailingBlanks(Value: Boolean);
    procedure SetLeftGutterWidth(Value: Integer);
    procedure SetRightMargin(Value: Integer);
    procedure SetOverwriteBlocks(Value: Boolean);
    procedure SetPersistentBlocks(Value: Boolean);
    procedure SetPreserveLineEnds(Value: Boolean);
    procedure SetSmartTab(Value: Boolean);
    procedure SetSyntaxHighlight(Value: Boolean);
    procedure SetTabStops(const Value: string);
    procedure SetUndoAfterSave(Value: Boolean);
    procedure SetUndoLimit(Value: Integer);
    procedure SetUseTabCharacter(Value: Boolean);

    property AutoIndent: Boolean read GetAutoIndent write SetAutoIndent;
    property BackspaceUnindents: Boolean read GetBackspaceUnindents write SetBackspaceUnindents;
    property CreateBackupFile: Boolean read GetCreateBackupFile write SetCreateBackupFile;
    property CursorThroughTabs: Boolean read GetCursorThroughTabs write SetCursorThroughTabs;
    property InsertMode: Boolean read GetInsertMode write SetInsertMode;
    property GroupUndo: Boolean read GetGroupUndo write SetGroupUndo;
    property KeepTrailingBlanks: Boolean read GetKeepTrailingBlanks write SetKeepTrailingBlanks;
    property LeftGutterWidth: Integer read GetLeftGutterWidth write SetLeftGutterWidth;
    property RightMargin: Integer read GetRightMargin write SetRightMargin;
    property OverwriteBlocks: Boolean read GetOverwriteBlocks write SetOverwriteBlocks;
    property PersistentBlocks: Boolean read GetPersistentBlocks write SetPersistentBlocks;
    property PreserveLineEnds: Boolean read GetPreserveLineEnds write SetPreserveLineEnds;
    property SmartTab: Boolean read GetSmartTab write SetSmartTab;
    property SyntaxHighlight: Boolean read GetSyntaxHighlight write SetSyntaxHighlight;
    property TabStops: string read GetTabStops write SetTabStops;
    property UndoAfterSave: Boolean read GetUndoAfterSave write SetUndoAfterSave;
    property UndoLimit: Integer read GetUndoLimit write SetUndoLimit;
    property UseTabCharacter: Boolean read GetuseTabCharacter write SetUseTabCharacter;
  end;

  IOTABufferOptions70 = interface(IOTABufferOptions60)
    ['{F8F13ACE-1124-408F-934F-8E92DA135424}']
    function GetShowSpace: Boolean;
    function GetShowTab: Boolean;
    procedure SetShowSpace(Value: Boolean);
    procedure SetShowTab(Value: Boolean);
    property ShowSpace: Boolean read GetShowSpace write SetShowSpace;
    property ShowTab: Boolean read GetShowTab write SetShowTab;
  end;

  IOTABufferOptions = interface(IOTABufferOptions70)
    ['{38E7F12C-7682-40E9-B13B-9C2E36BDBAFC}']
    function GetHighlightCurrentLine: Boolean;
    function GetShowLineBreaks: Boolean;
    procedure SetHighlightCurrentLine(Value: Boolean);
    procedure SetShowLineBreaks(Value: Boolean);
    property HighlightCurrentLine: Boolean read GetHighlightCurrentLine write SetHighlightCurrentLine;
    property ShowLineBreaks: Boolean read GetShowLineBreaks write SetShowLineBreaks;
  end;

  IOTAEditLineNotifier = interface(IOTANotifier)
    ['{D9D48F50-E6CC-11D2-ABE8-00C04FB16FB3}']
    procedure LineChanged(OldLine, NewLine: Integer; Data: Integer);
  end;

  IOTAEditLineTracker = interface(IUnknown)
    ['{D9D48F4F-E6CC-11D2-ABE8-00C04FB16FB3}']
    function AddNotifier(const Notifier: IOTAEditLineNotifier): Integer;
     
    procedure AddLine(Line: Integer; Data: Integer);
    procedure Delete(Index: Integer);
    function GetCount: Integer;
    function GetData(Index: Integer): Integer;
    function GetEditBuffer: IOTAEditBuffer;
    function GetLineNum(Index: Integer): Integer;
    function IndexOfLine(Line: Integer): Integer;
    function IndexOfData(Data: Integer): Integer;
    procedure RemoveNotifier(Index: Integer);
    procedure SetData(Index: Integer; Value: Integer);
    procedure SetLineNum(Index: Integer; Value: Integer);

    property Count: Integer read GetCount;
    property Data[Index: Integer]: Integer read GetData write SetData;
    property LineNum[Index: Integer]: Integer read GetLineNum write SetLineNum;
  end;

  IOTAEditBuffer60 = interface(IOTASourceEditor)
    ['{9C510460-C7BC-11D2-9AEB-00A02457621F}']
    procedure ClearUndo;
    function GetBufferOptions: IOTABufferOptions;
    function GetCurrentDate: TDateTime;
    function GetEditBlock: IOTAEditBlock;
    function GetEditLineTracker: IOTAEditLineTracker;
    function GetEditPosition: IOTAEditPosition;
    function GetInitialDate: TDateTime;
    function GetIsModified: Boolean;
    function GetIsReadOnly: Boolean;
    function GetTopView: IOTAEditView;
    function Print: Boolean;
    function Redo: Boolean;
    procedure SetIsReadOnly(Value: Boolean);
    function Undo: Boolean;

    property BufferOptions: IOTABufferOptions read GetBufferOptions;
    property EditBlock: IOTAEditBlock read GetEditBlock;
    property EditPosition: IOTAEditPosition read GetEditPosition;
    property IsModified: Boolean read GetIsModified;
    property IsReadOnly: Boolean read GetIsReadOnly write SetIsReadOnly;
    property TopView: IOTAEditView read GetTopView;
  end;

  IOTAEditBuffer = interface(IOTAEditBuffer60)
    ['{EB6465CE-D901-43C4-AB69-240A7400B9AA}']
    /// <summary>
    /// GetEditOptions returns the edit options for this current
    /// edit buffer. 
    /// </summary>
    function GetEditOptions: IOTAEditOptions;
    property EditOptions: IOTAEditOptions read GetEditOptions;
  end;

  IOTAEditBufferIterator = interface(IUnknown)
    ['{8ECB33AA-D0BD-11D2-ABD6-00C04FB16FB3}']
    function GetCount: Integer;
    function GetEditBuffer(Index: Integer): IOTAEditBuffer;

    property Count: Integer read GetCount;
    property EditBuffers[Index: Integer]: IOTAEditBuffer read GetEditBuffer;
  end;

  PKeyBindingRec = ^TKeyBindingRec;
  TKeyBindingRec = record
    KeyCode: TShortCut;
    KeyProc: TKeyBindingProc;
    Context: Pointer;
    Next: Integer;
    Reserved: Integer;
  end;

  IOTAKeyContext = interface(IUnknown)
    ['{3E7790CB-D2BB-11D2-ABD8-00C04FB16FB3}']
    function GetContext: Pointer;
    function GetEditBuffer: IOTAEditBuffer;
    function GetKeyboardServices: IOTAKeyboardServices;
    function GetKeyBindingRec(out BindingRec: TKeyBindingRec): Boolean;

    property Context: Pointer read GetContext;
    property EditBuffer: IOTAEditBuffer read GetEditBuffer;
    property KeyboardServices: IOTAKeyboardServices read GetKeyboardServices;
  end;

  IOTARecord = interface(IUnknown)
    ['{F8CAF8D6-D263-11D2-ABD8-00C04FB16FB3}']
    procedure Append(const Keys: array of TShortCut); overload;
    procedure Append(const CmdName: string; IsKeys: Boolean = True); overload;
    procedure Append(const ARecord: IOTARecord); overload;
    procedure Clear;
    function GetIsPaused: Boolean;
    function GetIsPlaying: Boolean;
    function GetIsRecording: Boolean;
    function GetName: string;
    procedure ReadFromStream(const Stream: IStream);
    procedure SetName(const Value: string);
    procedure WriteToStream(const Stream: IStream);

    property IsPaused: Boolean read GetIsPaused;
    property IsPlaying: Boolean read GetIsPlaying;
    property IsRecording: Boolean read GetIsRecording;
    property Name: string read GetName write SetName;
  end;

  TKeyBindingFlags = Integer;

  IOTAKeyBindingServices = interface(IUnknown)
    ['{F8CAF8D8-D263-11D2-ABD8-00C04FB16FB3}']
    function AddKeyBinding(const Keys: array of TShortCut; KeyProc: TKeyBindingProc;
      Context: Pointer; Flags: TKeyBindingFlags = kfImplicitShift or
      kfImplicitModifier or kfImplicitKeypad; const Keyboard: string = '';
      const MenuItemName: string = ''): Boolean;
    function AddMenuCommand(const Command: string; KeyProc: TKeyBindingProc;
      Context: Pointer): Boolean;
    procedure SetDefaultKeyProc(KeyProc: TKeyBindingProc; Context: Pointer;
      const Keyboard: string = '');
  end;

  IOTAKeyboardBinding = interface(IOTANotifier)
    ['{F8CAF8D7-D263-11D2-ABD8-00C04FB16FB3}']
    function GetBindingType: TBindingType;
    function GetDisplayName: string;
    function GetName: string;
    procedure BindKeyboard(const BindingServices: IOTAKeyBindingServices);

    property BindingType: TBindingType read GetBindingType;
    property DisplayName: string read GetDisplayName;
    property Name: string read GetName;
  end;

  IOTAKeyboardServices = interface(IUnknown)
    ['{F8CAF8D5-D263-11D2-ABD8-00C04FB16FB3}']
    function AddKeyboardBinding(const KeyBinding: IOTAKeyboardBinding): Integer;
    function GetCurrentPlayback: IOTARecord;
    function GetCurrentRecord: IOTARecord;
    function GetEditorServices: IOTAEditorServices;
    function GetKeysProcessed: LongWord;
    function NewRecordObject(out ARecord: IOTARecord): Boolean;
    procedure PausePlayback;
    procedure PauseRecord;
    procedure PopKeyboard(const Keyboard: string);
    function PushKeyboard(const Keyboard: string): string;
    procedure RestartKeyboardServices;
    procedure ResumePlayback;
    procedure ResumeRecord;
    procedure RemoveKeyboardBinding(Index: Integer);
    procedure SetPlaybackObject(const ARecord: IOTARecord);
    procedure SetRecordObject(const ARecord: IOTARecord);
    function LookupKeyBinding(const Keys: array of TShortCut;
      out BindingRec: TKeyBindingRec; const KeyBoard: string = ''): Boolean;
    function GetNextBindingRec(var BindingRec: TKeyBindingRec): Boolean;
    function CallKeyBindingProc(const BindingRec: TKeyBindingRec): TKeyBindingResult;

    property CurrentPlayback: IOTARecord read GetCurrentPlayback;
    property CurrentRecord: IOTARecord read GetCurrentRecord;
    property EditorServices: IOTAEditorServices read GetEditorServices;
    property KeysProcessed: LongWord read GetKeysProcessed;
  end;

  /// <summary>
  /// Allows reporting of keypresses and handlers to the message view.
  /// BorlandIDEServices implements this interface. 
  /// </summary>
  IOTAKeyboardDiagnostics = interface(IUnknown)
    ['{AEFC65F1-2504-11D3-AC25-00C04FB16FB3}']
    function GetKeyTracing: Boolean;
    procedure SetKeyTracing(Value: Boolean);

    property KeyTracing: Boolean read GetKeyTracing write SetKeyTracing;
  end;

  IOTASpeedSetting = interface(IOTANotifier)
    ['{B5CDCE07-E093-11D2-ABE2-00C04FB16FB3}']
    function GetDisplayName: string;
    function GetName: string;
    /// <summary>
    /// ExecuteSetting is passed the current editor options.
    /// If you want the speed setting to apply to all IOTAEditOptions, then
    /// you must enumerate through them using the IOTAEditorServices. 
    /// </summary>
    procedure ExecuteSetting(const EditOptions: IOTAEditOptions);
    property DisplayName: string read GetDisplayName;
    property Name: string read GetName;
  end;

  IOTAEditorColorSpeedSetting = interface(IOTANotifier)
    ['{C9BF69D9-06D4-4B10-A658-B75BBBBEFDF9}']
    /// <summary>
    /// This notifier will be called before the active Editor Color SpeedSetting changes. 
    /// </summary>
    procedure EditorColorChanging;
    /// <summary>
    /// This notifier will be called after the active Editor Color SpeedSetting changes. 
    /// </summary>
    procedure EditorColorChanged;
  end;

  IOTAEditOptions60 = interface(IUnknown)
    ['{487BEA91-DBC0-11D2-ABDE-00C04FB16FB3}']
    function AddSpeedSetting(const SpeedSetting: IOTASpeedSetting): Integer;

    procedure BeginUpdate;
    procedure EndUpdate;
    function GetBlockIndent: Integer;
    function GetBufferOptions: IOTABufferOptions;
    function GetFontName: string;
    function GetFontSize: Integer;
    function GetForceCutCopyEnabled: Boolean;
    function GetSpeedSettingCount: Integer;
    function GetSpeedSetting(Index: Integer): IOTASpeedSetting;
    /// <summary>
    /// GetSyntaxHighlightTypes is deprecated. Use SyntaxHighlighter. 
    /// </summary>
    function GetSyntaxHighlightTypes(Index: TOTASyntaxHighlighter): string; deprecated;
    function GetUseBriefCursorShapes: Boolean;
    function GetUseBriefRegularExpressions: Boolean;
    procedure RemoveSpeedSetting(Index: Integer);
    procedure SetBlockIndent(Value: Integer);
    procedure SetFontName(const Value: string);
    procedure SetFontSize(Value: Integer);
    procedure SetForceCutCopyEnabled(Value: Boolean);
    procedure SetSpeedSetting(const Name: string);
    /// <summary>
    /// SetSyntaxHighlightTypes is deprecated. Use SyntaxHighlighter. 
    /// </summary>
    procedure SetSyntaxHighlightTypes(Index: TOTASyntaxHighlighter; const Value: string); deprecated;
    procedure SetUseBriefCursorShapes(Value: Boolean);
    procedure SetUseBriefRegularExpressions(Value: Boolean);
    property BlockIndent: Integer read GetBlockIndent write SetBlockIndent;
    property BufferOptions: IOTABufferOptions read GetBufferOptions;
    property FontName: string read GetFontName write SetFontName;
    property FontSize: Integer read GetFontSize write SetFontSize;
    property ForceCutCopyEnabled: Boolean read GetForceCutCopyEnabled
      write SetForceCutCopyEnabled;
    property SpeedSettingCount: Integer read GetSpeedSettingCount;
    property SpeedSettings[Index: Integer]: IOTASpeedSetting read GetSpeedSetting;
    /// <summary>
    /// SyntaxHighlightTypes is deprecated. Use SyntaxHighlighter. 
    /// </summary>
    property SyntaxHighlightTypes[Index: TOTASyntaxHighlighter]: string
      read GetSyntaxHighlightTypes write SetSyntaxHighlightTypes;
    property UseBriefCursorShapes: Boolean read GetUseBriefCursorShapes
      write SetUseBriefCursorShapes;
    property UseBriefRegularExpressions: Boolean read GetUseBriefRegularExpressions
      write SetUseBriefRegularExpressions;
  end;

  /// <summary>
  /// IOTAEditOptions
  /// Certain options are now associated with particular file types,
  /// as seen in the Editor Options. Use the IOTAEditorServices to
  /// get options for a particular internal id, passing one of the
  /// cDefEd consts from the top of this unit.
  /// You may also add your own editor options using the IOTAEditorServices. 
  /// </summary>
  IOTAEditOptions = interface(IOTAEditOptions60)
    ['{02999EF7-669C-406B-8E14-4FE8B27542B8}']
    function GetExtensions: string;
    function GetOptionsName: string;
    function GetOptionsIDString: string;
    function GetSyntaxHighlighter: IOTAHighlighter;
    function GetOptionsIndex: Integer;
    procedure SetExtensions(const Value: string);
    procedure SetOptionsName(const Value: string);
    procedure SetSyntaxHighlighter(const Value: IOTAHighlighter);

    property Extensions: string read GetExtensions write SetExtensions;
    property OptionsName: string read GetOptionsName write SetOptionsName;
    property IDString: string read GetOptionsIDString;
    property SyntaxHighlighter: IOTAHighlighter read GetSyntaxHighlighter
      write SetSyntaxHighlighter;
    property OptionsIndex: Integer read GetOptionsIndex;
  end;

  IOTAEditorExplorerPersonalityTrait = interface(IOTANotifier)
    ['{76B0B1C4-A87D-473D-B6F5-CADCDEF78F30}']
    procedure ViewModified;
    procedure DoClassComplete;
    procedure DoClassNavigate;
  end;

  IOTAEditorServices60 = interface(IUnknown)
    ['{C2812BA7-C48D-11D2-9AE8-00A02457621F}']
    /// <summary>
    /// EditOptions/GetEditOptions now return the edit options for the active
    /// editor, which will be for whatever file type it is editing. 
    /// </summary>
    function GetEditOptions: IOTAEditOptions;
    function GetEditBufferIterator(out Iterator: IOTAEditBufferIterator): Boolean;
    function GetKeyboardServices: IOTAKeyboardServices;
    function GetTopBuffer: IOTAEditBuffer;
    function GetTopView: IOTAEditView;

    property EditOptions: IOTAEditOptions read GetEditOptions;
    property KeyboardServices: IOTAKeyboardServices read GetKeyboardServices;
    property TopBuffer: IOTAEditBuffer read GetTopBuffer;
    property TopView: IOTAEditView read GetTopView;
  end;

  IOTAEditorServices70 = interface(IOTAEditorServices60)
    ['{2596F557-44A3-49A6-867E-91E21E00F53E}']
    /// <summary>
    /// GetEditOptions returns the IOTAEditOptions associated with the
    /// IDString passed in, or nil if none was found. 
    /// </summary>
    function GetEditOptions(const IDString: string): IOTAEditOptions;
    /// <summary>
    /// GetEditOptionsForFile returns the IOTAEditOptions for a particular
    /// FileName, defaulting to the default options. 
    /// </summary>
    function GetEditOptionsForFile(const FileName: string): IOTAEditOptions;
    /// <summary>
    /// AddEditOptions returns the current IOTAEditOptions with IDString,
    /// or adds a new one if none was found. 
    /// </summary>
    function AddEditOptions(const IDString: string): IOTAEditOptions;
    /// <summary>
    /// DeleteEditOptions deletes the IOTAEditOptions with IDString,
    /// raising an exception if IDString was not found. 
    /// </summary>
    procedure DeleteEditOptions(const IDString: string);
    /// <summary>
    /// GetEditOptionsCount/EditOptionsCount are the count of the IOTAEditOptions 
    /// </summary>
    function GetEditOptionsCount: Integer;
    /// <summary>
    /// GetEditOptionsIndex is for iterating through the IOTAEditOptions 
    /// </summary>
    function GetEditOptionsIndex(Index: Integer): IOTAEditOptions;

    property EditOptionsCount: Integer read GetEditOptionsCount;
    property EditorOptions[Index: Integer]: IOTAEditOptions read GetEditOptionsIndex;
  end;

  IOTAEditorServices80 = interface(IOTAEditorServices70)
    ['{F37E8C46-0A02-4FD4-8D57-E55F9A5783EC}']
    function AddNotifier(const Notifier: INTAEditServicesNotifier): Integer;
    procedure RemoveNotifier(Index: Integer);
  end;

  IOTAEditorServices = interface(IOTAEditorServices80)
    ['{BE733055-5ED8-45B4-BAB1-19C46C237408}']
    function GetEditOptionsIDString(const FileName: String): string;
  end;

  INTAEditorServices = interface(IUnknown)
    ['{3CC6849A-6C72-49F8-BF63-E95083789141}']
    function GetEditWindowCount: Integer;
    function GetEditWindow(Index: Integer): INTAEditWindow;
    function GetTopEditWindow: INTAEditWindow;

    property EditWindowCount: Integer read GetEditWindowCount;
    property EditWindow[Index: Integer]: INTAEditWindow read GetEditWindow;
    property TopEditWindow: INTAEditWindow read GetTopEditWindow;
  end;

  /// <summary>
  /// Implement INTACustomEditorView to add a new tab along the top of the editor view
  /// If an INTACustomEditorView also implements IOTACustomEditorViewStructure,
  /// then the IOTACustomEditorViewStructure will be queried for the context to
  /// use to populate the Structure view.  See StructureViewAPI.pas 
  /// </summary>
  INTACustomEditorView = interface(IInterface)
    ['{E9465FAF-B671-4098-9ED9-AE4C05C5454A}']
    /// <summary>
    /// GetCanCloneView indicates whether this view type can be open in more than one
    /// editor window.  This is used when the user opens a new editor window via the
    /// View | New Edit Window menu in the IDE.  If this view is shown as part of the
    /// current module, and GetCanCloneView returns False, then the module will be moved
    /// to the new editor window.  If GetCanCloneView returns True, then the module
    /// will be copied into the new editor window, making is so that it is open in two
    /// places (the existing editor window and the new editor window 
    /// </summary>
    function GetCanCloneView: Boolean;
    /// <summary>
    /// If GetCanCloneView returns True, then CloneEditorView will be called when
    /// the view needs to be cloned (for instance, to be shown in another editor
    /// window) 
    /// </summary>
    function CloneEditorView: INTACustomEditorView;
    /// <summary>
    /// Returns the string to be shown in the editor view 
    /// </summary>
    function GetCaption: string;
    /// <summary>
    /// Returns a string to show in the Editor Window Caption when this
    /// view is active.  This is only shown with a floating Editor Window (in either
    /// an un-docked layout or when using View | New Edit Window 
    /// </summary>
    function GetEditorWindowCaption: string;

    /// <summary>
    /// The ViewIdentifier MUST be a unique ID for this view. It is internal,
    /// and should never change.  It should not be translated 
    /// </summary>
    function GetViewIdentifier: string;

    /// <summary>
    /// Allows the view to control the enabled state of the clipboard commands on
    /// the IDE's &quot;Edit&quot; menu when this view is active 
    /// </summary>
    function GetEditState: TEditState;
    /// <summary>
    /// Called when the user uses one of the clipboard commands on the IDE's &quot;Edit&quot;
    /// menu 
    /// </summary>
    function EditAction(Action: TEditAction): Boolean;
    /// <summary>
    /// Called when the user selects &quot;File | Close All&quot;.  Set ShouldClose to False
    /// to prevent your view from closing in response to a Close All.  Note: this
    /// should be done in very special cases only (for instance, the IDE's Welcome
    /// Page stays open when Close All is selected 
    /// </summary>
    procedure CloseAllCalled(var ShouldClose: Boolean);

    /// <summary>
    /// Called when the view is selected 
    /// </summary>
    procedure SelectView;
    /// <summary>
    /// Called when the view is de-selected 
    /// </summary>
    procedure DeselectView;

    /// <summary>
    /// Returns the frame class for this editor view or editor sub-view 
    /// </summary>
    function GetFrameClass: TCustomFrameClass;
    /// <summary>
    /// Called when an instance of the specified frame class is created 
    /// </summary>
    procedure FrameCreated(AFrame: TCustomFrame);

    property CanCloneView: Boolean read GetCanCloneView;
    property Caption: string read GetCaption;
    property EditorWindowCaption: string read GetEditorWindowCaption;
    property FrameClass: TCustomFrameClass read GetFrameClass;
    property ViewIdentifier: string read GetViewIdentifier;
  end;
  {$IFDEF LINUX}
  {$NODEFINE INTACustomEditorView}
  {$ENDIF}

  INTACustomEditorView150 = interface(INTACustomEditorView)
    ['{08A5E5C0-E3D5-44E0-BE0F-4ADC93C369A4}']
    /// <summary>
    /// Return the index of the image to be used for this editor view.  The return
    /// value is the index into the Editor/Project Manager glyph image list.  You
    /// should first add items to this list using INTAEditorViewServices.AddImages 
    /// </summary>
    function GetImageIndex: Integer;
    /// <summary>
    /// Return a string that will be displayed as the hint when the mouse hovers
    /// over this view's tab in the code editor. 
    /// </summary>
    function GetTabHintText: string;
    /// <summary>
    /// Called when the view is about to be closed.  Return False for the Allowed
    /// parameter if you want to prevent the view from closing 
    /// </summary>
    procedure Close(var Allowed: Boolean);
  end;
  {$IFDEF LINUX}
  {$NODEFINE INTACustomEditorView150}
  {$ENDIF}
  
  INTACustomEditorView280 = interface(INTACustomEditorView150)
    ['{76F27D95-E7F3-4A01-9C2C-FB2789A4FEB7}']
    /// <summary>
    ///  Return a TColor that will be used as the background color for the view's tab in the code editor. 
    ///
    ///  Note: return clNone for use the default IDE tab colors.
    /// </summary>
    function GetTabColor: TColor;
  end;
  

  /// <summary>
  /// If you want to have view-specific state information for this Editor View
  /// saved in the desktop file, you should also implement INTACustomEditorViewState 
  /// </summary>
  INTACustomEditorViewState = interface(IInterface)
    ['{AA6AA3D4-1A63-4A93-8964-450484F4B4D8}']
    /// <summary>
    /// LoadViewState and SaveViewState are called when a desktop is loaded and saved.
    /// You should use the provided TCustomIniFile and the ViewDeskSection to read and
    /// write state information for this view to the desktop file 
    /// </summary>
    procedure LoadViewState(const Desktop: TCustomIniFile; const ViewDeskSection: string);
    procedure SaveViewState(const Desktop: TCustomIniFile; const IsProject: Boolean;
      const ViewDeskSection: string);
  end;
  {$IFDEF LINUX}
  {$NODEFINE INTACustomEditorViewState}
  {$ENDIF}

  /// <summary>
  /// If you want view-specific information disaplyed in the editor window's status
  /// bar, you should also implement INTACustomEditorViewStatusPanel 
  /// </summary>
  INTACustomEditorViewStatusPanel = interface(IInterface)
    ['{39B8ECEB-3048-4733-BF3D-C76540D87AE2}']
    /// <summary>
    /// Return the number of panels to include in the status bar 
    /// </summary>
    function GetStatusPanelCount: Integer;
    /// <summary>
    /// Called to configure the status bar panels for this editor view.  Called for
    /// each Panel (check &quot;Panel.Index&quot; to see which TStatusPanel is being configured).
    /// Set properties on &quot;Panel&quot; to configure the panel.  Set &quot;Panel.Style&quot; to
    /// &quot;psOwnerDraw&quot; to have DrawPanel procedure called when painting the panel 
    /// </summary>
    procedure ConfigurePanel(StatusBar: TStatusbar; Panel: TStatusPanel);
    /// <summary>
    /// Called when a &quot;psOwnerDraw&quot; status bar panel needs to be painted 
    /// </summary>
    procedure DrawPanel(StatusBar: TStatusBar; Panel: TStatusPanel; const Rect: TRect);
  end;
  {$IFDEF LINUX}
  {$NODEFINE INTACustomEditorViewStatusPanel}
  {$ENDIF}

  /// <summary>
  /// Implement INTACustomEditorSubView to add a new lower tab in the editor
  /// For methods that take &quot;AContext: IInterface&quot; parameter, you can use one of
  /// the &quot;ContextTo...&quot; methods in INTAEditorViewServices to convert a non-nil
  /// AContext to something meaningful.
  /// 
  /// If an INTACustomEditorSubView also implements IOTACustomEditorSubViewStructure,
  /// then the IOTACustomEditorSubViewStructure will be queried for the context to
  /// use to populate the Structure view.  See StructureViewAPI.pas 
  /// </summary>
  INTACustomEditorSubView = interface(IInterface)
    ['{655AA26C-5898-4DB5-B21F-4F55E9B2B407}']
    /// <summary>
    /// GetCanCloneView indicates whether this view type can be open in more than one
    /// editor window.  This is used when the user opens a new editor window via the
    /// View | New Edit Window menu in the IDE.  If this view is shown as part of the
    /// current module, and GetCanCloneView returns False, then the module will be moved
    /// to the new editor window.  If GetCanCloneView returns True, then the module
    /// will be copied into the new editor window, making is so that it is open in two
    /// places (the existing editor window and the new editor window 
    /// </summary>
    function GetCanCloneView: Boolean;
    /// <summary>
    /// Returns the string to be shown in the editor tab 
    /// </summary>
    function GetCaption: string;
    /// <summary>
    /// Indicates the location of the tab for this editor view.  The &quot;Code&quot; tab will
    /// always be the left-most tab.  All other tabs are shown in priority order.
    /// The form designer is shown at &quot;HighViewPriority&quot; 
    /// </summary>
    function GetPriority: Integer;
    /// <summary>
    /// The ViewIdentifier MUST be a unique ID for this view. It is internal,
    /// and should never change.  It should not be translated 
    /// </summary>
    function GetViewIdentifier: string;
    /// <summary>
    /// Called when the view is displayed or hidden (&quot;hidden&quot; is indicated by a
    /// nil &quot;AContext&quot;). AViewObject is the frame instance created for this view 
    /// </summary>
    procedure Display(const AContext: IInterface; AViewObject: TObject);
    /// <summary>
    /// Called when the user uses one of the clipboard commands on the IDE's &quot;Edit&quot;
    /// menu 
    /// </summary>
    function EditAction(const AContext: IInterface; Action: TEditAction; AViewObject: TObject): Boolean;
    /// <summary>
    /// Allows the view to control the enabled state of the clipboard commands on
    /// the IDE's &quot;Edit&quot; menu when this view is active 
    /// </summary>
    function GetEditState(const AContext: IInterface; AViewObject: TObject): TEditState;
    /// <summary>
    /// Indicates whether or not this view handles the specified Context 
    /// </summary>
    function Handles(const AContext: IInterface): Boolean;
    /// <summary>
    /// Hide happens before this INTACustomEditorSubView is hidden and another one
    /// is shown.  It will actually be hidden with a call to Display(nil, AViewObject) 
    /// </summary>
    procedure Hide(const AContext: IInterface; AViewObject: TObject);
    /// <summary>
    /// This function is called when the editor window is closed/destroyed.  This
    /// is an indication that this view object should forget any information
    /// associated with this window/view.
    /// 
    /// NOTE: It does not happen on a per module basis, but rather when the
    /// ENTIRE edit window is closed. The current open View items will then get
    /// this notification. Use Destroyed on the module to find out when
    /// a particular module is closed 
    /// </summary>
    procedure ViewClosed(const AContext: IInterface; AViewObject: TObject);

    /// <summary>
    /// Returns the frame class for this editor view or editor sub-view
    /// </summary>
    function GetFrameClass: TCustomFrameClass;
    /// <summary>
    /// Called when an instance of the specified frame class is created 
    /// </summary>
    procedure FrameCreated(AFrame: TCustomFrame);

    property CanCloneView: Boolean read GetCanCloneView;
    property Caption: string read GetCaption;
    property FrameClass: TCustomFrameClass read GetFrameClass;
    property Priority: Integer read GetPriority;
    property ViewIdentifier: string read GetViewIdentifier;
  end;
  {$IFDEF LINUX}
  {$NODEFINE INTACustomEditorSubView}
  {$ENDIF}

  /// <summary>
  /// Implement this interface in addition to the ancestor interface in order to obtain
  /// view-specific context when programatically via the SwitchToView() functions on
  /// IOTASourceEditor which take the extra AViewContext parameter 
  /// </summary>
  INTACustomEditorSubView190 = interface(INTACustomEditorSubView)
    ['{356C05A7-78C0-477F-B59A-017D1AC74B00}']
    /// <summary>
    /// If the custom editor view supports this interface, SetViewContext may be called right after Display()
    /// is called with a valid AContext. There may also be cases where Display() isn't called, which may mean that the
    /// view is already selected, and only the internal view context must be updated. It will only be called in
    /// response to a programatic call to IOTASourceEditor.SwitchToView(). It is up to the view to decide what to
    /// do if the AViewContext parameter is nil. This could mean that it was called via the
    /// IOTASourceEditor.SwitchToView() methods which don't take a view context. In general, a nil view context
    /// will merely display the same context as before or whatever the &quot;default&quot; context is.
    /// 
    /// NOTE: SelectViewContext will NOT be called when the view tab is selected by the user. In this case, Display()
    /// should merely show the previous context or whatever the &quot;default&quot; context for that view happens to be.
    /// </summary>
    procedure SetViewContext(const AContext: IInterface; const AViewObject: TObject; const AViewContext: TObject);
  end;

  TNTARecreateEditorViewFunction = function: INTACustomEditorView;

  IOTAEditorViewServices140 = interface(IInterface)
    ['{CCE8FBE0-E121-450C-9366-1AC6BFD6CF81}']
    /// <summary>
    /// Registers a custom editor view.  The RecreateEditorView function will be called
    /// when a saved desktop that is being loaded contains an instance of this editor
    /// view 
    /// </summary>
    procedure RegisterEditorView(const ViewIdentifier: string; RecreateEditorView: TNTARecreateEditorViewFunction);
    /// <summary>
    /// Unregisters a previously registered custom editor view 
    /// </summary>
    procedure UnregisterEditorView(const ViewIdentifier: string);
    /// <summary>
    /// Show the specified editor tab in the top most editor window.  If there is
    /// an existing tab that is already hosting the specified EditorView instance,
    /// then that tab will get focus.  If the specified EditorView is not found,
    /// then a new tab will be created to host the instance. 
    /// </summary>
    procedure ShowEditorView(const EditorView: INTACustomEditorView);
    /// <summary>
    /// Returns the INTAEditWindow that owns the specified EditorTab 
    /// </summary>
    function GetOwningEditWindow(const EditorTab: INTACustomEditorView): INTAEditWindow;

    /// <summary>
    /// Registers a custom editor sub view 
    /// </summary>
    function RegisterEditorSubView(const ACustomEditorView: INTACustomEditorSubView): Pointer;
    /// <summary>
    /// Unregisters a previously registered custom editor sub view 
    /// </summary>
    procedure UnregisterEditorSubView(AView: Pointer);
    /// <summary>
    /// The following are helper functions to convert an Editor Context to something more useful 
    /// </summary>
    function ContextToRootComponent(const AContext: IInterface; out ARootComponent: TComponent): Boolean;
    function ContextToDesigner(const AContext: IInterface; out ADesigner: IDesigner): Boolean;
    function ContextToFormEditor(const AContext: IInterface; out AFormEditor: IOTAFormEditor): Boolean;
    function ContextToModule(const AContext: IInterface; out AModule: IOTAModule): Boolean;
    function ContextToFormFilename(const AContext: IInterface; out AFilename: string): Boolean;
    function ContextToFilename(const AContext: IInterface; out AFilename: string): Boolean;
    function ContextResurrect(const AContext: IInterface): Boolean;
  end;

  IOTAEditorViewServices = interface(IOTAEditorViewServices140)
    ['{75FE2D18-622B-4198-A092-ADD1E91612BD}']
    /// <summary>
    /// Attempts to close the active view in the editor.  Note that the view may
    /// not actually close (for instance if the view contains a modified editor
    /// buffer and the user Cancels the &quot;Save changes&quot; confirmation dialog. 
    /// </summary>
    procedure CloseActiveEditorView;
    /// <summary>
    /// Attempts to close the specified view in the editor.  Note that the view
    /// may not actually close (for instance if the view sets &quot;Allowed&quot; to False
    /// in its INTACustomEditorView150.Close method 
    /// </summary>
    procedure CloseEditorView(const EditorView: INTACustomEditorView);
  end;

  INTAEditorViewServices = interface(IInterface)
    ['{29F85F0F-E210-4577-9F5D-2B6ED7C05398}']
    /// <summary>
    /// AddImages takes all the images from the given image list and adds them to
    /// the imagelist used by the editor for glyphs on the top editor tabs. The
    /// imagelist used by the editor is also used by the Project Manager. &quot;Ident&quot;
    /// is used to identify dynamically added images that may already exist in the
    /// imagelist. Since images cannot be safely deleted without causing incorrect
    /// glyphs to be used for all subsequent images, this allows an add-in to be
    /// unloaded then reloaded in the same IDE session and still acquire the same
    /// image index. The return value is the index in the editor image list of the
    /// first image in the source list 
    /// </summary>
    function AddImages(AImages: TCustomImageList; const Ident: string): Integer;
  end;
  {$IFDEF LINUX}
  {$NODEFINE INTAEditorViewServices}
  {$ENDIF}

  INTAToDoItem = interface(IUnknown)
    ['{094003D8-E7AA-11D2-AA99-00C04FA35CE8}']
    /// <summary>
    /// Implement this interface on items returned by a registered IOTAToDoManager.
    /// This interface is also returned by IOTAToDoServices.GetItem to allow read
    /// access to the IDE's To-Do List. 
    /// </summary>

    /// <summary>
    /// CanDelete returns true to enable &quot;Delete&quot; on the To-Do List's local menu when this item
    /// is selected. 
    /// </summary>
    function  CanDelete: Boolean;
    /// <summary>
    /// CanEdit returns true to enable &quot;Edit&quot; on the To-Do List's local menu when this item
    /// is selected. 
    /// </summary>
    function  CanEdit: Boolean;
    /// <summary>
    /// CanShow returns true to enable &quot;Open&quot; on the To-Do List's local menu when this item
    /// is selected. 
    /// </summary>
    function  CanShow: Boolean;
    /// <summary>
    /// Delete is called when the item has been selected for deletion by the user. 
    /// </summary>
    procedure Delete;
    /// <summary>
    /// DrawImage draws an image representing the item in the To-Do List window. 
    /// </summary>
    procedure DrawImage(const Canvas: TCanvas; const Rect: TRect);
    /// <summary>
    /// DoubleClicked indicates the user has double-clicked the item in the To-Do List window. 
    /// </summary>
    procedure DoubleClicked;
    procedure Edit;
    function  GetText: string;
    function  GetPriority: TOTAToDoPriority;
    function  GetCategory: string;
    function  GetChecked: Boolean;
    /// <summary>
    /// GetModuleName returns the string shown in the &quot;Module&quot; column of the To-Do List
    /// window. 
    /// </summary>
    function  GetModuleName: string;
    /// <summary>
    /// GetKind returns a unique string indicating the origin of the item. It is also used
    /// as the caption for submenu items of the &quot;Filter&quot; local menu. 
    /// </summary>
    function  GetKind: string;
    function  GetData: Integer;
    function  GetOwner: string;
    /// <summary>
    /// IsValid indicates when the item has been completely defined (when processing
    /// items in a separate thread). 
    /// </summary>
    function  IsValid: Boolean;
    procedure SetChecked(const Value: Boolean);
    /// <summary>
    /// Show is called to make the item's source visible; i.e., for an item culled
    /// from source code, Show opens the source file in the editor. 
    /// </summary>
    procedure Show;

    property  Checked: Boolean read GetChecked write SetChecked;
  end;
  {$IFDEF LINUX}
  {$NODEFINE INTAToDoItem}
  {$ENDIF}

  /// <summary>
  /// Implement IOTAToDoManager on a TInterfacedObject; register with IOTAToDoServices
  /// to add To-Do items to the list. The Manager is basically just a list of
  /// INTAToDoItem interfaces; INTAToDoItem methods will be called when the To-Do List
  /// needs to display information, paint the item's representation in the list,
  /// inquire about status of an item. Not all INTAToDoItems may be added to the IDE's
  /// list; if the user has requested not to see items with a given attribute
  /// (i.e., Checked or of a certain type), they will not be added to the displayed
  /// To-Do list. 
  /// </summary>
  IOTAToDoManager = interface(IUnknown)
    ['{3D4A0565-EB77-11D2-AA9A-00C04FA35CE8}']
    /// <summary>
    /// The Name property is used to uniquely identify To-Do Item managers. 
    /// </summary>
    function  GetName: string;
    procedure SetName(const AName: string);
    function  GetItem(Index: Integer): INTAToDoItem;
    function  GetItemCount: Integer;
    /// <summary>
    /// ProjectChanged is called when the active project has been changed. 
    /// </summary>
    procedure ProjectChanged;

    property  Name: string read GetName write SetName;
    property  ItemCount: Integer read GetItemCount;
    property  Items[Index: Integer]: INTAToDoItem read GetItem;
  end;

  IOTAToDoServices = interface(IUnknown)
    ['{F8FC00EF-E61A-11D2-AA99-00C04FA35CE8}']
    function  AddManager(AManager: IOTAToDoManager): Integer;
    function  AddNotifier(const ANotifier: IOTANotifier): Integer;
    /// <summary>
    /// GetItem returns an item in the To-Do list, including those belonging to add-in
    /// managers. 
    /// </summary>
    function  GetItem(Index: Integer): INTAToDoItem;
    /// <summary>
    /// Returns the total number of visible To-Do items in the To-Do List, including
    /// those belonging to add-in managers. 
    /// </summary>
    function  GetItemCount: Integer;
    procedure RemoveManager(Index: Integer);
    procedure RemoveNotifier(Index: Integer);
    /// <summary>
    /// UpdateList causes the To-Do List to collate all items provided by its managers.
    /// Note that it will force the To-Do List to call every registered manager to
    /// query the state of all its items. 
    /// </summary>
    procedure UpdateList;

    property ItemCount: Integer read GetItemCount;
    property Items[Index: Integer]: INTAToDoItem read GetItem;
  end;

  /// <summary>
  /// types and interfaces for code completion 
  /// </summary>
  TOTAInvokeType = (itAuto, itManual, itTimer);

  TOTACodeInsightType = (citNone, { don't invoke code insight }
                         citCodeInsight, { perform code completion }
                         citParameterCodeInsight, { perform parameter completion }
                         citBrowseCodeInsight, { browse code (CTRL + click) }
                         citHintCodeInsight); { pop up hints over idents in the editor }

  TOTASortOrder = (soAlpha, { sort the code completion list alphanumerically }
                   soScope); { sort the code completion list by scope }

  /// <summary>
  /// TOTAViewerSymbolFlags is used for color coding the class name of the ident 
  /// </summary>
  TOTAViewerSymbolFlags = (vsfUnknown,
                           vsfConstant,
                           vsfType,
                           vsfVariable,
                           vsfProcedure,
                           vsfFunction,
                           vsfUnit,
                           vsfLabel,
                           vsfProperty,
                           vsfConstructor,
                           vsfDestructor,
                           vsfInterface,
                           vsfEvent,
                           vsfParameter,
                           vsfLocalVar,
                           vsfReservedWord);
  /// <summary>
  /// TOTAViewerVisibilityFlags 
  /// </summary>
  TOTAViewerVisibilityFlags = Integer;

  /// <summary>
  /// TOTAProcDispatchFlags for future use 
  /// </summary>
  TOTAProcDispatchFlags = (pdfNone,
                           pdfVirtual,
                           pdfDynamic);

  IOTACodeInsightSymbolList = interface(IUnknown)
    ['{4CA1CDFD-BD9A-4628-94AE-9BF3EB2DA22E}']
    /// <summary>
    /// Implementor should clear its symbol list 
    /// </summary>
    procedure Clear;
    /// <summary>
    /// returns the count of the symbols in the list - may be modified by setting a filter - 
    /// </summary>
    function GetCount: Integer;
    /// <summary>
    /// returns whether the symbol is able to be read from and written to 
    /// </summary>
    function GetSymbolIsReadWrite(I: Integer): Boolean;
    /// <summary>
    /// returns whether the symbols is abstract.  Viewer draws these in the 'need to implement' color 
    /// </summary>
    function GetSymbolIsAbstract(I: Integer): Boolean;
    /// <summary>
    /// return the symbol flags for the item at index 'I'.  I is the index in the filtered list 
    /// </summary>
    function GetViewerSymbolFlags(I: Integer): TOTAViewerSymbolFlags;
    /// <summary>
    /// return the visibility flags for the item at index 'I'.  I is the index in the filtered list 
    /// </summary>
    function GetViewerVisibilityFlags(I: Integer): TOTAViewerVisibilityFlags;
    /// <summary>
    /// return the procedure flags for the item at index 'I'.  I is the index in the filtered list 
    /// </summary>
    function GetProcDispatchFlags(I: Integer): TOTAProcDispatchFlags;
    /// <summary>
    /// The list was requested to be sorted by 'Value' 
    /// </summary>
    procedure SetSortOrder(const Value: TOTASortOrder);
    /// <summary>
    /// returns the sort order of the list 
    /// </summary>
    function GetSortOrder: TOTASortOrder;
    /// <summary>
    /// given an identifier, return the index of the closest partial match 
    /// </summary>
    function FindIdent(const AnIdent: string): Integer;
    /// <summary>
    /// given an identifier, find the 'Index' of an exact match in the list and return True.  Otherwise return False 
    /// </summary>
    function FindSymIndex(const Ident: string; var Index: Integer): Boolean;
    /// <summary>
    /// set the lists filter to 'FilterText'.  It is up to the implementor to determine how to filter or if they even want to filter 
    /// </summary>
    procedure SetFilter(const FilterText: string);
    /// <summary>
    /// return the symbol text for item 'Index'.  i.e. Form1 
    /// </summary>
    function GetSymbolText(Index: Integer): string;
    /// <summary>
    /// return the symbol type text for item 'Index'.  i.e. TForm1 
    /// </summary>
    function GetSymbolTypeText(Index: Integer): string;
    /// <summary>
    /// return the symbol class text for item 'Index'.  i.e. 'var', 'function', 'type', etc 
    /// </summary>
    function GetSymbolClassText(I: Integer): string;

    property SymbolClassText[I: Integer]: string read GetSymbolClassText;
    property SymbolTypeText[I: Integer]: string read GetSymbolTypeText;
    property SymbolText[I: Integer]: string read GetSymbolText;
    property SymbolFlags[I: Integer]: TOTAViewerSymbolFlags read GetViewerSymbolFlags;
    property SymbolVisibility[I: Integer]: TOTAViewerVisibilityFlags read GetViewerVisibilityFlags;
    property SymbolIsAbstract[I: Integer]: Boolean read GetSymbolIsAbstract;
    property SymbolIsReadWrite[I: Integer]: Boolean read GetSymbolIsReadWrite;
    property FuncDispatchFlags[I: Integer]: TOTAProcDispatchFlags read GetProcDispatchFlags;
    property SortOrder: TOTASortOrder read GetSortOrder write SetSortOrder;
    property Count: Integer read GetCount;
  end;

  IOTACodeInsightSymbolList80 = interface(IOTACodeInsightSymbolList)
    ['{9D76DD60-0D5A-405B-9695-C1F13092898E}']
    /// <summary>
    /// Return documentation for the symbol, in HTML 
    /// </summary>
    function GetSymbolDocumentation(I: Integer): string;

    property SymbolDocumentation[I: Integer]: string read GetSymbolDocumentation;
  end;

  IOTACodeInsightCustomParameterHighlight = interface(IUnknown)
    ['{A75D8C18-14D7-465F-8CCB-EB1B1F62B4B3}']
    /// <summary>
    /// Returns a specific syntax code (atIdentifier, atComment, etc.) to be used for
    /// highlighting the parameter list. Return -1 to use the default syntax highlighting
    /// for parameters. 
    /// </summary>
    function GetParamTextSyntaxCode(I: Integer): Integer;

    property ParamTextSyntaxCode[I: Integer]: Integer read GetParamTextSyntaxCode;
  end;

  IOTACodeInsightParamQuery = interface(IUnknown)
    ['{B1842926-C7F7-4869-B55A-CFDB6BF705B5}']
    /// <summary>
    /// returns the count of the parameters 
    /// </summary>
    function GetQueryParamCount: Integer;
    /// <summary>
    /// returns a string representing the return value of the method/proc 
    /// </summary>
    function GetQueryRetVal: string;
    /// <summary>
    /// returns the symbol text of the parameter at 'Index' 
    /// </summary>
    function GetQueryParamSymText(Index: Integer): string;
    /// <summary>
    /// returns the symbol type text of the parameter at 'Index' 
    /// </summary>
    function GetQueryParamTypeText(Index: Integer): string;
    /// <summary>
    /// returns whether the symbol at index 'Index' as a default value 
    /// </summary>
    function GetQueryParamHasDefaultVal(Index: Integer): Boolean;
    /// <summary>
    /// returns a string representing the type of invocation for the parameter at 'Index'. i.e. 'var', 'out', 'const' 
    /// </summary>
    function GetQueryParamInvokeTypeText(Index: Integer): string;

    property RetValType: string read GetQueryRetVal;
    property ParamSymText[Index: Integer]: string read GetQueryParamSymText;
    property ParamTypeText[Index: Integer]: string read GetQueryParamTypeText;
    property ParamCount: Integer read GetQueryParamCount;
    property ParamHasDefaultVal[Index: Integer]: Boolean read GetQueryParamHasDefaultVal;
    property ParamInvokeTypeText[Index: Integer]: string read GetQueryParamInvokeTypeText;
  end;

  IOTACodeInsightParameterList = interface(IUnknown)
    ['{99B6A644-3E97-48A1-9758-0A5FE94767C7}']
    /// <summary>
    /// 
    /// returns a ParamQuery to the caller based upon the ProcIndex.  There may be multiple
    /// items in list as we may be dealing with overloaded functions.
    ///     
    /// </summary>
    procedure GetParameterQuery(ProcIndex: Integer; out ParamQuery: IOTACodeInsightParamQuery);
    /// <summary>
    /// 
    /// return which character to use to delimit parameters in the parameter hint window.
    /// i.e.  Delphi uses ';'
    ///       C++ uses ','
    ///     
    /// </summary>
    function GetParamDelimiter: Char;
    /// <summary>
    /// returns the count of procedures in the list 
    /// </summary>
    function GetProcedureCount: Integer;
    /// <summary>
    /// 
    /// returns the parameters as a string from the procedure at index I.  The parameters
    /// should be delimited by a line ending (sLineBreak for instance).
    ///     
    /// </summary>
    function GetProcedureParamsText(I: Integer): string;

    property ProcedureParamsText[I: Integer]: string read GetProcedureParamsText;
    property ProcedureCount: Integer read GetProcedureCount;
    property ParamDelimiter: Char read GetParamDelimiter;
  end;

  IOTACodeInsightParameterList100 = interface(IOTACodeInsightParameterList)
    ['{EC7B37F6-8AB8-4B09-85A4-AA53D5856C0F}']
    function GetParmPos(Index: Integer): TOTACharPos;
    function GetParmCount: Integer;
    function GetParmName(Index: Integer): string;
    function GetParmHint(Index: Integer): string;
    function GetCallStartPos: TOTACharPos;
    function GetCallEndPos: TOTACharPos;

    property CallStartPos: TOTACharPos read GetCallStartPos;
    property CallEndPos: TOTACharPos read GetCallEndPos;
    property ParmCount: Integer read GetParmCount;
    property ParmHint[Index: Integer]: string read GetParmHint;
    property ParmName[Index: Integer]: string read GetParmName;
    property ParmPos[Index: Integer]: TOTACharPos read GetParmPos;
  end;

  IOTACodeInsightManager100 = interface(IUnknown)
    ['{BA5B444A-6E78-4A79-BF05-E184C1132B30}']
    /// <summary>
    /// returns a description of the language which we handle
    /// </summary>
    function GetName: string;
    /// <summary>
    /// returns a unique IDString to the services module
    ///  </summary>
    function GetIDString: string;
    /// <summary>
    /// returns whether we should be able to be invoked or not
    ///  </summary>
    function GetEnabled: Boolean;
    ///  <summary>
    /// sets the active state to Value so this manager may be turned off
    ///  </summary>
    procedure SetEnabled(Value: Boolean);
    /// <summary>
    ///  returns a charset used to get the token at the current editor position.  This is
    ///  used for retrieving the seed text when code completion is invoked as well as
    ///  retrieving the token from the editor when we are typing for look ahead.
    ///  The PreValidating parameter should be used to add special tokens to the charset for retrieval
    ///  from the editor.  For instance, C++ might add ['.', '-', '>'] to the returned charset
    ///  when it is prevalidating.
    /// </summary>
    function EditorTokenValidChars(PreValidating: Boolean): TSysCharSet;
    /// <summary>
    ///  the implementor should set Allow to True if it wishes to be invoked for the key 'Key'.
    ///  'Key' is the key which the user pressed to invoke code completion.
    ///  There are four special values to 'Key' when invoked by the code insight timer.
    ///
    ///  They are as follows:
    ///    #0 : Code completion was requested.
    ///    #1 : Parameter insight was requested.
    ///    #2 : A browse was requested.
    ///    #3 : a symbol hint was requested.
    /// </summary>
    procedure AllowCodeInsight(var Allow: Boolean; const Key: Char);
    /// <summary>
    ///  the implementor should return true if it wishes to allow the token 'str' to be
    ///  a valid code point for Code Insight.
    /// </summary>
    function PreValidateCodeInsight(const Str: string): Boolean;
    /// <summary>
    /// returns whether the symbol at index 'Index' as browseable in the Code completion viewer
    ///  </summary>
    function IsViewerBrowsable(Index: Integer): Boolean;
    /// <summary>
    /// returns whether the code completion viewer allows multi-select
    ///  </summary>
    function GetMultiSelect: Boolean;
    /// <summary>
    /// returns the symbol list to the caller
    ///  </summary>
    procedure GetSymbolList(out SymbolList: IOTACodeInsightSymbolList);
    /// <summary>
    ///  determines whether or not the key 'Key' which was entered into the editor should close
    ///  the code completion viewer or not (set CloseViewer to True or False depending on your choice).
    ///  Also, the implementor should inform the manager whether or not it should accept the symbol
    ///  at the currently selected index/indices.
    /// </summary>
    procedure OnEditorKey(Key: Char; var CloseViewer: Boolean; var Accept: Boolean);
    /// <summary>
    /// returns true if this manager should handle this file
    ///  </summary>
    function HandlesFile(const AFileName: string): Boolean;
    /// <summary>
    /// returns the longest symbol class text for measurement for the viewer.  i.e.  'constructor' is longer than 'var'
    ///  </summary>
    function GetLongestItem: string;
    /// <summary>
    /// returns a parameter list to the manager
    ///  </summary>
    procedure GetParameterList(out ParameterList: IOTACodeInsightParameterList);
    /// <summary>
    ///  given key 'AChar' which was entered into the editor and the current element (atComment, atIdentifier, etc),
    ///  return how code insight should be invoked and which type of invocation it should be.
    ///
    ///  As an example, GetCodeInsightType() might be implemented something like this:
    ///  ...
    ///  begin
    ///    InvokeType := itManual;
    ///    if not ((AElement = atString) and (AChar <> #1)) and not (AElement = atComment) then
    ///    begin
    ///      case AChar of
    ///        #0: CodeInsightType := citCodeInsight;
    ///        #1: CodeInsightType := citParameterCodeInsight;
    ///        #2: CodeInsightType := citBrowseCodeInsight;
    ///        #3: CodeInsightType := citHintCodeInsight;
    ///        '.':
    ///        begin
    ///          CodeInsightType := citCodeInsight;
    ///          InvokeType := itTimer;
    ///        end;
    ///        '(':
    ///        begin
    ///          CodeInsightType := citParameterCodeInsight;
    ///          InvokeType := itTimer;
    ///        end;
    ///      end;
    ///    end
    ///    else
    ///      CodeInsightType := citNone;
    ///  end;
    /// </summary>
    procedure GetCodeInsightType(AChar: Char; AElement: Integer; out CodeInsightType: TOTACodeInsightType;
      out InvokeType: TOTAInvokeType);
    /// <summary>
    ///  returns true if invocation was successful.  HowInvoked informs the implementor whether
    ///  it was invoked via timer, manual, etc...  Str is the text to seed to viewer with and
    ///  is used for the initial filtering in the viewer.
    /// </summary>
    function InvokeCodeCompletion(HowInvoked: TOTAInvokeType; var Str: string): Boolean;
    /// <summary>
    ///  returns true if invocation was successful.  HowInvoked informs the implementor whether
    ///  it was invoked via timer, manual, etc...  SelectedIndex is the index of the current parameter
    ///  for the method/proc.
    /// </summary>
    function InvokeParameterCodeInsight(HowInvoked: TOTAInvokeType; var SelectedIndex: Integer): Boolean;
    /// <summary>
    ///  tells the manager where it should anchor the parameter hint window.
    ///  A default value (EdPos) is provided for the implementor to change if they so wish.
    /// </summary>
    procedure ParameterCodeInsightAnchorPos(var EdPos: TOTAEditPos);
    /// <summary>
    ///  returns the index of the parameter which should be highlighted based upon EdPos.
    ///  This is used to reduce extra codeinsight invocations as an implementor might
    ///  store off the editor positions of parameters on the first invocation.
    ///  return a -1 if you want to be reinvoked.
    /// </summary>
    function ParameterCodeInsightParamIndex(EdPos: TOTAEditPos): Integer;
    /// <summary>
    /// return the hint string for the position in the editor (HintLine/HintCol are the editor coordinates)
    ///  </summary>
    function GetHintText(HintLine, HintCol: Integer): string;
    /// <summary>
    ///  return a FileName and LineNumber for the symbol which is requested to be browsed to.
    ///  if Index > -1 then it is an index into the symbol list and the browse was requested
    ///  by a user clicking in the code completion viewer.
    ///  return false if you'd like to inform the user that the requested operation failed otherwise return true.
    ///  if you wish to fail by not informing the user, set AFileName = '' and ALineNum = 0.
    ///  if Index is -1, you should use the global CodeInsightServices() and request the EditView from it.
    ///  This should be able to give you any information you require.
    /// </summary>
    function GotoDefinition(out AFileName: string; out ALineNum: Integer; Index: Integer = -1): Boolean;
    /// <summary>
    ///  called when the code completion is completed.  Accepted is true if the user has requested
    ///  the item hinted to them in the viewer otherwise Accepted is false.
    ///  DisplayParams should be set to true if the implementor would like to be requeried
    ///  for parameter invocation.  It is up to the implementor to insert the text into the editor.
    ///  One way might be to use CodeInsightServices.InsertText(StrToInsert, ShouldReplace);
    ///  Another might be to acquire the EditView from CodeInsightServices.GetEditView() and do
    ///  the insertion yourself.
    /// </summary>
    procedure Done(Accepted: Boolean; out DisplayParams: Boolean);

    property Name: string read GetName;
    property MultiSelect: Boolean read GetMultiSelect;
    property Enabled: Boolean read GetEnabled write SetEnabled;
  end;

  /// <summary>
  /// IOTACodeInsightManagerEnvOptions is used to hide UI elements in
  /// the Code Insight environment options page.
  /// </summary>
  IOTACodeInsightManagerEnvOptions = interface(IUnknown)
    ['{5ED252A8-813F-4963-816C-2FF140199F7E}']
    function IsEnableErrorInsightVisible: Boolean;
    function IsCodeCompleteAutoParensVisible: Boolean;
    function IsCodeCompleteAutoInvokeVisible: Boolean;
    function IsCodeCompleteHistoryVisible: Boolean;
    function IsCodeCompleteShowReservedWordsVisible: Boolean;
    function IsCodeParametersVisible: Boolean;
    function IsEvalHintsVisible: Boolean;
    function IsDeclInfoVisible: Boolean;
    function IsToolTipHelpInsightVisible: Boolean;
    function IsEnableAutoCompletionVisible: Boolean;
    function IsBlockWrapStyleVisible: Boolean;
    function GetCodeInsightUIName: string;
    /// <summary>
    /// Retrieves help insight information for the current Viewer's
    /// selected item. Return an empty string if none is to be shown or
    /// is available.
    /// </summary>
    procedure ManagerDisabled;
    ///  <summary>
    ///  Called when a user selects this insight manager as the default
    ///  manager for a language. No action is required.
    ///  </summary>
    procedure ManagerEnabled;

    property CodeInsightUIName: string read GetCodeInsightUIName;
  end;

  /// <summary>
  /// IOTACodeInsightManagerEnvOptions is used to hide UI elements in
  /// the Code Insight environment options page.
  /// </summary>
  IOTACodeInsightManagerEnvOptions270 = interface(IUnknown)
    ['{5E593875-DB7F-43AC-BD6F-C29CF8C31FB7}']
    function IsGenerateVSCodeInfo: Boolean;
  end;


  /// <summary>
  /// Used for the new Code Insight Preview feature. To be implemented by a module,
  /// and queried for by Code Insight. Duplicated in ToolsAPI.cs. If you change it
  /// here, you MUST change it in ToolsAPI.cs
  /// </summary>
  IOTACodeBrowsePreview = interface(IDispatch)
    ['{929C8812-4DB1-4338-B3B8-C1BE7969E2BF}']
    function GetCodePreviewInfo(SourceLine: Integer; SourceCol: Integer;
      out FileName: WideString; out Offset: Integer; out Length: Integer): WordBool; safecall;
  end;

  IOTACodeInsightManager90 = interface(IOTACodeInsightManager100)
    ['{3408E3C3-B6C1-4B02-8C5C-FD54D71A082F}']
    /// <summary>
    /// Retrieves help insight information for the current Viewer's
    /// selected item. Return an empty string if none is to be shown or
    /// is available.
    /// </summary>
    function GetHelpInsightHtml: WideString;
  end;

  IOTACodeInsightManager = interface(IOTACodeInsightManager100)
    ['{013F5F71-C500-44C8-904C-554F98C2EC28}']
    function GetOptionSetName: string;
  end;

  /// <summary>
  ///
  /// TOTACodeCompletionContext
  ///
  /// Primary code completion managers use this to let non-primary managers
  /// filter their data according to the invocation context.
  /// </summary>
  TOTACodeCompletionContext = (ccNone,
                               ccError,
                               ccMember,
                               ccArgument,
                               ccDecl,
                               ccTypeDecl,
                               ccExpr,
                               ccStatement,
                               ccConstExpr,
                               ccProcDecl,
                               ccMemberDecl,
                               ccNamespace,
                               ccComment,
                               ccStringLiteral,
                               // top level
                               ccDocument,
                               // in an element
                               ccElement,
                               // in an attribute
                               ccAttribute,
                               // all contexts
                               ccAny);

  /// <summary>
  ///
  /// IOTAPrimaryCodeInsightManager
  ///
  /// Tells code insight services that the manager which implements this
  /// is a primary manager.  This means that alternate managers
  /// may query the 'currentmanager' from the services to get
  /// invocation context information.
  /// </summary>
  IOTAPrimaryCodeInsightManager = interface(IDispatch)
    ['{E935146E-B88C-4E4F-9FAC-69973952D534}']
    function GetContext: TOTACodeCompletionContext;
    property Context: TOTACodeCompletionContext read GetContext;
  end;

  IOTACodeInsightViewer90 = interface(IUnknown)
    ['{AAA55FAC-350E-4F43-9C42-4FC28B6BFE33}']
    /// <summary>
    /// returns whether the item at index 'Index' is selected in the viewer 
    /// </summary>
    function GetSelected(Index: Integer): Boolean;
    /// <summary>
    /// returns the count of the items in the viewer 
    /// </summary>
    function GetItemCount: Integer;
    /// <summary>
    /// returns the selected string.  Is useful when implementing IOTACodeInsightManager.Done() 
    /// </summary>
    function GetSelectedString: string;
    /// <summary>
    /// returns the index of the selected item 
    /// </summary>
    function GetSelectedIndex: Integer; deprecated;
    /// <summary>
    /// 
    /// returns the key which was used to close the viewer.  An implementation
    /// of IOTACodeInsightManager.Done() might use this to determine whether it should be inserted
    /// into the completed text or not.  For instance, a user might accept an identifier in the
    /// list by typing a ';'.  The comma would be the 'closekey' and the implementor of
    /// IOTACodeInsightManager.Done() might want to insert the identifier selected as well
    /// as the ';'.
    ///     
    /// </summary>
    function GetCloseKey: Char;
    /// <summary>
    /// returns whether the selection in the viewer is valid 
    /// </summary>
    function GetIsValidSelection: Boolean; deprecated;
    property Selected[Index: Integer]: Boolean read GetSelected;
    property ItemCount: Integer read GetItemCount;
    property SelectedString: string read GetSelectedString;
    property SelectedIndex: Integer read GetSelectedIndex;
    property CloseKey: Char read GetCloseKey;
    property IsValidSelection: Boolean read GetIsValidSelection;
  end;

  IOTACodeInsightViewer = interface(IOTACodeInsightViewer90)
    ['{6268E073-D469-41BB-84C5-D96A34EA3D17}']
    function GetManagerIsValidSelection(const Mgr: IOTACodeInsightManager): Boolean; overload;
    function GetManagerIsValidSelection(const Mgr: IOTACodeInsightManager; Index: Integer): Boolean; overload;
    function GetManagerSelectedIndex(const Mgr: IOTACodeInsightManager): Integer;
  end;

  /// <summary>
  /// 
  /// An IOTACodeInsightManager should implement this interface if it would like to
  /// do custom drawing in the viewer.
  ///   
  /// </summary>
  INTACustomDrawCodeInsightViewer = interface(IUnknown)
    ['{32CA7B43-9AFC-49CF-ABC9-7ECD772488D9}']
    /// <summary>
    /// 
    /// called when the viewer draws the item at index 'Index'.  if DoDraw is false,
    /// then only a rectangle calculation is being requested.  The rectangle should
    /// be returned by the 'Rect' out parameter.
    ///     
    /// </summary>
    procedure DrawLine(Index: Integer; Canvas: TCanvas; var Rect: TRect;
      DrawingHintText: Boolean; DoDraw: Boolean; var DefaultDraw: Boolean);
  end;
  {$IFDEF LINUX}
  {$NODEFINE INTACustomDrawCodeInsightViewer}
  {$ENDIF}

  /// <summary>
  /// may be queried by using (BorlandIDEServices as IOTACodeInsightServices). 
  /// </summary>
  IOTACodeInsightServices60 = interface(IUnknown)
    ['{476904F8-89A9-4CD8-A71E-164660659763}']
    /// <summary>
    /// returns the current edit view to work with 
    /// </summary>
    procedure GetEditView(out EditView: IOTAEditView);
    /// <summary>
    /// returns the viewer interface to be queried by code completion implementors 
    /// </summary>
    procedure GetViewer(out Viewer: IOTACodeInsightViewer);
    /// <summary>
    /// returns the current code completion manager 
    /// </summary>
    procedure GetCurrentCodeInsightManager(out CodeInsightManager: IOTACodeInsightManager);
    /// <summary>
    /// cancel the invocation requested from the current IOTACodeInsightManager 
    /// </summary>
    procedure CancelCodeInsightProcessing;
    /// <summary>
    /// registers a new code insight manager and returns its index 
    /// </summary>
    function AddCodeInsightManager(const ACodeInsightManager: IOTACodeInsightManager): Integer;
    /// <summary>
    /// unregister the manager at index 'Index' 
    /// </summary>
    procedure RemoveCodeInsightManager(Index: Integer);
    /// <summary>
    /// inserts 'Str' into the editor optionally replacing the token which the editor is currently on 
    /// </summary>
    procedure InsertText(const Str: string; Replace: Boolean);
    /// <summary>
    /// returns the count of installed code insight managers 
    /// </summary>
    function GetCodeInsightManagerCount: Integer;
    /// <summary>
    /// returns the code insight manager at index 'Index' 
    /// </summary>
    function GetCodeInsightManager(Index: Integer): IOTACodeInsightManager;
    property CodeInsightManagerCount: Integer read GetCodeInsightManagerCount;
    property CodeInsightManager[Index: Integer]: IOTACodeInsightManager read GetCodeInsightManager;
  end;

  IOTACodeInsightServices270 = interface(IOTACodeInsightServices60)
    ['{EE5C42A9-DBC8-4C5D-B28E-528024CBC97C}']
    /// <summary>
    /// 
    /// sets the EditView and CurrentCIManager for operations with CI.  The
    /// Viewer/Hints are disabled while an EditView and/or a CodeInsightManager
    /// have been set via this procedure.  SetQueryContext must be called with
    /// parameters of nil for CodeInsightServices to be returned to its initial state.
    ///     
    /// </summary>
    procedure SetQueryContext(const EditView: IOTAEditView;
      const CodeInsightManager: IOTACodeInsightManager);
  end;

  IOTACodeInsightServices = interface(IOTACodeInsightServices270)
    ['{FD980885-AF2D-4D29-8EFB-2EAE52C37596}']
    /// <summary> This can be called if the IOTACOdeInsightSelect is also
    ///  implemented to determine if the file can be handled.
    ///  An example:
    ///  Result := (BorlandIDEServices as IOTACodeInsightServices).
    ///    HandlesFile(AFileName, GetIDString);
    ///</summary>
    function HandlesFile(const AFileName, AIDString: string): Boolean;
  end;

  IOTACodeInsightSelection = interface
    ['{48AFA25C-BFDD-408F-B81B-6BDFDA0ABB1C}']
    /// <summary> Return the string that will be shown in the "Tools|Options|
    ///  Editor|Source|Insight Provider" combobox. This should be a
    ///  resourcestring if you wish to have translated versions.
    ///</summary>
    function GetDisplayName: string;
    /// <summary> Use the same function as in IOTACodeInsightManager. This
    ///  is declared for convenience. </summary>
    function GetIDString: string;
    property DisplayName: string read GetDisplayName;
    property IDString: string read GetIDString;
  end;

  INTAIDEInsightItem270 = interface
    ['{E8508251-803C-4EC6-BD7D-D67131532A15}']
    /// <summary>
    ///  Provides a canvas on which to custom draw the item's text and specify its
    ///    width.
    ///  Return value: Width of the text that is to be drawn. If this value is not
    ///    accurate clipping may occur.
    ///  Canvas: The canvas on which to draw.
    ///  Rect: The visible area in which to draw. The return value of this function
    ///    may be larger than Rect's width indicating a horizontal scrollbar is necessary.
    ///  DrawDefault: Indicates whether the item is to be drawn in the default manner
    ///    by the IDE or is custom drawn.
    ///  DoDraw: If false, the return value is being requested for measurement purposes
    ///    only, to determine hint or scrollbar parameters.
    /// </summary>
    function DrawText(Canvas: TCanvas; Rect: TRect; var DrawDefault: Boolean;
      DoDraw: Boolean = True): Integer;
    /// <summary>
    ///  Called when this item has been selected and the dialog accepted
    /// </summary>
    procedure Execute;
    /// <summary>
    ///  Return a description of the item. Default drawing de-emphasises this
    ///    text, since by default it is not searchable
    /// </summary>
    function GetDescription: string;
    /// <summary>
    ///  Returns whether or not the item's description should be included when
    ///    determining a match
    /// </summary>
    function GetDescriptionSearchable: Boolean;
    /// <summary>
    ///  Provide a custom glyph. This TBitmap is owned by the IDE and
    ///    should be drawn on but not be assigned to. Return false if no glyph is
    ///    to be drawn.
    /// </summary>
    function GetGlyph(Bitmap: TBitmap): Boolean;
    /// <summary>
    ///  Determines ownership and lifetime of this item. If true, the IDE assumes
    ///    ownership of the item and it will persist throughout the current IDE
    ///    session, and should only to be added to the list once. If false, the
    ///    item must be added to the list on each request and will be released
    ///    when the dialog is closed.
    /// </summary>
    function GetSticky: Boolean;
    /// <summary>
    ///  The searchable title of the item
    /// </summary>
    function GetTitle: string;
    /// <summary>
    ///  Whether or not the item is visible (searchable) in the current IDE context.
    /// </summary>
    function GetVisible: Boolean;
    /// <summary>
    ///  Called just before the IDE insight dialog is populated. Update the item's
    ///    visibility state and other parameters if necessary.
    /// </summary>
    procedure Update;

    property Description: string read GetDescription;
    property IsDescriptionSearchable: Boolean read GetDescriptionSearchable;
    property Sticky: Boolean read GetSticky;
    property Title: string read GetTitle;
    property Visible: Boolean read GetVisible;
  end;

  INTAIDEInsightItem280 = interface(INTAIDEInsightItem270)
    ['{68DB38FE-F2AF-4E80-A51B-2474B5F4ACAA}']
    /// <summary>
    ///  Setting a custom multi-resolution glyph for the IDE Insight item
    /// </summary>
    function SetGlyph(const AImageName: string; const AGlyph: TGraphicArray): Boolean;
  end;

  /// <summary>
  ///  Represents a searchable item in the IDE Insight dialog }
  /// </summary>
  INTAIDEInsightItem = interface(INTAIDEInsightItem280)
    ['{539EE5EB-7A17-4756-9E98-09EE71551AE0}']
  end;

  INTAIDEInsightItemArray = array of INTAIDEInsightItem;

  /// <summary>
  /// Represents a category in the IDE Insight dialog 
  /// </summary>
  IOTAIDEInsightCategory = interface
    ['{D943D3FE-BC3F-4405-BF2A-4F9F001AD19E}']
    /// <summary>
    /// Removes all items from the category regardless of persistent (Sticky) state 
    /// </summary>
    procedure ClearItems;
    /// <summary>
    /// Return the display name of the category, e.g., &quot;Commands&quot;, &quot;Files&quot;, etc. 
    /// </summary>
    function GetCaption: string;
    /// <summary>
    /// Whether or not the category is enabled for searching and display 
    /// </summary>
    function GetDisabled: Boolean;
    /// <summary>
    /// Returns an item in this category 
    /// </summary>
    function GetItem(const Index: Integer): INTAIDEInsightItem;
    /// <summary>
    /// The number of items in the category 
    /// </summary>
    function ItemCount: Integer;
    /// <summary>
    /// Disables the category. Disabled categories will not show in the dialog
    /// and will not be searched for matching items. 
    /// </summary>
    procedure SetDisabled(Value: Boolean);

    property Caption: string read GetCaption;
    property Disabled: Boolean read GetDisabled write SetDisabled;
    property Items[const Index: Integer]: INTAIDEInsightItem read GetItem;
  end;

  IOTAIDEInsightService = interface;
  /// <summary>
  /// Implement and register this interface with IOTAIDEInsightService to receive
  /// a notification when the IDE Insight dialog is invoked.
  /// e.g., (BorlandIDEServices as IOTAIDEInsightService).AddNotifier() 
  /// </summary>
  IOTAIDEInsightNotifier = interface
    ['{FDEC7D0D-9633-424A-A925-5DC1DE13FD48}']
    /// <summary>
    /// This notification is called when the IDE Insight dialog is being invoked and
    /// is requesting items for its list. Context parameter is null and reserved
    /// for future use. 
    /// </summary>
    procedure RequestingItems(IDEInsightService: IOTAIDEInsightService; Context: IInterface);
  end;

  IOTAIDEInsightNotifier150 = interface
    ['{6B051B2F-1EB6-41BC-AA94-DB9727A7702B}']
    /// <summary>
    /// Notify that IDEInsight is finished, if the callee needs to clean up this is
    /// the time 
    /// </summary>
    procedure ReleaseItems(Context: IInterface);
  end;

  /// <summary>
  /// Entry point into the IDE Insight system. 
  /// </summary>
  IOTAIDEInsightService = interface
    ['{D1258D2C-DE95-4A0A-9A7E-8C6167F48B31}']
    /// <summary>
    /// Adds an item into the specified category. If the category does not exist
    /// it will be created. If category is empty, the item will appear outside
    /// of the category list 
    /// </summary>
    procedure AddItem(Item: INTAIDEInsightItem; Category: string = '');
    /// <summary>
    /// Call this to register an IOTAIDEInsightNotifier. The result is the index to be
    /// used when calling RemoveNotifier. If &lt;0 then an error occurred. 
    /// </summary>
    function AddNotifier(Notifier: IOTAIDEInsightNotifier): Integer;
    /// <summary>
    /// The number of categories currently known by IDE Insight 
    /// </summary>
    function CategoryCount: Integer;
    /// <summary>
    /// Returns a category by display name or index 
    /// </summary>
    function GetCategory(const IndexOrName: Variant): IOTAIDEInsightCategory; overload;
    /// <summary>
    /// Returns a category by name and optionally creates it 
    /// </summary>
    function GetCategory(const Name: string; CanCreate: Boolean = False): IOTAIDEInsightCategory; overload;
    /// <summary>
    /// Invokes the IDE Insight dialog 
    /// </summary>
    procedure Invoke;
    /// <summary>
    /// Remove an Item from the list if it doesn't have a category 
    /// </summary>
    procedure RemoveItem(const Item: INTAIDEInsightItem);
    /// <summary>
    /// Remove a previously added notifier using the index returned by AddNotifier(). 
    /// </summary>
    procedure RemoveNotifier(const Index: Integer);

    property Categories[const IndexOrName: Variant]: IOTAIDEInsightCategory read GetCategory;
  end;

  INTAIDEInsightService180 = interface
    ['{6B0977D7-DE13-4715-AB0B-3791126CABE9}']
    /// <summary>
    /// Display all items in the action list in the IDE Insight window, prefixed
    /// with an optional Description.
    /// Items in the IDE Insight list will be shown as:
    ///   [Description |] Category | TCustomAction.Caption
    /// Contained actions which do not specify a category will not be shown. 
    /// </summary>
    function AddActionList(Actions: TCustomActionList; const Description: string = '';
      const Category: string = ''): Integer;
    procedure RemoveActionList(const Index: Integer);
  end;

  INTAIDEInsightService = interface(INTAIDEInsightService180)
    ['{1780CF98-614F-4BB9-A856-3D1D2EA05A57}']
    /// <summary>
    /// Returns the toolbar associated with the IDE Insight 
    /// </summary>
    function GetToolBar: TToolBar;
    /// <summary>
    /// Sets the toolbar associated with the IDE Insight 
    /// </summary>
    procedure SetToolBar(Value: TToolBar);
    /// <summary>
    /// Returns the edit control associated with the IDE Insight popup form 
    /// </summary>
    function GetEditSearchControl: TWinControl;
    /// <summary>
    /// Sets the edit control associated with the IDE Insight popup form 
    /// </summary>
    procedure SetEditSearchControl(Value: TWinControl);
    /// <summary>
    /// Executes the search in the IDE Insight, showing the popup form if there
    /// are results for the given string 
    /// </summary>
    procedure Filter(const FilterText: string);
    /// <summary>
    /// Hides the IDE Insight popup form 
    /// </summary>
    procedure HidePopup;
    /// <summary>
    /// Called when you want to make an special treatment for a key pressed inside
    /// the EditSearchControl 
    /// </summary>
    procedure DoKey(var Key: Word);

    property ToolBar: TToolBar read GetToolBar write SetToolBar;
    property EditSearchControl: TWinControl read GetEditSearchControl write SetEditSearchControl;
  end;

  {$IFDEF LINUX}
  {$NODEFINE INTAIDEInsightService}
  {$ENDIF}

  TOTAAffect = (afNothing, afTop, afLeft, afBottom, afRight, afHCenter, afVCenter,
    afHSpace, afVSpace, afHWinCenter, afVWinCenter, afHSpaceInc, afHSpaceDec,
    afHSpaceDel, afVSpaceInc, afVSpaceDec, afVSpaceDel, afAlignToGrid, afSnapToGrid,
    afSendToBack, afBringToFront);

  TOTASizeAffect = (asNothing, asHGrow, asHShrink, asHAbsolute, asVGrow, asVShrink,
    asVAbsolute, asWidths, asHeights, asWidthHeight, asSizeToGrid);

  TOTAAlignableState = set of (asEnabled, asChecked);

  IOTAAlignable = interface
    ['{346E7BA3-D47E-11D3-BA96-0080C78ADCDB}']
    procedure Align(Affect: TOTAAffect);
    procedure Size(Affect: TOTASizeAffect; Value: Integer);
  end;

  IOTAAlignableState = interface
    ['{481A90D6-95AD-4AC8-8C53-E862DF164BD7}']
    function GetAlignAffectState(Affect: TOTAAffect): TOTAAlignableState;
    function GetSizeAffectState(Affect: TOTASizeAffect): TOTAAlignableState;
  end;

  IOTAScaleable = interface
    ['{346E7BA6-D47E-11D3-BA96-0080C78ADCDB}']
    procedure Scale(Factor: Integer);
  end;

  IOTATabOrderable = interface
    ['{346E7BA4-D47E-11D3-BA96-0080C78ADCDB}']
    function GetTabCompCount: Integer;
    function GetTabCompInfo(Order: Integer; var Name, ClassName: string;
      var Comp: Pointer): Boolean;
    procedure SetTabCompOrder(Comp: Pointer; Order: Integer);
  end;

  IOTACreateOrderable = interface
    ['{346E7BA5-D47E-11D3-BA96-0080C78ADCDB}']
    function GetCompCount: Integer;
    function GetCompName(Index: Integer): string;
    function GetCompType(Index: Integer): string;
    function GetNVComp(Index: Integer): Pointer;
    procedure SetNVComp(Comp: Pointer; Order: Integer);
  end;

  /// <summary>
  /// Designers must implement this interface in order to make sure they can
  /// participate in the Edit menu designer commands 
  /// </summary>

  IOTADesignerCommandNotifier = interface(IOTANotifier)
    ['{F862787A-4FF5-4B91-B626-D9AD53EA98A6}']
    function GetActive: Boolean;
    function GetActiveDesignerType: string;
    function GetAlignable: IOTAAlignable;
    function IsCommandEnabled(const Command: string): Boolean;
    function IsCommandChecked(const Command: string): Boolean;
    function IsCommandVisible(const Command: string): Boolean;
    procedure DesignerCommand(const Command: string);

    property Active: Boolean read GetActive;
    property ActiveDesignerType: string read GetActiveDesignerType;
    property Alignable: IOTAAlignable read GetAlignable;
  end;

  IOTADesignerCommandServices = interface(IInterface)
    ['{C18D655E-54B1-412D-BECF-584B08838827}']
    /// <summary>
    /// Sets the currently activated designer to the given DesignerCommands
    /// interface so that the IDE can then use this interface to determine what
    /// stock edit menu items are enabled and where to send the responses to the
    /// commands 
    /// </summary>
    procedure ActivateDesignerCommands(const DesignerCommands: IOTADesignerCommandNotifier);
    /// <summary>
    /// Returns the currently active set of DesignerCommands 
    /// </summary>
    function GetActiveDesignerCommands: IOTADesignerCommandNotifier;
    /// <summary>
    /// Call EditAlign to use the internal IDE alignment dialog 
    /// </summary>
    procedure EditAlign(const Alignable: IOTAAlignable);
    /// <summary>
    /// Call EditSize to use the internal IDE size dialog. 
    /// </summary>
    procedure EditSize(const Sizeable: IOTAAlignable);
    /// <summary>
    /// Call EditScale to use the internal IDE scaling dialog 
    /// </summary>
    procedure EditScale(const Scalable: IOTAScaleable);
    /// <summary>
    /// Call EditTabOrder to use the internal IDE tab order dialog 
    /// </summary>
    procedure EditTabOrder(const TabOrderable: IOTATabOrderable);
    /// <summary>
    /// Call EditCreationOrder to use the internal IDE creation order dialog 
    /// </summary>
    procedure EditCreationOrder(const CreateOrderable: IOTACreateOrderable);

    property ActiveDesignerCommands: IOTADesignerCommandNotifier read GetActiveDesignerCommands;
  end;

  IOTAPersonalityServices100 = interface(IInterface)
    ['{F66FB6B3-24DC-4BC0-8A6B-4159B527A1FC}']
    function GetPersonalityCount: Integer;
    function GetPersonality(Index: Integer): string;
    function AddPersonality(const APersonality: string): Integer;
    procedure RemovePersonality(const APersonality: string);
    procedure AddPersonalityTrait(const APersonality: string; const ATraitGUID: TGUID; const ATrait: IInterface);
    procedure RemovePersonalityTrait(const APersonality: string; const ATraitGUID: TGUID);
    procedure AddFileType(const APersonality, AFileType: string);
    procedure RemoveFileType(const APersonality, AFileType: string);
    procedure AddFileExtensions(const APersonality, AFileType, AFileExtensions: string);
    procedure RemoveFileExtensions(const APersonality, AFileType, AFileExtensions: string);
    procedure AddFileTrait(const APersonality, AFileType: string; const ATraitGUID: TGUID; const ATrait: IInterface);
    procedure RemoveFileTrait(const APersonality, AFileType: string; const ATraitGUID: TGUID);
    function GetCurrentPersonality: string;
    procedure SetCurrentPersonality(const APersonality: string);
    function GetFileTrait(const APersonality, AFileName: string; const ATraitGUID: TGUID; SearchDefault: Boolean): IInterface; overload;
    function GetFileTrait(const AFileName: string; const ATraitGUID: TGUID; SearchDefault: Boolean): IInterface; overload;
    function GetFileTrait(const APersonality, AFileName: string; const ATraitGUID: TGUID): IInterface; overload;
    function GetFileTrait(const AFileName: string; const ATraitGUID: TGUID): IInterface; overload;
    function GetTrait(const APersonality: string; const ATraitGUID: TGUID): IInterface; overload;
    function GetTrait(const ATraitGUID: TGUID): IInterface; overload;
    function SupportsFileTrait(const APersonality, AFileName: string; const ATraitGUID: TGUID; SearchDefault: Boolean): Boolean; overload;
    function SupportsFileTrait(const AFileName: string; const ATraitGUID: TGUID; SearchDefault: Boolean): Boolean; overload;
    function SupportsFileTrait(const APersonality, AFileName: string; const ATraitGUID: TGUID): Boolean; overload;
    function SupportsFileTrait(const AFileName: string; const ATraitGUID: TGUID): Boolean; overload;
    function SupportsTrait(const APersonality: string; const ATraitGUID: TGUID): Boolean; overload;
    function SupportsTrait(const ATraitGUID: TGUID): Boolean; overload;
    // If there are more than one personalities that support this interface the user
    // will be asked to select one.  The select personality will be set to the active personality.
    function PromptUserForPersonality(const ATraitGUID: TGUID; const Prompt: string): Boolean;

    property CurrentPersonality: string read GetCurrentPersonality write SetCurrentPersonality;
    property PersonalityCount: Integer read GetPersonalityCount;
    property Personalities[Index: Integer]: string read GetPersonality;
  end;

  IOTAPersonalityServices140 = interface(IOTAPersonalityServices100)
    ['{92D70AB5-F54F-4432-8E0E-5BEEF4B3BE77}']
    function GetFilePersonality(const AFileName: string): string;
    function FindFileTrait(const AFileName: string; const ATraitGUID: TGUID): IInterface;
    function PersonalityExists(const APersonality: string): Boolean;
  end;

  IOTAPersonalityServices = interface(IOTAPersonalityServices140)
    ['{F6B15FD1-E9D6-4DCC-8ACD-06143F1F67BE}']
    function GetPersonalityId(const APersonality: string): Integer;
  end;

  INTAPersonalityDevelopers = interface(IInterface)
    ['{765E768E-CF71-427C-AC9C-CF4BFEBCFED5}']
    function GetDeveloperNames: TStrings;
    procedure NameHit(const Name: string; Point: TPoint; const Canvas: TCanvas);
    property DeveloperNames: TStrings read GetDeveloperNames;
  end;


  IBorlandIDEServices70 = interface(IInterface)
    ['{7FD1CE92-E053-11D1-AB0B-00C04FB16FB3}']
  end;

  IBorlandIDEServices = interface(IBorlandIDEServices70)
    ['{C9E8E577-B5D8-43F3-BC84-6A734A015732}']
    function SupportsService(const Service: TGUID): Boolean;
    function GetService(const Service: TGUID): IInterface; overload;
    function GetService(const Service: TGUID; out Svc): Boolean; overload;
  end;

  IOTASplashScreenServices270 = interface(IInterface)
    ['{41610E44-49EA-48DC-BC3E-2650345D4DA2}']
    /// <summary>
    /// Any IDE plugin may provide an image to be displayed on the splash screen
    /// as the product is initializing.  If AddPluginBitmap is called,
    /// AddProductBitmap should *NOT* be called or a duplicate entry will be
    /// displayed.  The bitmap should be 24x24 pixels with the lower-left pixel
    /// indicating the transparent color.  If IsUnRegistered is true, the
    /// caption will be painted red. LicenseStatus will be shown in parentheses
    /// after the caption. SKUName will be appended to the caption 
    /// </summary>
    procedure AddPluginBitmap(const ACaption: string; ABitmap: HBITMAP;
      AIsUnRegistered: Boolean = False; const ALicenseStatus: string = '';
      const ASKUName: string = ''); overload;
    /// <summary>
    /// A full product personality may call AddProductBitmap in order to display
    /// an image on the splash screen in the same manner as AddPluginBitmap.  If
    /// AddProductBitmap is called, AddPluginBitmap should *NOT* be called or a
    /// duplicate entry will be displayed.  The bitmap should be 24x24 pixels
    /// with the lower-left pixel indicating the transparent color.  If
    /// IsUnRegistered is true, the caption will be painted red. LicenseStatus
    /// will be shown in parentheses after the caption. SKUName will be appended 
    /// to the caption.
    /// NOTE: AddProductBitmap should only be used by personality addins.  All
    /// other addins should use AddPluginBitmap.  If you call AddProductInfo and
    /// the IDE is not running in multi-personality mode, your Product Info will
    /// not actually show up in the splash screen 
    /// </summary>
    procedure AddProductBitmap(const ACaption: string; ABitmap: HBITMAP;
      IsUnRegistered: Boolean = False; const ALicenseStatus: string = '';
      const ASKUName: string = ''); overload;
    /// <summary>
    /// If there is one and only one product personality installed into the IDE,
    /// the built-in splash screen will not be displayed.  Instead, the IDE will
    /// wait for the single personality to call ShowProductSplash in order to
    /// display that product's specific splash screen.  Even if there are multiple
    /// product personalities installed, each one should still call this method
    /// as it will be properly ignored if the IDE sees that more than one
    /// product personality is installed.  This keeps the product personalities
    /// from having to detect if they are the one and only one available. This
    /// bitmap should be 450x300 pixels. 
    /// </summary>
    procedure ShowProductSplash(ABitmap: HBITMAP);
    /// <summary>
    /// During product startup, the IDE and any add-in or personality may wish to
    /// display status info for the user.  Call StatusMesage to display this
    /// string with the splash screen. 
    /// </summary>
    procedure StatusMessage(const StatusMessage: string);
    /// <summary>
    /// A full product personality may call SetProductIcon in order to setup the
    /// product's icon that will be displayed on the application main form and
    /// the taskbar. If this is not called or there are multiple personalities
    /// installed, the default IDE icon is used. 
    /// </summary>
    procedure SetProductIcon(AIcon: HICON);
  end;

  /// <summary>
  ///  This interface provided support high DPI graphics
  /// </summary>
  IOTASplashScreenServices280 = interface(IOTASplashScreenServices270)
    ['{7B78F1BA-19C2-4A80-9FE2-6BF6E31604F6}']
    /// <summary>
    /// This overloaded version of AddPluginBitmap allows you to specify TGraphicArray
    /// as parameter for AImageArray instead of HBITMAP for AImage 
    /// </summary>
    procedure AddPluginBitmap(const Caption: string; const AImageArray: TGraphicArray;
      AIsUnRegistered: Boolean = False; const ALicenseStatus: string = '';
      const ASKUName: string = ''); overload;
    /// <summary>
    /// This overloaded version of AddProductBitmap allows you to specify TGraphicArray
    /// as parameter for AImageArray instead of HBITMAP for AImage 
    /// </summary>
    procedure AddProductBitmap(const Caption: string; const AImageArray: TGraphicArray;
      AIsUnRegistered: Boolean = False; const ALicenseStatus: string = '';
      const ASKUName: string = ''); overload;
  end;

  /// <summary>
  ///  The IOTASplashScreenServices is the first service available during product
  ///  startup, which is why it is available as a separate specific global variable.
  ///  When this interface is created, the BorlandIDEServices interface is
  ///  unavailable since it has yet to be initialized.
  /// </summary>
  IOTASplashScreenServices = interface(IOTASplashScreenServices280)
    ['{1A3CDFB0-EBF6-449D-88D4-3D2991F8974F}']
  end;

  /// <summary>
  /// IOTAAboutBoxServices 
  /// </summary>
  IOTAAboutBoxServices120 = interface(IInterface)
    ['{1DD6FC0B-32F9-4161-A81A-9BE214F9F30D}']
    /// <summary>
    /// Call AddPluginInfo to provide information specific to a particular plugin.
    /// The caller should save the returned index in order to later remove the
    /// plug-in info using RemovePluginInfo. Title is displayed in a listbox in
    /// which the user can select.  Description is displayed in a memo which
    /// should describe the plugin.  And the Image is displayed next to the
    /// Description when the title is selected.  The Image should follow the same
    /// size and rules as required for a plugin image in the splash screen.  See
    /// IOTASplashScreenServices.  If IsUnRegistered is true, the title will be
    /// painted red. LicenseStatus will be shown in a label when the title is
    /// selected. SKUName will also be shown in a label when the title is selected 
    /// </summary>
    function AddPluginInfo(const ATitle, ADescription: string; AImage: HBITMAP;
      AIsUnRegistered: Boolean = False; const ALicenseStatus: string = '';
      const ASKUName: string = ''): Integer; overload;
    /// <summary>
    /// AddProductInfo follows the same rules as AddPluginInfo, except for
    /// providing the About box Dialog title, copyright string and the extra
    /// about box graphic.  ACopyright should include both the product name,
    /// version, and copyright info.  This information is displayed at the top of
    /// the about box.  The Product image has the same rules as the image
    /// passed to AddPluginInfo. If IsUnRegistered is true, the title will be
    /// painted red. LicenseStatus will be shown in a label when the title is
    /// selected. SKUName will also be shown in a label when the title is selected.
    /// NOTE: AddProductInfo should only be used by personality addins.  All other
    /// addins should use AddPluginInfo.  If you call AddProductInfo and the IDE
    /// is not running in multi-personality mode, your Product Info will not
    /// actually show up in the About box 
    /// </summary>
    function AddProductInfo(const ADialogTitle, ACopyright, ATitle, ADescription: string;
      AAboutImage, AProductImage: HBITMAP; AIsUnRegistered: Boolean = False;
      const ALicenseStatus: string = ''; const ASKUName: string = ''): Integer; overload;
    /// <summary>
    /// When a plugin is unloaded, it should actively remove itself from the
    /// AboutBoxServices but specifying the index returned from AddPluginInfo 
    /// </summary>
    procedure RemovePluginInfo(Index: Integer);
    /// <summary>
    /// When a product personality is unloaded, it should actively remove itself
    /// from the AboutBoxServices but specifying the index returned from
    /// AddProductInfo 
    /// </summary>
    procedure RemoveProductInfo(Index: Integer);
  end;

  /// <summary>
  /// this corresponds to TAlphaFormat in Graphics.pas 
  /// </summary>
  TOTAAlphaFormat = (otaafIgnored, otaafDefined, otaafPremultiplied);

  IOTAAboutBoxServices270 = interface(IOTAAboutBoxServices120)
    ['{CD3BF221-2C93-4253-8A2F-901300DEE9DC}']
    /// <summary>
    /// This overloaded version of AddPluginInfo adds an additional parameter that
    /// allows you to specify the alphaformat associated with the &quot;AImage&quot; bitmap 
    /// </summary>
    function AddPluginInfo(const ATitle, ADescription: string; AImage: HBITMAP;
      AIsUnRegistered: Boolean = False; const ALicenseStatus: string = '';
      const ASKUName: string = ''; AAlphaFormat: TOTAAlphaFormat = otaafIgnored): Integer; overload;
    /// <summary>
    /// This overloaded version of AddProductInfo adds additional parameters that
    /// allow you to specify the alphaformat associated with the &quot;AAboutImage&quot; and
    /// &quot;AProdcutImage&quot; bitmaps 
    /// </summary>
    function AddProductInfo(const ADialogTitle, ACopyright, ATitle, ADescription: string;
      AAboutImage, AProductImage: HBITMAP; AIsUnRegistered: Boolean = False;
      const ALicenseStatus: string = ''; const ASKUName: string = '';
      AAboutImageAlphaFormat: TOTAAlphaFormat = otaafIgnored;
      AProductImageAlphaFormat: TOTAAlphaFormat = otaafIgnored): Integer; overload;
  end;

  IOTAAboutBoxServices280 = interface(IOTAAboutBoxServices270)
    ['{6A9745C8-05CD-40FA-B1F8-92AFA7C5ECEE}']
    /// <summary>
    /// This overloaded version of AddPluginInfo allows you to specify TGraphicArray
    /// to support multiple resolutions of the same image 
    /// </summary>
    function AddPluginInfo(const ATitle, ADescription: string;
      const AImage: TGraphicArray; AIsUnRegistered: Boolean = False;
      const ALicenseStatus: string = ''; const ASKUName: string = ''): Integer; overload;
    /// <summary>
    /// This overloaded version of AddProductInfo allows you to specify TGraphicArray
    /// to support multiple resolutions of the same image 
    /// </summary>
    function AddProductInfo(const ADialogTitle, ACopyright, ATitle,
      ADescription: string; AAboutImage: HBITMAP;
      const AProductImage: TGraphicArray; AIsUnRegistered: Boolean = False;
      const ALicenseStatus: string = ''; const ASKUName: string = '';
      AAboutImageAlphaFormat: TOTAAlphaFormat = otaafIgnored): Integer; overload;
  end;

  IOTAAboutBoxServices = interface(IOTAAboutBoxServices280)
    ['{62A2F7FD-16F1-45B9-9417-A2D293D07A22}']
  end;


  /// <summary>
  /// IOTAHistoryItem
  /// Implement this interface (and IOTANotifier) and call
  /// IOTAHistoryServices.AddHistoryItem to insert into the global positional or
  /// location history stack. 
  /// </summary>
  IOTAHistoryItem = interface(IOTANotifier)
    ['{4D97EDB8-16BE-4BD2-A624-3EE91EB4C8BC}']
    /// <summary>
    /// Execute is called when this particular history item is invoked 
    /// </summary>
    procedure Execute;
    /// <summary>
    /// GetItemCaption is called if the UI needs to display the history item in
    /// a menu or other type of list.  The implementor should return a human
    /// readable string that uniquely identifies this item. 
    /// </summary>
    function GetItemCaption: string;
    /// <summary>
    /// IsEqual is called when inserting this item into the history stack to
    /// determine if this item is the same location or position as the current
    /// top item.  This will keep the stack from filling with adjacent duplicate
    /// entries. 
    /// </summary>
    function IsEqual(const Item: IOTAHistoryItem): Boolean;
  end;

  /// <summary>
  /// IOTAHistoryServices
  /// This provides a globally available history service for managing positional
  /// or location history similar to an internet browser.  This service is
  /// typically activated by the user by selecting a back or forward arrow on a
  /// toolbar. 
  /// </summary>

  IOTAHistoryServices = interface(IInterface)
    ['{0EFF550D-305C-466C-94C1-1D406DF9B73A}']
    /// <summary>
    /// AddHistoryItem adds the given items to the history stack at the current
    /// stack pointer location.  All items *after* the current location, which are
    /// the &quot;forward&quot; items, are destroyed.  CurItem is the current location you wish
    /// to save, and NewItem is the new location you wish to save. The current location
    /// is checked against the top of the stack and if it doesn't exists, it is then
    /// added.  The NewItem is always added.  It is done this way so that you can
    /// always get back to the current location 
    /// </summary>
    procedure AddHistoryItem(const CurItem, NewItem: IOTAHistoryItem);
    /// <summary>
    /// GetBackwardCount returns the number of items in history stack that are
    /// ahead of the current stack pointer 
    /// </summary>
    function GetBackwardCount: Integer;
    /// <summary>
    /// GetBackwardItem returns the indexed item in the current back &quot;list&quot;
    /// portion of the history stack 
    /// </summary>
    function GetBackwardItem(Index: Integer): IOTAHistoryItem;
    /// <summary>
    /// GetForwardCount returns the number of items in history stack that are
    /// behind the current stack pointer 
    /// </summary>
    function GetForwardCount: Integer;
    /// <summary>
    /// GetForwardItem returns the indexed item in the current forward &quot;list&quot;
    /// portion of the history stack 
    /// </summary>
    function GetForwardItem(Index: Integer): IOTAHistoryItem;
    /// <summary>
    /// GetStackStatus returns whether or not the current stack pointer has items
    /// in the stack before and/or after its current location.  The results can be
    /// used to determine whether or not a forward or backward toolbar button is
    /// enabled.  Typically this is called internally by the IDE as it implements
    /// globally available toolbar buttons as part of this service.  This function
    /// is provided for informational purposes. 
    /// </summary>
    procedure GetStackStatus(var CanGoBack, CanGoForward: Boolean);
    /// <summary>
    /// Call this Execute to cause the stack pointer to advance down or up the stack
    /// depending upon the parameter and call the Execute of the next item,
    /// if available. 
    /// </summary>
    procedure Execute(GoForward: Boolean); overload;
    /// <summary>
    /// Call this Execute to force the item to be executed and to set the current
    /// stack pointer to this position. 
    /// </summary>
    procedure Execute(const AItem: IOTAHistoryItem); overload;
    /// <summary>
    /// RemoveHistoryItem can be used to forcibly remove items from the history
    /// list. Typically this method is not used, however in cases where the module
    /// that implements this item is being unloaded, it may be necessary. There
    /// be no items in the list that could potentially cause control to transfer to
    /// a spot where there is no longer any valid code. 
    /// </summary>
    procedure RemoveHistoryItem(const Item: IOTAHistoryItem);

    property BackwardCount: Integer read GetBackwardCount;
    property BackwardItems[Index: Integer]: IOTAHistoryItem read GetBackwardItem;
    property ForwardCount: Integer read GetForwardCount;
    property ForwardItems[Index: Integer]: IOTAHistoryItem read GetForwardItem;
  end;

  IOTACompileNotifier = interface(IInterface)
    ['{C138C3D0-2806-479F-9960-950CD0B8A874}']
    procedure ProjectCompileStarted(const Project: IOTAProject; Mode: TOTACompileMode);
    procedure ProjectCompileFinished(const Project: IOTAProject; Result: TOTACompileResult);
    procedure ProjectGroupCompileStarted(Mode: TOTACompileMode);
    procedure ProjectGroupCompileFinished(Result: TOTACompileResult);
  end;

  IOTACompileServices = interface(IInterface)
    ['{68C486EF-C079-4D40-B462-2C0DD21FE342}']
    function AddNotifier(Notifier: IOTACompileNotifier): Integer; overload;
    /// <summary>
    /// Cancel background compilation. Waits for background thread
    /// to terminate before returning. Optionally prompt the user,
    /// returning True if the thread was cancelled and false if not 
    /// </summary>
    function CancelBackgroundCompile(Prompt: Boolean): Boolean;
    /// <summary>
    /// Compile a list of projects. Returns crOTABackground if background
    /// compiling. Add IOTACompileNotifier to be informed of the result of
    /// background compilation 
    /// </summary>
    function CompileProjects(Projects: array of IOTAProject; CompileMode: TOTACompileMode;
      Wait, ClearMessages: Boolean): TOTACompileResult;
    /// <summary>
    /// Prevent any subsequent compilation requests to the IDE from taking
    /// place in the background thread, regardless of settings 
    /// </summary>
    procedure DisableBackgroundCompilation;
    /// <summary>
    /// Re-enable background compilation in the IDE 
    /// </summary>
    procedure EnableBackgroundCompilation;
    /// <summary>
    /// Returns true if a background compile is currently running 
    /// </summary>
    function IsBackgroundCompileActive: Boolean;
    procedure RemoveNotifier(Index: Integer);
  end;

  IOTAProjectFileStorageNotifier = interface(IInterface)
    ['{D6B7B13F-F5EA-4320-BDCE-55236638BDE2}']
    /// <summary>
    /// This function will return the name of your node in the project file. 
    /// </summary>
    function GetName: string;
    /// <summary>
    /// Called when a project is loaded and there is a node that matches the
    /// result of GetName.  You may keep a reference to Node and edit the contents
    /// but you must free the reference when ProjectClosing is called. 
    /// </summary>
    procedure ProjectLoaded(const ProjectOrGroup: IOTAModule; const Node: IXMLNode);
    procedure CreatingProject(const ProjectOrGroup: IOTAModule);
    procedure ProjectSaving(const ProjectOrGroup: IOTAModule; const Node: IXMLNode);
    procedure ProjectClosing(const ProjectOrGroup: IOTAModule);
    property Name: string read GetName;
  end;

  IOTAProjectFileStorage = interface(IInterface)
    ['{81515027-EEED-442F-977C-8F39F53D8D0A}']
    /// <summary>
    /// Called to create a section in the project file to store user data.
    /// ProjectOrGroup is the project file or project group that the section
    /// is to be added.  This project must be open at the time.  SectionName is
    /// the name of the new section to be added to the project xml file.  This
    /// name must be a valid xml node name.  Set LocalProjectFile to true if the
    /// section is to be stored in local project file or false for the standard
    /// project file. 
    /// </summary>
    function AddNewSection(const ProjectOrGroup: IOTAModule; SectionName: string;
      LocalProjectFile: Boolean): IXMLNode;
    /// <summary>
    /// Call this to register an IOTANotifier. The result is the index to be
    /// used when calling RemoveNotifier. If &lt;0 then an error occurred. 
    /// </summary>
    function AddNotifier(const ANotifier: IOTAProjectFileStorageNotifier): Integer;
    function GetNotifierCount: Integer;
    function GetNotifier(Index: Integer): IOTAProjectFileStorageNotifier;
    /// <summary>
    /// Will return the specified node if it exists, otherwise it returns nil 
    /// </summary>
    function GetProjectStorageNode(const ProjectOrGroup: IOTAModule;
       const NodeName: string; LocalProjectFile: Boolean): IXMLNode;
    procedure RemoveNotifier(Index: Integer);
  end;

  /// <summary>
  /// This notifier is deprecated. Use IOTAProjectMenuItemCreatorNotifier instead.
  /// It supports adding menu items for multi-selected items in the Project Manager. 
  /// </summary>
  INTAProjectMenuCreatorNotifier = interface(IOTANotifier)
    ['{8209348C-2114-439C-AD4E-BFB7049A636A}']
    /// <summary>
    /// The result will be inserted into the project manager local menu. Menu
    /// may have child menus. 
    /// </summary>
    function AddMenu(const Ident: string): TMenuItem;
    /// <summary>
    /// Return True if you wish to install a project manager menu item for this
    /// ident.  In cases where the project manager node is a file Ident will be
    /// a fully qualified file name. 
    /// </summary>
    function CanHandle(const Ident: string): Boolean;
  end;

  IOTAProjectMenuItemCreatorNotifier = interface(IOTANotifier)
    ['{CFEE5A57-2B04-4CD6-968E-1CBF8BF96522}']
    /// <summary>
    /// For each menu item you wish to add to the project manager for the given
    /// list of idents, add an IOTAProjectManagerMenu to the ProjectManagerMenuList.
    /// An example of a value for IdentList is sFileContainer and the name of the
    /// file, look above in this file for other constants. 
    /// </summary>
    procedure AddMenu(const Project: IOTAProject; const IdentList: TStrings;
      const ProjectManagerMenuList: IInterfaceList; IsMultiSelect: Boolean);
  end;

  IOTAProjectManager = interface(IInterface)
    ['{B142EF92-0A91-4614-A72A-CE46F9C88B7B}']
    /// <summary>
    /// This function is deprecated -- use AddMenuItemCreatorNotifier instead 
    /// </summary>
    function AddMenuCreatorNotifier(const Notifier: INTAProjectMenuCreatorNotifier): Integer; deprecated;
    /// <summary>
    /// Adds a menu notifier, which allows you to customize the local menu of the
    /// project manager 
    /// </summary>
    function AddMenuItemCreatorNotifier(const Notifier: IOTAProjectMenuItemCreatorNotifier): Integer;
    /// <summary>
    /// Returns the currently selected project.  Ident is the string identifier
    /// for the returned project 
    /// </summary>
    function GetCurrentSelection(var Ident: string): IOTAProject;
    /// <summary>
    /// This function is deprecated -- use RemoveMenuItemCreatorNotifier instead 
    /// </summary>
    procedure RemoveMenuCreatorNotifier(Index: Integer); deprecated;
    /// <summary>
    /// Removes a previously added menu notifier 
    /// </summary>
    procedure RemoveMenuItemCreatorNotifier(Index: Integer);
  end;

  IOTAPerformanceTimer = interface(IInterface)
    ['{7C04C7AA-A699-41AA-B6F7-C369CFF8EB5F}']
    function GetCategory: string;
    function GetDescription: string;
    function GetResults: Integer;

    /// <summary>
    /// Return the category (optional) of this timer 
    /// </summary>
    property Category: string read GetCategory;
    /// <summary>
    /// Return the description of this timer 
    /// </summary>
    property Description: string read GetDescription;
    /// <summary>
    /// Timer results expressed in miliseconds
    /// </summary>
    property Results: Integer read GetResults;
  end;

  /// <summary>
  /// IOTATimerServices
  /// This provides a globally available service for timing operations and tracking performance.
  /// Individual timer results are tracked and persisted by a more complete performance monitor
  /// implementation.  See the PerfMon.pas unit for information. Timer services must be enabled
  /// with the BDS.exe -TS command line switch.  The default log file name is
  /// BDSPerformanceData.log and is located in the application data directory.  The default
  /// logfile name may be overriden by including the filename along with the -TS command
  /// line switch (no spaces) or via the property on the service interface. 
  /// </summary>
  IOTATimerServices = interface(IInterface)
    ['{E7D682D3-3540-4981-9ABF-160828754191}']
    /// <summary>
    /// Find a timer object from a description or category 
    /// </summary>
    function FindTimer(const Description, Category: string; ActiveOnly: Boolean = true): IOTAPerformanceTimer;
    /// <summary>
    /// Retrieve a timer object to get the description, category or results 
    /// </summary>
    function GetTimer(TimerID: Integer): IOTAPerformanceTimer;
    /// <summary>
    /// Returns the number of individual timers for iterating all results 
    /// </summary>
    function GetTimerCount: Integer;
    /// <summary>
    /// Set a marker with the elapsed time since the process was started 
    /// </summary>
    procedure MarkElapsedTime(const Description: string);
    /// <summary>
    /// Begin timing a new operation.  Returned handle is used to stop timing. Category is optional 
    /// </summary>
    function StartTimer(const Description: string; const Category: string = ''): Integer;
    /// <summary>
    /// Stop an active timer  
    /// </summary>
    procedure StopTimer(TimerID: Integer); overload;
    /// <summary>
    /// Alternate stop method, useful when StartTimer and StopTimer are in different places 
    /// </summary>
    procedure StopTimer(const Description, Category: string); overload;
    /// <summary>
    /// Force collected data for all timers to be written to the logfile 
    /// </summary>
    procedure UpdateLogFile;
    /// <summary>
    /// The name of the logfile 
    /// </summary>
    function GetLogFileName: string;
    procedure SetLogFileName(const Value: string);
    property LogFileName: string read GetLogFileName write SetLogFileName;
  end;

  IOTAHelpTrait = interface(IDispatch)
    ['{DEE36173-1597-498A-A85A-C90BFCAE9B74}']
  end;

  IOTAPersonalityHelpTrait = interface(IDispatch)
    ['{914E82DB-4123-4AA8-91D9-DB105E1FEC64}']
    procedure ShowKeywordHelp(const Keyword: WideString); safecall;
    function UnderstandsKeyword(const Keyword: WideString): WordBool; safecall;
  end;

  IOTAHelpServices = interface(IDispatch)
    ['{25F4CC12-EA93-4AEC-BC4A-DFDF427053B0}']
    procedure ShowKeywordHelp(const Keyword: WideString); safecall;
    function UnderstandsKeyword(const Keyword: WideString): WordBool; safecall;
    procedure ShowContextHelp(ContextID: Integer); safecall;
    procedure ShowTopicHelp(const Topic: WideString); safecall;
    function GetFileHelpTrait(const FileName: WideString): IOTAHelpTrait; safecall;
    function GetPersonalityHelpTrait(const Personality: WideString): IOTAPersonalityHelpTrait; safecall;
  end;

  /// <summary>
  /// This is meant to be an abstract interface that describes a menu context that
  /// can be passed to an IOTALocalMenu-descendant's Execute method. 
  /// </summary>
  IOTAMenuContext = interface(IInterface)
    ['{378F0D38-ED5F-4128-B7D6-9D423FC1502F}']
    /// <summary>
    /// Returns the identifier for this context 
    /// </summary>
    function GetIdent: string;
    /// <summary>
    /// Returns the verb for this context 
    /// </summary>
    function GetVerb: string;

    property Ident: string read GetIdent;
    property Verb: string read GetVerb;
  end;

  /// <summary>
  /// This is meant to be an abstract interface that describes a local menu item
  /// in an IDE view.  Specific views that can have their local menus customized
  /// will provide a descendant interface to be used for that view 
  /// </summary>
  IOTALocalMenu = interface(IOTANotifier)
    ['{83ECCBDF-939D-4F8D-B96D-A0C67ACC86EA}']
    /// <summary>
    /// Returns the Caption to be used for this menu item 
    /// </summary>
    function GetCaption: string;
    /// <summary>
    /// Returns the Checked state to be used for this menu item 
    /// </summary>
    function GetChecked: Boolean;
    /// <summary>
    /// Returns the Enabled state to be used for this menu item 
    /// </summary>
    function GetEnabled: Boolean;
    /// <summary>
    /// Returns the help context to be used for this menu item 
    /// </summary>
    function GetHelpContext: Integer;
    /// <summary>
    /// Returns the Name for this menu item.  If blank, a name will be generated 
    /// </summary>
    function GetName: string;
    /// <summary>
    /// Returns the parent menu for this menu item 
    /// </summary>
    function GetParent: string;
    /// <summary>
    /// Returns the position of this menu item within the menu 
    /// </summary>
    function GetPosition: Integer;
    /// <summary>
    /// Returns the verb associated with this menu item 
    /// </summary>
    function GetVerb: string;
    /// <summary>
    /// Sets the Caption of the menu item to the specified value 
    /// </summary>
    procedure SetCaption(const Value: string);
    /// <summary>
    /// Sets the Checked state of the menu item to the specified value 
    /// </summary>
    procedure SetChecked(Value: Boolean);
    /// <summary>
    /// Sets the Enabled  state of the menu item to the specified value 
    /// </summary>
    procedure SetEnabled(Value: Boolean);
    /// <summary>
    /// Sets the help context of the menu item to the specified value 
    /// </summary>
    procedure SetHelpContext(Value: Integer);
    /// <summary>
    /// Sets the Name of the menu item to the specified value 
    /// </summary>
    procedure SetName(const Value: string);
    /// <summary>
    /// Sets the Parent of the menu item to the specified value 
    /// </summary>
    procedure SetParent(const Value: string);
    /// <summary>
    /// Sets the position of the menu item to the specified value 
    /// </summary>
    procedure SetPosition(Value: Integer);
    /// <summary>
    /// Sets the verb associated with the menu item to the specified value 
    /// </summary>
    procedure SetVerb(const Value: string);

    property Caption: string read GetCaption write SetCaption;
    property Checked: Boolean read GetChecked write SetChecked;
    property Enabled: Boolean read GetEnabled write SetEnabled;
    property HelpContext: Integer read GetHelpContext write SetHelpContext;
    property Name: string read GetName write SetName;
    property Parent: string read GetParent write SetParent;
    property Position: Integer read GetPosition write SetPosition;
    property Verb: string read GetVerb write SetVerb;
  end;

  /// <summary>
  /// This is the context used for Project Manager local menu items.  The list
  /// passed to IOTAProjectManagerMenu.Execute will be a list of these interfaces 
  /// </summary>
  IOTAProjectMenuContext = interface(IOTAMenuContext)
    ['{ECEC33FD-837A-46DC-A0AD-1FFEBEEA23AF}']
    /// <summary>
    /// Returns the project associated with the menu item 
    /// </summary>
    function GetProject: IOTAProject;

    property Project: IOTAProject read GetProject;
  end;

  /// <summary>
  /// This is a Project Manager specific local menu item 
  /// </summary>
  IOTAProjectManagerMenu = interface(IOTALocalMenu)
    ['{5E3B2F18-306E-4922-9067-3F71843C51FA}']
    /// <summary>
    /// Indicates whether or not this menu item supports multi-selected items 
    /// </summary>
    function GetIsMultiSelectable: Boolean;
    /// <summary>
    /// Sets this menu item's multi-selected state 
    /// </summary>
    procedure SetIsMultiSelectable(Value: Boolean);
    /// <summary>
    /// Execute is called when the menu item is selected.  MenuContextList is a
    /// list of IOTAProjectMenuContext.  Each item in the list represents an item
    /// in the project manager that is selected 
    /// </summary>
    procedure Execute(const MenuContextList: IInterfaceList); overload;
    /// <summary>
    /// PreExecute is called before the Execute method.  MenuContextList is a list
    /// of IOTAProjectMenuContext.  Each item in the list represents an item in
    /// the project manager that is selected 
    /// </summary>
    function PreExecute(const MenuContextList: IInterfaceList): Boolean;
    /// <summary>
    /// PostExecute is called after the Execute method.  MenuContextList is a list
    /// of IOTAProjectMenuContext.  Each item in the list represents an item in
    /// the project manager that is selected 
    /// </summary>
    function PostExecute(const MenuContextList: IInterfaceList): Boolean;

    property IsMultiSelectable: Boolean read GetIsMultiSelectable write SetIsMultiSelectable;
  end;

  IOTAVersionControlNotifier = interface(IOTANotifier)
    ['{C301E578-D2AE-48EA-9EEA-AEE48D578FE7}']
    /// <summary>
    /// Returns the name that is shown if more than one version control system is
    /// installed and the user wants to add a project to a version control system 
    /// </summary>
    function GetDisplayName: string;
    /// <summary>
    /// Returns true if the file is currently managed/versioned by the version
    /// control system.  Under most cases &quot;Ident&quot; will be a fully-qualified
    /// filename -- however, if the user clicks on a node that is not a file (for
    /// example the &quot;Contains&quot; node for a package project), then &quot;Ident&quot; will be
    /// the name of that node 
    /// </summary>
    function IsFileManaged(const Project: IOTAProject; const IdentList: TStrings): Boolean;
    /// <summary>
    /// This procedure is called when the project manager is creating its local
    /// menu.  The version control system may add any menu items to
    /// ProjectManagerMenuList that it wishes to have shown 
    /// </summary>
    procedure ProjectManagerMenu(const Project: IOTAProject; const IdentList: TStrings;
      const ProjectManagerMenuList: IInterfaceList; IsMultiSelect: Boolean);
    /// <summary>
    /// Called when the user selects a menu item to add a project to this
    /// version control system 
    /// </summary>
    function AddNewProject(const Project: IOTAProject): Boolean;

    property DisplayName: string read GetDisplayName;
  end;

  IOTAVersionControlNotifier150 = interface(IOTAVersionControlNotifier)
    ['{DDAB6FCC-ABE7-46C8-8040-ABFE7E1D7604}']
    /// <summary>
    /// This function is called when a user wants to retrieve a project from
    /// the repository.  Return True to have the IDE attempt to open ProjectName 
    /// </summary>
    function CheckoutProject(var ProjectName: string): Boolean;
    /// <summary>
    /// This function is called when the user wants to retrieve a project from
    /// a repository using the specified Connection. The most common use is when
    /// this is called from the Welcome page.  This allows a webpage to have a
    /// link to checkout and open a project from a repository 
    /// </summary>
    function CheckoutProjectWithConnection(var ProjectName: string; const Connection: string): Boolean;
    /// <summary>
    /// Returns a unique name used to identify the version control system 
    /// </summary>
    function GetName: string;

    property Name: string read GetName;
  end;

  /// <summary>
  /// IOTAVersionControlServices provides functionality for version control
  /// systems to plug into the IDE 
  /// </summary>
  IOTAVersionControlServices = interface(IInterface)
    ['{1BFE2647-9BFC-4084-AE3E-3E09A9179E34}']
    /// <summary>
    /// Add s version control system into the IDE.  Returns the index of the
    /// added system 
    /// </summary>
    function AddNotifier(const ANotifier: IOTAVersionControlNotifier): Integer;
    /// <summary>
    /// Returns the number of available version control systems 
    /// </summary>
    function GetCount: Integer;
    /// <summary>
    /// Returns the specified version control system 
    /// </summary>
    function GetItem(const Index: Integer): IOTAVersionControlNotifier;
    /// <summary>
    /// Remove a previously added version control system 
    /// </summary>
    procedure RemoveNotifier(Index: Integer);

    property Count: Integer read GetCount;
    property Items[const Index: Integer]: IOTAVersionControlNotifier read GetItem;
  end;

  TOTADiffFlag = (dfOTABuffer, dfOTAFile, dfOTARevision);

  IOTABaseCustomDifferenceViewer = interface(IOTANotifier)
    ['{8302DA7D-1FDA-4043-95C7-F2C1C6BCE127}']
    /// <summary>
    /// Return the display name of this difference viewer.  This name can be
    /// translated 
    /// </summary>
    function GetDisplayName: string;
    /// <summary>
    /// Return the internal name of this difference viewer.  This name should not
    /// be translated 
    /// </summary>
    function GetName: string;

    property DisplayName: string read GetDisplayName;
    property Name: string read GetName;
  end;

  IOTACustomDifferenceViewer = interface(IOTABaseCustomDifferenceViewer)
    ['{E20CA9AF-799E-4AE1-9C74-DBB2B9C54529}']
    /// <summary>
    /// Called to request that a Difference view be shown.  Left and Right
    /// represent the file contents to show in the Difference view.
    /// LeftDisplayName and RightDisplayName are strings that the Difference
    /// viewer should show in its user interface.  LeftFileName and RightFileName
    /// (if specified) are the actual file names of the files being shown in the
    /// Difference viewer. LeftFlag and RightFlag indicate the types of the two
    /// items shown in the Difference viewer. 
    /// </summary>
    procedure ShowDifference(const Left, Right: IStream; const LeftDisplayName,
      RightDisplayName, LeftFileName, RightFileName: string;
      LeftFlag, RightFlag: TOTADiffFlag);
  end;

  TOTADifferenceType = (dtOTAInternal, dtOTAExternal, dtOTADefault);

  IOTACustomDifferenceManager = interface
    ['{6440B99E-AD2A-485B-BC9E-E43E8D81C999}']
    /// <summary>
    /// Returns the current default difference viewer 
    /// </summary>
    function GetDefaultDifferenceViewer: IOTACustomDifferenceViewer;
    /// <summary>
    /// Returns the current default external difference viewer 
    /// </summary>
    function GetDefaultExternalDifferenceViewer: IOTACustomDifferenceViewer;
    /// <summary>
    /// Returns the current default internal difference viewer 
    /// </summary>
    function GetDefaultInternalDifferenceViewer: IOTACustomDifferenceViewer;
    /// <summary>
    /// Returns the number of available external difference viewers 
    /// </summary>
    function GetExternalCount: Integer;
    /// <summary>
    /// Returns the specified external difference viewer 
    /// </summary>
    function GetExternalDifferenceViewer(Index: Integer): IOTACustomDifferenceViewer;
    /// <summary>
    /// Returns the number of available internal difference viewers 
    /// </summary>
    function GetInternalCount: Integer;
    /// <summary>
    /// Returns the specified internal difference viewer 
    /// </summary>
    function GetInternalDifferenceViewer(Index: Integer): IOTACustomDifferenceViewer;
    /// <summary>
    /// Registers an internal custom difference viewer. Returns the index of the
    /// newly registerd difference viewer 
    /// </summary>
    function RegisterCustomDifferenceViewer(const CustomDiffViewer: IOTACustomDifferenceViewer): Integer;
    /// <summary>
    /// Request that a difference be shown. Left and Right represent the file
    /// contents to show in the Difference viewer.  LeftDisplayName and
    /// RightDisplayName are strings that the Difference viewer should show in its
    /// user interface.  LeftFileName and RightFileName (if specified) are the
    /// actual file names of the files being shown in the Difference viewer.
    /// LeftFlag and RightFlag indicate the types of the two items shown in the
    /// Difference viewer. 
    /// </summary>
    procedure ShowDifference(const Left, Right: IStream; const LeftDisplayName,
      RightDisplayName, LeftFileName, RightFileName: string;
      LeftFlag, RightFlag: TOTADiffFlag; DifferenceType: TOTADifferenceType);
    /// <summary>
    /// Unregister a previously registered custom difference viewer 
    /// </summary>
    procedure UnRegisterCustomDifferenceViewer(Index: Integer);

    property DefaultDifferenceViewer: IOTACustomDifferenceViewer read GetDefaultDifferenceViewer;
    property DefaultExternalDifferenceViewer: IOTACustomDifferenceViewer read GetDefaultExternalDifferenceViewer;
    property DefaultInternalDifferenceViewer: IOTACustomDifferenceViewer read GetDefaultInternalDifferenceViewer;
    property ExternalCount: Integer read GetExternalCount;
    property InternalCount: Integer read GetInternalCount;
  end;

  IOTACustomMergeViewer = interface(IOTABaseCustomDifferenceViewer)
    ['{06D2060C-5FA0-4216-A328-1271279DE2AE}']
    /// <summary>
    /// Called to request that a Merge view be shown.  Base, Theirs, and Mine
    /// represent the file contents to show in the Merge view.  BaseDisplayName,
    /// TheirsDisplayName and MineDisplayName are strings that the Merge viewer
    /// should show in its user interface.  FileName represents the actual file
    /// name.  BaseFileName, TheirsFileName and MineFileName (if specified) are the
    /// actual file names of the files being shown in the Merge viewer. If Wait is
    /// True, then this call should not return until the merge is complete (this
    /// is mainly here in case a custom Merge viewer calls an external tool) 
    /// </summary>
    procedure ShowMerge(const Base, Theirs, Mine: IStream; const BaseDisplayName,
      TheirsDisplayName, MineDisplayName, FileName, BaseFileName, TheirsFileName,
      MineFileName: string; Wait: Boolean);
  end;

  IOTACustomMergeManager = interface
    ['{B04FCE64-E57F-47E8-BA6A-2E96AD737BBA}']
    /// <summary>
    /// Returns the current default merge viewer 
    /// </summary>
    function GetDefaultMergeViewer: IOTACustomMergeViewer;
    /// <summary>
    /// Returns the current default external merge viewer 
    /// </summary>
    function GetDefaultExternalMergeViewer: IOTACustomMergeViewer;
    /// <summary>
    /// Returns the current default internal merge viewer 
    /// </summary>
    function GetDefaultInternalMergeViewer: IOTACustomMergeViewer;
    /// <summary>
    /// Returns the number of available external merge viewers 
    /// </summary>
    function GetExternalCount: Integer;
    /// <summary>
    /// Returns the specified external merge viewer 
    /// </summary>
    function GetExternalMergeViewer(Index: Integer): IOTACustomMergeViewer;
    /// <summary>
    /// Returns the number of available internal merge viewers 
    /// </summary>
    function GetInternalCount: Integer;
    /// <summary>
    /// Returns the specified internal merge viewer 
    /// </summary>
    function GetInternalMergeViewer(Index: Integer): IOTACustomMergeViewer;
    /// <summary>
    /// Registers an internal custom merge viewer. Returns the index of the newly
    /// registerd merge viewer 
    /// </summary>
    function RegisterCustomMergeViewer(const CustomMergeViewer: IOTACustomMergeViewer): Integer;
    /// <summary>
    /// Request that a Merge view be shown.  Base, Theirs, and Mine represent the
    /// file contents to show in the Merge view.  BaseDisplayName,
    /// TheirsDisplayName and MineDisplayName are strings that the Merge viewer
    /// should show in its user interface.  FileName represents the actual file
    /// name.  BaseFileName, TheirsFileName and MineFileName (if specified) are the
    /// actual file names of the files being shown in the Merge viewer. If Wait is
    /// True, then this call should not return until the merge is complete (this
    /// is mainly here in case a custom Merge viewer calls an external tool) 
    /// </summary>
    procedure ShowMerge(const Base, Theirs, Mine: IStream; const BaseDisplayName,
      TheirsDisplayName, MineDisplayName, FileName, BaseFileName, TheirsFileName,
      MineFileName: string; MergeType: TOTADifferenceType; Wait: Boolean);
    /// <summary>
    /// Unregister a previously registered custom merge viewer 
    /// </summary>
    procedure UnRegisterCustomMergeViewer(Index: Integer);

    property DefaultMergeViewer: IOTACustomMergeViewer read GetDefaultMergeViewer;
    property DefaultExternalMergeViewer: IOTACustomMergeViewer read GetDefaultExternalMergeViewer;
    property DefaultInternalMergeViewer: IOTACustomMergeViewer read GetDefaultInternalMergeViewer;
    property ExternalCount: Integer read GetExternalCount;
    property InternalCount: Integer read GetInternalCount;
  end;

  TOTABuildEventType = (betOTAPreCompile, betOTAPostCompile, betOTAPreLink);
  TOTABuildEventTypes = set of TOTABuildEventType;
  TOTABuildEventMode = (beOTAAlways, beOTATargetOutOfDate);

  IOTABuildEvent = interface
    ['{D00E9978-43EE-442F-9296-A175037DF581}']
    /// <summary>
    /// Build mode is only valid for post-build events. betOTAAlways will always
    /// execute the event, while beOTATargetOutOfDate will only execute when the
    /// project's target output is out-of-date 
    /// </summary>
    function GetBuildMode: TOTABuildEventMode;
    procedure SetBuildMode(const Value: TOTABuildEventMode);
    /// <summary>
    /// If one or more of the commands fail, cancel the build 
    /// </summary>
    function GetCancel: Boolean;
    /// <summary>
    /// If one or more of the commands fail, cancel the build 
    /// </summary>
    procedure SetCancel(const Value: Boolean);
    /// <summary>
    /// Return the commands to execute. Multiple commands are separated by CR-LF Pair 
    /// </summary>
    function GetCommands: string;
    /// <summary>
    /// Commands to execute. Separate multiple commands with a CR-LF pair 
    /// </summary>
    procedure SetCommands(Value: string);
    function GetType: TOTABuildEventType;

    property BuildType: TOTABuildEventType read GetType;
    property BuildMode: TOTABuildEventMode read GetBuildMode write SetBuildMode;
    property Commands: string read GetCommands write SetCommands;
    property CancelOnError: Boolean read GetCancel write SetCancel;
  end;

  IOTABuildEventProvider = interface
    ['{803BC8A0-E6B5-47FA-807C-685E26FF551D}']
    function GetBuildEvent(EventType: TOTABuildEventType;
      ConfigKey, PlatformName: string; Create: Boolean = False; const Filename: string = ''): IOTABuildEvent;
    function HasBuildEvents(ConfigKey: string = ''; PlatformName: string = ''; const Filename: string = ''): Boolean;
    procedure RemoveBuildEvent(EventType: TOTABuildEventType;
      ConfigKey, PlatformName: string; const Filename: string = '');
  end;

  IOTAProjectUnitScopes = interface
    ['{3D724710-9F56-4BFB-8804-2410022BAAE9}']
    function GetUnitScopes(ConfigName: string = ''; PlatformName: string = ''): TArray<string>;
  end;

  IOTAGetItService220 = interface
    ['{767984C8-F8CE-4BC5-9562-725AC0665710}']
    function Install(const CatalogId: string): Boolean;
    function Uninstall(const CatalogId: string): Boolean;
  end;

  IOTAGetItService230 = interface(IOTAGetItService220)
    ['{CB83D480-DC2D-4881-AF2A-E68496EE52BF}']
    function IsInstalled(const CatalogId: string): Boolean;
  end;

  IOTAGetItService = interface(IOTAGetItService230)
    ['{6DA2C99A-212A-4A24-B3CA-8C67CF4B7123}']
    procedure CheckProjectDependencies(const Project: IOTAProject);
    function InstallAndroidSDK: Boolean;
    function InstallAndroidSDKTools: Boolean;
    function Install(const CatalogId: string): Boolean; overload;
    function Install(const CatalogId: string; AutoCloseProgressDlg: Boolean = False): Boolean; overload;
  end;

  INTAIDEThemingServicesNotifier = interface(IOTANotifier)
    ['{4CBFAA40-89E6-412C-B667-9034666E2931}']
    /// <summary>
    ///  This notifier will be called immediately before the active IDE Theme changes.
    /// </summary>
    procedure ChangingTheme();
    /// <summary>
    ///  This notifier will be called immediately after the active IDE Theme changes.
    /// </summary>
    procedure ChangedTheme();
  end;

  IOTAExtensionsNotifier = interface(IOTANotifier)
    ['{C7066567-194C-41BB-B7FA-DA2EB1F4DA66}']
    /// <summary>
    ///  This notifier will be called immediately after the OTA Extension added
    /// </summary>
    procedure AddedOTAExtension();
  end;

  IOTAIDEThemingServices250 = interface(IInterface)
    ['{DEAD2648-9B21-4084-771E-1E69A9176637}']  
    /// <summary>
    ///  Call this to register an INTAIDEThemingServicesNotifier. The result is the index to be
    ///  used when calling RemoveNotifier. If <0 then an error occurred.
    /// </summary>
    function AddNotifier(const ANotifier: INTAIDEThemingServicesNotifier): Integer;
    procedure RemoveNotifier(Index: Integer);
    /// <summary>
    ///  Returns the current Active Theme name.
    /// </summary>
    function GetActiveThemeName: string;
    /// <summary>
    ///  Returns the current Active StyleServices used by the IDE.
    /// </summary>
    function GetIDEStyleServices: TCustomStyleServices;
    /// <summary>
    ///  Returns the Enabled status of the IDE Theming.
    /// </summary>
    function GetIDEThemingEnabled: Boolean;
    /// <summary>
    ///  Recursive function which update the UI properties like Font.Color, Color for controls
    ///  which not uses Styles Hooks (i.e : TLabel, TPanel, TBevel).
    ///
    ///  This function can be used in the form initialization and/or in response to a IDE theme-changed notification.
    /// </summary>
    procedure ApplyTheme(AComponent: TComponent);
    /// <summary>
    ///  GetEditorColorSpeedSetting returns the current Editor Color SpeedSetting associated with the
    ///  IDE ThemeName passed in.
    /// </summary>
    function GetEditorColorSpeedSetting(const ThemeName: string): string;
    /// <summary>
    ///  GetOIColorSpeedSetting returns the selected Object Inspector Color SpeedSetting associated with the
    ///  IDE ThemeName passed in.
    /// </summary>
    function GetOIColorSpeedSetting(const ThemeName: string): string;
    property StyleServices: TCustomStyleServices read GetIDEStyleServices;
    property ActiveTheme: string read GetActiveThemeName;
    property IDEThemingEnabled: Boolean read GetIDEThemingEnabled;
    /// <summary>
    ///  Enable the Theming support in the specified Form Class.
    /// </summary>
    procedure RegisterFormClass(AFormClass : TCustomFormClass);
  end;

  IOTAIDEThemingServices260 = interface(IOTAIDEThemingServices250)
    ['{BDEBDA9B-7001-4A25-9639-A3699AE9FC51}']
    /// <summary>
    ///  Call this to register an IOTAEditorColorSpeedSetting. The result is the index to be
    ///  used when calling RemoveEditorColorNotifier. If <0 then an error occurred.
    /// </summary>
    function AddEditorColorNotifier(const ANotifier: IOTAEditorColorSpeedSetting): Integer;
    procedure RemoveEditorColorNotifier(Index: Integer);
  end;

  IOTAIDEThemingServices = interface(IOTAIDEThemingServices260)
    ['{DEAD2647-9B2C-4084-A61E-1E69A9179637}']
  end;

  IOTAIDEWaitDialogServices270 = interface(IInterface)
    ['{61858165-9756-4B3A-A5A5-192A392CEA4A}']
    /// <summary>
    ///  IsVisible allows to determine if IDE Wait Dialog is visible.
    /// </summary>
   function IsVisible: Boolean;
    /// <summary>
    ///  IsInputEnabled allows to determine if IDE Wait Dialog has blocked the user input
    ///  ignoring mouse, keyboard, and timer events.
    /// </summary>
    function IsInputEnabled: Boolean;
    /// <summary>
    ///  Show used for activate the IDE Wait Dialog. should be used always in try finally block with the CloseDialog.
    /// </summary>
    procedure Show(const Caption, ADescription: string);
    /// <summary>
    ///  CloseDialog close the IDE Wait Dialog if is visible.
    /// </summary>
    procedure CloseDialog;
    /// <summary>
    ///  UpdateCurrentWork is used to update the current item being processed of the many that may be being done.
    /// </summary>
    procedure UpdateCurrentWork(const ACurrentWork: string);
    /// <summary>
    /// UpdateDescription is used to update the overall description of the work being done.
    /// </summary>
    procedure UpdateDescription(const ADescription: string);
  end;
  
  IOTAIDEWaitDialogServices = interface(IOTAIDEWaitDialogServices270)
    ['{30CD7CFE-3EE4-4CED-AF4A-C8C76BE487F5}']
  end;

  /// <summary>
  /// This class serves as a stubbed implementation of the IOTANotifier interface.
  /// simply statically override the methods you intend to implement and redeclare
  /// IOTANotifier or descendant.  The most common overrides would probably be,
  /// Destroyed and Modified.  Some Subsystems do *not* call all methods since in
  /// some cases there is no such operation. This object does not exist for
  /// C++Builder since these interfaces are used directly as pure virtual COM-style
  /// classes. 
  /// </summary>

  TNotifierObject = class(TInterfacedObject)
  protected
    // IOTANotifier 
    procedure AfterSave;
    procedure BeforeSave;
    procedure Destroyed;
    procedure Modified;
  end;

  TModuleNotifierObject = class(TNotifierObject)
  protected
    // IOTAModuleNotifier 
    function CheckOverwrite: Boolean;
    procedure ModuleRenamed(const NewName: string);
    // IOTAModuleNotifier80 
    function AllowSave: Boolean;
    function GetOverwriteFileNameCount: Integer;
    function GetOverwriteFileName(Index: Integer): string;
    procedure SetSaveFileName(const FileName: string);
  end;

  /// <summary>
  /// Implements IOTAFile 
  /// </summary>
  TOTAFile = class(TInterfacedObject, IOTAFile)
    FSource: string;
    FAge: TDateTime;
  public
    constructor Create(const StringCode: String; const Age: TDateTime = -1);
    // IOTAFile 
    function GetSource: string; virtual;
    function GetAge: TDateTime; virtual;
  end;

  TOTAStringsAdapter = class(TInterfacedObject, IOTAStrings, INTAStrings)
  private
    FStrings: TStrings;
    FOwned: Boolean;
  protected
    // IOTAStrings
    procedure Assign(const Strings: IOTAStrings);
    function GetCount: Integer;
    function GetData(const Index: Integer): Integer;
    function GetItem(const Index: Integer): string;
    function GetName(const Index: Integer): string;
    function GetValue(const Name: string): string;
    function GetValueFromIndex(const Index: Integer): string;
    procedure SetData(const Index: Integer; Value: Integer);
    procedure SetItem(const Index: Integer; const Value: string);
    procedure SetValue(const Name, Value: string);
    procedure SetValueFromIndex(const Index: Integer; const Value: string);
    // INTAStrings
    function GetStrings: TStrings;
  public
    constructor Create(AStrings: TStrings; AOwned: Boolean = False);
    destructor Destroy; override;
  end;

  // OTAAsyncCodeInsightManager CallBack declarations
  TOTACodeCompleteCallBack = procedure(Sender: TObject; AId: Integer; AError: Boolean;
    const AMessage: string) of object;
  TOTAParametersCallBack = procedure(Sender: TObject; AId, ASelectIndex: Integer;
    AError: Boolean; const AMessage: string) of object;
  TOTAHintTextCallBack = procedure(Sender: TObject; AId: Integer; const AHint: string;
    AError: Boolean; const AMessage: string) of object;
  TOTAGotoDefinitionCallBack = procedure(Sender: TObject; AId: Integer;
    const AFileName: string; ALine: Integer; AError: Boolean;
    const AMessage: string) of object;
  TOTAParamIndexCallBack = procedure(Sender: TObject; AParamIndex: Integer) of object;
  TOTAParamIndexCallBackEx = procedure(Sender: TObject; AParamIndex, ALineIndex: Integer) of object;

  IOTAAsyncCodeInsightManager = interface
    ['{2BB78A32-BF68-4223-9993-50A0688204E4}']
     /// <summary> AAllow is set to True if AKey is supported by the manager.
     /// AKey has 4 special keys or is a character from the document.
     ///   #0 CodeInsight
     ///   #1 ParameterCodeInsight
     ///   #2 BrowseCodeInsight
     ///   #3 HintCodeInsight </summary>
    procedure AsyncAllowCodeInsight(var AAllow: Boolean; const AKey: Char);
     /// <summary> Return True if AInsightType is supported. </summary>
    function AsyncCanInvoke(AInsightType: TOTACodeInsightType): Boolean;
     /// <summary> Return True if enabled and ready to except Insights. </summary>
    function AsyncEnabled: Boolean;
     /// <summary> Invoke code completion (Code Insight) with the results sent
     /// to ACallback. </summary>
    function AsyncInvokeCodeCompletion(AHowInvoked: TOTAInvokeType; var AStr: string; ALine, ACharIndex: Integer;
      ACallback: TOTACodeCompleteCallBack): Integer;
     /// <summary> Invoke parameter completion (Parameter Insight) with the
     /// results sent to ACallback. </summary>
    function AsyncInvokeParameterCodeInsight(HowInvoked: TOTAInvokeType; const AFileName: string;
      ALine, ACharIndex: Integer; ACallback: TOTAParametersCallBack): Integer;
     /// <summary> Invoke Help Insight with the results sent to ACallback. </summary>
    function AsyncGetHintText(HintLine, HintCol: Integer; ACallBack: TOTAHintTextCallBack): Integer;
     /// <summary> Invoke go to definition with the results sent to ACallback. </summary>
    function AsyncGotoDefinition(const AFileName: string; ALine, ACharIndex: Integer;
      ACallBack: TOTAGotoDefinitionCallBack): Integer;
     /// <summary> Called when the IDE was currently displaying parameter
     /// complete information and the user is entering text. The callback
     /// returns the current index in the parameter list. </summary>
    procedure AsyncParameterCodeInsightParamIndex(const AFileName: string; ALine,
      ACharIndex: Integer; ACallBack: TOTAParamIndexCallBack);
     /// <summary> Called if an operation needs to be canceled. One example
     /// would be code completion not returning before the user reqests another
     /// code completion. </summary>
    procedure AsyncOperationCanceled(AId: Integer);
    /// <summary> Called before an insight is invoked if the result is True
    ///  then the 'Calculating...' status is show if False then nothing is shown.
    ///  </summary>
    function ShowCalculating: Boolean;
  end;

  IOTAAsyncCodeInsightManager270 = interface
    ['{15EA6CCC-7AF8-40EC-B957-87DC901F60AF}']
     /// <summary> Called when the IDE was currently displaying parameter
     /// complete information and the user is entering text. The callback
     /// returns the current index in the parameter list. The exteneded
     /// also includes Active Signature or LineIndex which is the best
     /// matching parameter list.</summary>
    procedure AsyncParameterCodeInsightParamIndexEx(const AFileName: string; ALine,
      ACharIndex: Integer; ACallBack: TOTAParamIndexCallBackEx);

  end;

  IOTACodeInsightUIOverride = interface
    ['{47D57C60-AB08-4A03-9A5E-2DC2C89ACAF6}']
    /// <summary> EnableTooltip is called when the IDE is determining whether
    ///  to call Tooltip or not. Changing the value of AEnabled will override
    ///  the default calculations of the IDE.
    /// </summary>
    procedure EnableTooltip(const AFileName: string;
      AElement: Integer; ATooltipPos: TOTAEditPos;
      var AEnabled: Boolean);
    /// <summary> EnableGotoDefinition is called when the IDE is determining
    ///  whether to call goto definition or not. Changing the value of AEnabled
    ///  will override the default calculations of the IDE.
    /// </summary>
    procedure EnableGotoDefinition(const AEditView: IOTAEditView;
      AElement: Integer; ATooltipPos: TOTAEditPos;
      var AEnabled: Boolean);
  end;


  /// <summary>
  /// Interface for retrieve product version / SKU info
  /// </summary>
  IOTAVersionSKUInfoService280 = interface(IInterface)
    ['{03DBF50C-B649-4AAF-AF5E-28E1B359D29B}']
    /// <summary>
    /// Return SKU identifier, possible values are:
    ///
    ///   Professional = 2
    ///   Professional C/S = 3
    ///   Enterprise = 4
    ///   Architect = 5
    ///   CommunityEdition = 128
    /// </summary>
    function GetSKU: Integer;
    /// <summary>
    /// Return product trial
    /// </summary>
    function GetIsProductTrial: Boolean;
    /// <summary>
    /// Return array w/ installed platforms.
    /// platforms identifiers are documented at System.Classes.
    ///
    /// Use PlatformAPI.PlatformIDToName for get the platform name.
    /// </summary>
    function GetPlatforms: TArray<TPlatformIds>;
    property SKU: Integer read GetSKU;
    property IsProductTrial: Boolean read GetIsProductTrial;
    property Platforms: TArray<TPlatformIds> read GetPlatforms;
  end;

  IOTAVersionSKUInfoService = interface(IOTAVersionSKUInfoService280)
    ['{530C43C7-7A23-45D6-BDDC-AD9C5C108C58}']
  end;

var
 (* The BorlandIDEServices global variable is initialized by the Delphi or
    C++Builder IDE.  From this interface all of the IxxxxServices interfaces
    may be queried for.  For example, in order to obtain the IOTAModuleServices
    interface, simply call the QueryInterface method with the interface
    identifier or the GUID for the IOTAModuleServices interface.  In Delphi, you
    could also use the "as" operator, however not all versions of the IDEs will
    support all the "services" interfaces.  IOTATodoServices is only supported
    in the Professional and Enterprise versions of the products.

    In Delphi;
      var
        ModuleServices: IOTAModuleServices;

      ...

      if Supports(BorlandIDEServices, IOTAModuleServices, ModuleServices) then
      begin
        ...
      end;

    or in C++Builder;

      IOTAModuleServices *ModuleServices;
      if (Supports(BorlandIDEServices, __uuidof(IOTAModuleServices), &ModuleServices))
      {
        ...
      }
  *)
  BorlandIDEServices: IBorlandIDEServices;
  SplashScreenServices: IOTASplashScreenServices;
  LibraryWizardProc: TWizardRegisterProc = nil;

procedure RegisterPackageWizard(const Wizard: IOTAWizard);

/// <summary>
/// Convert a String into an IOTAFile for use by the IDE 
/// </summary>
function StringToIOTAFile(const CodeString: string): IOTAFile;

/// <summary>
/// Returns the Active Project 
/// </summary>
function GetActiveProject: IOTAProject;

function PersonalityServices: IOTAPersonalityServices;

implementation

function StringToIOTAFile(const CodeString: string): IOTAFile;
begin
  Result := TOTAFile.Create(CodeString);
end;

function GetActiveProject: IOTAProject;
begin
  Result := nil;
  if Assigned(BorlandIDEServices) then
    Result := (BorlandIDEServices as IOTAModuleServices).GetActiveProject;
end;

procedure RegisterPackageWizard(const Wizard: IOTAWizard);
begin
  if Assigned(LibraryWizardProc) then
    LibraryWizardProc(Wizard);
end;

{ TNotifierObject }

procedure TNotifierObject.AfterSave;
begin
  // do nothing stub implementation
end;

procedure TNotifierObject.BeforeSave;
begin
  // do nothing stub implementation
end;

procedure TNotifierObject.Destroyed;
begin
  // do nothing stub implementation
end;

procedure TNotifierObject.Modified;
begin
  // do nothing stub implementation
end;

{ TOTAFile }
constructor TOTAFile.Create(const StringCode: String; const Age: TDateTime);
begin
  FSource := StringCode;
  FAge := Age;
end;

function    TOTAFile.GetSource: string;
begin
  Result := FSource;
end;

function    TOTAFile.GetAge: TDateTime;
begin
  Result := FAge;
end;

{ TModuleNotifierObject }

function TModuleNotifierObject.AllowSave: Boolean;
begin
  Result := True;
end;

function TModuleNotifierObject.CheckOverwrite: Boolean;
begin
  Result := True;
end;

function TModuleNotifierObject.GetOverwriteFileName(Index: Integer): string;
begin
  Result := '';
end;

function TModuleNotifierObject.GetOverwriteFileNameCount: Integer;
begin
  Result := 0;
end;

procedure TModuleNotifierObject.ModuleRenamed(const NewName: string);
begin
  { Do nothing }
end;

procedure TModuleNotifierObject.SetSaveFileName(const FileName: string);
begin
  { Do nothing }
end;

function PersonalityServices: IOTAPersonalityServices;
begin
  Supports(BorlandIDEServices, IOTAPersonalityServices, Result);
end;

{ TOTAStringsAdapter }

procedure TOTAStringsAdapter.Assign(const Strings: IOTAStrings);
var
  NTAStrings: INTAStrings;
  I, Index: Integer;
begin
  if Supports(Strings, INTAStrings, NTAStrings) then
    FStrings.Assign(NTAStrings.Strings)
  else
  begin
    FStrings.Clear;
    for I := 0 to Strings.Count - 1 do
    begin
      Index := FStrings.Add(Strings.Items[I]);
      FStrings.Objects[Index] := TObject(Strings.Data[I]);
    end;
  end;
end;

constructor TOTAStringsAdapter.Create(AStrings: TStrings; AOwned: Boolean = False);
begin
  inherited Create;
  FStrings := AStrings;
  FOwned := AOwned;
end;

destructor TOTAStringsAdapter.Destroy;
begin
  if FOwned then
    FStrings.Free;
  inherited Destroy;
end;

function TOTAStringsAdapter.GetCount: Integer;
begin
  Result := FStrings.Count;
end;

function TOTAStringsAdapter.GetData(const Index: Integer): Integer;
begin
  Result := Integer(FStrings.Objects[Index]);
end;

function TOTAStringsAdapter.GetItem(const Index: Integer): string;
begin
  Result := FStrings[Index];
end;

function TOTAStringsAdapter.GetName(const Index: Integer): string;
begin
  Result := FStrings.Names[Index];
end;

function TOTAStringsAdapter.GetStrings: TStrings;
begin
  Result := FStrings;
end;

function TOTAStringsAdapter.GetValue(const Name: string): string;
begin
  Result := FStrings.Values[Name];
end;

function TOTAStringsAdapter.GetValueFromIndex(const Index: Integer): string;
begin
  Result := FStrings.ValueFromIndex[Index];
end;

procedure TOTAStringsAdapter.SetData(const Index: Integer; Value: Integer);
begin
  FStrings.Objects[Index] := TObject(Value);
end;

procedure TOTAStringsAdapter.SetItem(const Index: Integer; const Value: string);
begin
  FStrings[Index] := Value;
end;

procedure TOTAStringsAdapter.SetValue(const Name, Value: string);
begin
  FStrings.Values[Name] := Value;
end;

procedure TOTAStringsAdapter.SetValueFromIndex(const Index: Integer; const Value: string);
begin
  FStrings.ValueFromIndex[Index] := Value;
end;

end.
